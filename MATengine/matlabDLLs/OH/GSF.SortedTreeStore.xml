<?xml version="1.0"?>
<doc>
    <assembly>
        <name>GSF.SortedTreeStore</name>
    </assembly>
    <members>
        <member name="T:GSF.Collections.ConcurrentIndexedDictionary`2">
            <summary>
            A thread safe indexed dictionary that can only be added to.
            </summary>
            <remarks>
            This is a special purpose class that supports only the Add and Get operations.
            It is designed to have indexing capabilities or dictionary lookup.
            </remarks>
        </member>
        <member name="P:GSF.Collections.ConcurrentIndexedDictionary`2.Count">
            <summary>
            Gets the number of items in the dictionary
            </summary>
        </member>
        <member name="P:GSF.Collections.ConcurrentIndexedDictionary`2.Item(System.Int32)">
            <summary>
            Gets the indexed item
            </summary>
            <param name="index">the index of the field</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Collections.ConcurrentIndexedDictionary`2.Get(`0)">
            <summary>
            Gets the key associated with the value.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Collections.ConcurrentIndexedDictionary`2.IndexOf(`0)">
            <summary>
            Gets the index of the <see cref="!:key"/>.
            </summary>
            <param name="key"></param>
            <returns>the index, or -1 if not found</returns>
        </member>
        <member name="M:GSF.Collections.ConcurrentIndexedDictionary`2.Add(`0,`1)">
            <summary>
            Adds the specified item to the list
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns>the index of the item</returns>
        </member>
        <member name="M:GSF.Collections.ConcurrentIndexedDictionary`2.GetOrAdd(`0,System.Func{`1})">
            <summary>
            Gets or adds a value for the specified key in one atomic operation.
            </summary>
            <param name="key">the key to get</param>
            <param name="createFunction">A method to create the value if it does not exist</param>
            <returns> The value. </returns>
        </member>
        <member name="T:GSF.Collections.ListExtensions">
            <summary>
            Extensions for <see cref="T:System.Collections.Generic.IList`1"/>
            </summary>
        </member>
        <member name="M:GSF.Collections.ListExtensions.ReplaceFirstNullOrAdd``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            Parses through the provided list and assigns <see cref="!:item"/> to the first null field. 
            Otherwise, it will add it to he end of the list.
            </summary>
            <param name="list">the list to iterate through</param>
            <param name="item">the item to add</param>
            <returns>the index of the added item</returns>
        </member>
        <member name="M:GSF.Collections.ListExtensions.ReplaceFirstNullOrAdd``1(System.Collections.Generic.List{``0},``0)">
            <summary>
            Parses through the provided list and assigns <see cref="!:item"/> to the first null field. 
            Otherwise, it will add it to he end of the list.
            </summary>
            <param name="list">the list to iterate through</param>
            <param name="item">the item to add</param>
            <returns>the index of the added item</returns>
        </member>
        <member name="T:GSF.Collections.WeakList`1">
            <summary>
            Creates a list of items that will be weak referenced.
            This list is thread safe and allows enumeration while adding and removing from the list.
            </summary>
            <typeparam name="T"></typeparam>
            <remarks>
            This is a special case list where all items in the list are weak referenced. Only include
            instances that are strong referenced somewhere. 
            For example, delegates will not work in this list unless it is strong referenced in the instance.
            This is because a delegate is a small wrapper of (Object,Method) and is usually recreated on the fly
            rather than stored. Therefore if the only reference to the delegate is passed to this list, it will be
            collected at the next GC cycle.
            </remarks>
        </member>
        <member name="T:GSF.Collections.WeakList`1.Snapshot">
            <summary>
            Contains a snapshot of the data so read operations can be non-blocking
            </summary>
        </member>
        <member name="M:GSF.Collections.WeakList`1.Snapshot.Grow">
            <summary>
            Grows the snapshot, doubling the size of the number of entries.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.Collections.WeakList`1.Snapshot.Remove(`0)">
            <summary>
            Removes all occurances of <see cref="!:item"/> from the list
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:GSF.Collections.WeakList`1.Snapshot.TryAdd(`0)">
            <summary>
            Attempts to add <see cref="!:item"/> to the list. 
            </summary>
            <param name="item"></param>
            <returns>returns true if added, false otherwise.</returns>
        </member>
        <member name="T:GSF.Collections.WeakList`1.Enumerator">
            <summary>
            An <see cref="T:System.Collections.Generic.IEnumerator`1"/> for <see cref="T:GSF.Collections.WeakList`1"/>
            </summary>
        </member>
        <member name="M:GSF.Collections.WeakList`1.Enumerator.#ctor(System.WeakReference[],System.Int32)">
            <summary>
            Creates a <see cref="T:GSF.Collections.WeakList`1.Enumerator"/>
            </summary>
            <param name="items">the weak referenced items.</param>
            <param name="count">the number of valid items in the list.</param>
        </member>
        <member name="P:GSF.Collections.WeakList`1.Enumerator.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
            </returns>
        </member>
        <member name="P:GSF.Collections.WeakList`1.Enumerator.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current element in the collection.
            </summary>
            <returns>
            The current element in the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:GSF.Collections.WeakList`1.Enumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:GSF.Collections.WeakList`1.Enumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:GSF.Collections.WeakList`1.Enumerator.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:GSF.Collections.WeakList`1.#ctor">
            <summary>
            Creates a <see cref="T:GSF.Collections.WeakList`1"/>
            </summary>
        </member>
        <member name="M:GSF.Collections.WeakList`1.Clear">
            <summary>
            Clears all of the times in the list. Method is thread safe.
            </summary>
        </member>
        <member name="M:GSF.Collections.WeakList`1.Add(`0)">
            <summary>
            Adds the <see cref="!:item"/> to the list. Method is thread safe.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:GSF.Collections.WeakList`1.Remove(`0)">
            <summary>
            Removes all occurances of the <see cref="!:item"/> from the list. Method is thread safe.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:GSF.Collections.WeakList`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:GSF.Collections.WeakList`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:GSF.Collections.WeakList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:GSF.Collections.BitArray">
            <summary>
            Provides an array of bits.  Much like the native .NET implementation, 
            however this focuses on providing a free space bit array.
            </summary>
        </member>
        <member name="F:GSF.Collections.BitArray.BitsPerElementShift">
            <summary>
            The number of bits to shift to get the index of the array
            </summary>
        </member>
        <member name="F:GSF.Collections.BitArray.BitsPerElementMask">
            <summary>
            The mask to apply to get the bit position of the value
            </summary>
        </member>
        <member name="F:GSF.Collections.BitArray.BitsPerElement">
            <summary>
            The number of bits per array element.
            </summary>
        </member>
        <member name="M:GSF.Collections.BitArray.#ctor(System.Boolean,System.Int32)">
            <summary>
            Initializes <see cref="T:GSF.Collections.BitArray"/>.
            </summary>
            <param name="initialState">Set to true to initial will all elements set.  False to have all elements cleared.</param>
            <param name="count">The number of bit positions to support</param>
        </member>
        <member name="P:GSF.Collections.BitArray.Item(System.Int32)">
            <summary>
            Gets/Sets individual bits in this array.
            </summary>
            <param name="index">the bit position to get.</param>
            <returns></returns>
        </member>
        <member name="P:GSF.Collections.BitArray.Count">
            <summary>
            Gets the number of bits this array contains.
            </summary>
        </member>
        <member name="P:GSF.Collections.BitArray.SetCount">
            <summary>
            Gets the number of bits that are set in this array.
            </summary>
        </member>
        <member name="P:GSF.Collections.BitArray.ClearCount">
            <summary>
            Gets the number of bits that are cleared in this array.
            </summary>
        </member>
        <member name="M:GSF.Collections.BitArray.GetBit(System.Int32)">
            <summary>
            Gets the status of the corresponding bit.
            </summary>
            <param name="index"></param>
            <returns>True if Set.  False if Cleared</returns>
        </member>
        <member name="M:GSF.Collections.BitArray.GetBitUnchecked(System.Int32)">
            <summary>
            Gets the status of the corresponding bit.
            This method does not validate the bounds of the array, 
            and will be Aggressively Inlined.
            </summary>
            <param name="index"></param>
            <returns>True if Set.  False if Cleared</returns>
            <remarks>
            The exact speed varies, but has been shown to be anywhere from 1 to 6 times faster. 
            (All smaller than a few nanoseconds. But in an inner loop, this can be a decent improvement.)
            </remarks>
        </member>
        <member name="M:GSF.Collections.BitArray.SetBit(System.Int32)">
            <summary>
            Sets the corresponding bit to true
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:GSF.Collections.BitArray.TrySetBit(System.Int32)">
            <summary>
            Sets the corresponding bit to true. 
            Returns true if the bit state was changed.
            </summary>
            <param name="index"></param>
            <remarks>True if the bit state was changed. False if the bit was already set.</remarks>
        </member>
        <member name="M:GSF.Collections.BitArray.ClearAll">
            <summary>
            Clears all bits.
            </summary>
        </member>
        <member name="M:GSF.Collections.BitArray.ClearBit(System.Int32)">
            <summary>
            Sets the corresponding bit to false
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:GSF.Collections.BitArray.TryClearBit(System.Int32)">
            <summary>
            Sets the corresponding bit to false.
            Returns true if the bit state was changed.
            </summary>
            <param name="index"></param>
            <remarks>True if the bit state was changed. False if the bit was already cleared.</remarks>
        </member>
        <member name="M:GSF.Collections.BitArray.ClearBits(System.Int32,System.Int32)">
            <summary>
            Clears a series of bits
            </summary>
            <param name="index">the starting index to clear</param>
            <param name="length">the length of bits</param>
        </member>
        <member name="M:GSF.Collections.BitArray.SetAll">
            <summary>
            Sets all bits.
            </summary>
        </member>
        <member name="M:GSF.Collections.BitArray.SetBits(System.Int32,System.Int32)">
            <summary>
            Sets a series of bits
            </summary>
            <param name="index">the starting index to clear</param>
            <param name="length">the length of bits</param>
        </member>
        <member name="M:GSF.Collections.BitArray.AreAllBitsSet(System.Int32,System.Int32)">
            <summary>
            Determines if any of the provided bits are set.
            </summary>
            <param name="index">the starting index</param>
            <param name="length">the length of the run</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Collections.BitArray.AreAllBitsCleared(System.Int32,System.Int32)">
            <summary>
            Determines if any of the provided bits are cleared.
            </summary>
            <param name="index">the starting index</param>
            <param name="length">the length of the run</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Collections.BitArray.SetCapacity(System.Int32)">
            <summary>
            Increases the capacity of the bit array. Decreasing capacity is currently not supported
            </summary>
            <param name="capacity">the number of bits to support</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Collections.BitArray.EnsureCapacity(System.Int32)">
            <summary>
            Verifies that the <see cref="T:GSF.Collections.BitArray"/> has the capacity 
            to store the provided number of elements.
            If not, the bit array will autogrow by a factor of 2 or at least the capacity
            </summary>
            <param name="capacity"></param>
        </member>
        <member name="M:GSF.Collections.BitArray.FindClearedBit">
            <summary>
            Returns the index of the first bit that is cleared. 
            -1 is returned if all bits are set.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.Collections.BitArray.FindSetBit">
            <summary>
            Returns the index of the first bit that is set. 
            -1 is returned if all bits are set.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.Collections.BitArray.GetAllSetBits">
            <summary>
            Yields a list of all bits that are set.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.Collections.BitArray.GetAllClearedBits">
            <summary>
            Yields a list of all bits that are cleared.
            </summary>
            <returns></returns>
        </member>
        <member name="T:GSF.Collections.SortedListConstructor">
            <summary>
            Quickly will create a <see cref="T:System.Collections.SortedList"/> from the provided list of keys and values
            </summary>
        </member>
        <member name="M:GSF.Collections.SortedListConstructor.Create``2(System.Collections.Generic.ICollection{``0},System.Collections.Generic.ICollection{``1})">
            <summary>
            Creates a sorted list from the provided keys and values.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="keys"></param>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="T:GSF.Collections.LargeArray`1">
            <summary>
            Since large arrays expand slowly, this class can quickly grow an array with millions of elements.
            It is highly advised that these objects are structs since keeping a list of millions of classes 
            will cause the garbage collection cycles to become very slow.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:GSF.Collections.LargeArray`1.#ctor">
            <summary>
            Creates a <see cref="T:GSF.Collections.LargeArray`1"/> with a jagged array depth of 1024 elements.
            </summary>
        </member>
        <member name="M:GSF.Collections.LargeArray`1.#ctor(System.Int32)">
            <summary>
            Creates a <see cref="T:GSF.Collections.LargeArray`1"/> with the specified jagged array depth.
            </summary>
            <param name="jaggedArrayDepth">the number of elements per jagged array. Rounds up to the nearest power of 2.</param>
        </member>
        <member name="P:GSF.Collections.LargeArray`1.Item(System.Int32)">
            <summary>
            Gets/Sets the value in the specified index of the array.
            </summary>
            <param name="index">The index to address</param>
            <returns></returns>
        </member>
        <member name="P:GSF.Collections.LargeArray`1.Capacity">
            <summary>
            Gets the number of items in the array.
            </summary>
        </member>
        <member name="M:GSF.Collections.LargeArray`1.SetCapacity(System.Int32)">
            <summary>
            Increases the capacity of the array to at least the given length. Will not reduce the size.
            </summary>
            <param name="length"></param>
            <returns>The current length of the list.</returns>
        </member>
        <member name="T:GSF.Collections.NullableLargeArray`1">
            <summary>
            Provides a high speed list that can have elements that can be null.
            It would be similiar to a List&lt;Nullable&lt;T&gt;&gt;() except provide high speed lookup for
            NextIndexOfNull like functions.
            </summary>
            <typeparam name="T">The type.</typeparam>
        </member>
        <member name="M:GSF.Collections.NullableLargeArray`1.#ctor">
            <summary>
            Creates a <see cref="T:GSF.Collections.NullableLargeArray`1"/>
            </summary>
        </member>
        <member name="M:GSF.Collections.NullableLargeArray`1.HasValue(System.Int32)">
            <summary>
            Returns if the object is not null.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Collections.NullableLargeArray`1.TryGetValue(System.Int32,`0@)">
            <summary>
            Tries to get the following value for the list.
            </summary>
            <param name="index"></param>
            <param name="value"></param>
            <returns>True if the item exists. False if null.</returns>
        </member>
        <member name="P:GSF.Collections.NullableLargeArray`1.Capacity">
            <summary>
            Gets the number of items that can be stored in the array.
            </summary>
        </member>
        <member name="P:GSF.Collections.NullableLargeArray`1.CountUsed">
            <summary>
            Gets the number of items that are in the array that are not null
            </summary>
        </member>
        <member name="P:GSF.Collections.NullableLargeArray`1.CountFree">
            <summary>
            Gets the number of available spaces in the array. Equal to <see cref="P:GSF.Collections.NullableLargeArray`1.Capacity"/> - <see cref="P:GSF.Collections.NullableLargeArray`1.CountUsed"/>.
            </summary>
        </member>
        <member name="P:GSF.Collections.NullableLargeArray`1.Item(System.Int32)">
            <summary>
            Gets the provided item from the array. 
            </summary>
            <param name="index">the index of the item</param>
            <returns>The item.</returns>
        </member>
        <member name="M:GSF.Collections.NullableLargeArray`1.SetCapacity(System.Int32)">
            <summary>
            Increases the capacity of the array to at least the given length. Will not reduce the size.
            </summary>
            <param name="length"></param>
            <returns>The current length of the list.</returns>
        </member>
        <member name="M:GSF.Collections.NullableLargeArray`1.GetValue(System.Int32)">
            <summary>
            Gets the specified item from the list.  Throws an exception if the item is null.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Collections.NullableLargeArray`1.SetNull(System.Int32)">
            <summary>
            Sets the following item to null.
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:GSF.Collections.NullableLargeArray`1.SetValue(System.Int32,`0)">
            <summary>
            Sets a value in the list.
            </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:GSF.Collections.NullableLargeArray`1.OverwriteValue(System.Int32,`0)">
            <summary>
            Replaces and existing value in the list. Throws an exception if the existing item is null.
            </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:GSF.Collections.NullableLargeArray`1.AddValue(`0)">
            <summary>
            Adds a new value to the list and locates it at the nearest possible empty location.
            If there is not enough room, the list is automatically expanded.
            </summary>
            <param name="value">The value to add.</param>
            <returns>the index where the value was placed.</returns>
        </member>
        <member name="M:GSF.Collections.NullableLargeArray`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the non-null elements of this collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:GSF.Collections.NullableLargeArray`1.Clear">
            <summary>
            Clears all elements in the list
            </summary>
        </member>
        <member name="T:GSF.Collections.ResourceQueue`1">
            <summary>
            Provides a thread safe queue that acts as a quazi buffer pool. 
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:GSF.Collections.ResourceQueue`1.#ctor(System.Func{`0},System.Int32,System.Int32)">
            <summary>
            Creates a new Resource Queue.
            </summary>
            <param name="instance">A delegate that will return the necessary queue.</param>
            <param name="initialCount">The initial number of resources to have in the queue.</param>
            <param name="maximumCount">The maximum number of items to hold in the queue at one time.</param>
        </member>
        <member name="M:GSF.Collections.ResourceQueue`1.Dequeue">
            <summary>
            Removes an item from the queue. If one does not exist, one is created.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.Collections.ResourceQueue`1.Enqueue(`0)">
            <summary>
            Addes an item back to the queue.
            </summary>
            <param name="resource">The resource to queue.</param>
        </member>
        <member name="T:GSF.Collections.ResourceQueueCollection`2">
            <summary>
            Provides a thread safe collection of many different resources of the same type.
            </summary>
            <typeparam name="TKey">An ICompariable type that is used to distinquish different resource queues.</typeparam>
            <typeparam name="TResource">They type of the resource queue.</typeparam>
        </member>
        <member name="M:GSF.Collections.ResourceQueueCollection`2.#ctor(System.Func{`1},System.Int32,System.Int32)">
            <summary>
            Creates a new ResourceQueueCollection.
            </summary>
            <param name="instance">A function to pass to the ResourceQueue for a given TCompare </param>
            <param name="initialCount">The initial size of each resource queue</param>
            <param name="maximumCount">The maximum size of each resource queue</param>
        </member>
        <member name="M:GSF.Collections.ResourceQueueCollection`2.#ctor(System.Func{`0,`1},System.Int32,System.Int32)">
            <summary>
            Creates a new ResourceQueueCollection.
            </summary>
            <param name="instance">A function that will return the function to pass to the ResourceQueue for a given TCompare </param>
            <param name="initialCount">The initial size of each resource queue</param>
            <param name="maximumCount">The maximum size of each resource queue</param>
        </member>
        <member name="M:GSF.Collections.ResourceQueueCollection`2.#ctor(System.Func{`0,System.Func{`1}},System.Int32,System.Int32)">
            <summary>
            Creates a new ResourceQueueCollection.
            </summary>
            <param name="instance">A function that will return the function to pass to the ResourceQueue for a given TCompare </param>
            <param name="initialCount">The initial size of each resource queue</param>
            <param name="maximumCount">The maximum size of each resource queue</param>
        </member>
        <member name="M:GSF.Collections.ResourceQueueCollection`2.#ctor(System.Func{`0,System.Func{`1}},System.Func{`0,System.Int32},System.Func{`0,System.Int32})">
            <summary>
            Creates a new ResourceQueueCollection.
            </summary>
            <param name="instance">A function that will return the function to pass to the ResourceQueue for a given TCompare </param>
            <param name="initialCount">The initial size of each resource queue</param>
            <param name="maximumCount">The maximum size of each resource queue</param>
        </member>
        <member name="P:GSF.Collections.ResourceQueueCollection`2.Item(`0)">
            <summary>
            Gets the resource queue for a key of this.
            </summary>
            <param name="key">The key identifying the resource queue to pull from</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Collections.ResourceQueueCollection`2.GetResourceQueue(`0)">
            <summary>
            Gets the resource queue for a key of this.
            </summary>
            <param name="key">The key identifying the resource queue to pull from</param>
            <returns></returns>
        </member>
        <member name="T:GSF.BitConvert">
            <summary>
            Contains some random and useful functions.
            </summary>
        </member>
        <member name="T:GSF.DateTimeExtensions">
            <summary>
            Helper methods for type <see cref="T:System.DateTime"/>
            </summary>
        </member>
        <member name="M:GSF.DateTimeExtensions.RoundDownToNearestDay(System.DateTime)">
            <summary>
            Rounds the supplied datetime down to the nearest day.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.DateTimeExtensions.RoundDownToNearestHour(System.DateTime)">
            <summary>
            Rounds the supplied datetime down to the nearest hour.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.DateTimeExtensions.RoundDownToNearestMinute(System.DateTime)">
            <summary>
            Rounds the supplied datetime down to the nearest minute.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.DateTimeExtensions.RoundDownToNearestSecond(System.DateTime)">
            <summary>
            Rounds the supplied datetime down to the nearest second.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.DateTimeExtensions.RoundDownToNearestMillisecond(System.DateTime)">
            <summary>
            Rounds the supplied datetime down to the nearest millisecond.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:GSF.IO.BinaryStreamBase">
            <summary>
            An abstract class for reading/writing to a little endian stream.
            </summary>
        </member>
        <member name="F:GSF.IO.BinaryStreamBase.Utf8">
            <summary>
            A shared instance of UTF8 encoding.
            </summary>
        </member>
        <member name="F:GSF.IO.BinaryStreamBase.Stream">
            <summary>
            A <see cref="F:GSF.IO.BinaryStreamBase.Stream"/> implementation of this <see cref="T:GSF.IO.BinaryStreamBase"/>
            </summary>
        </member>
        <member name="F:GSF.IO.BinaryStreamBase.m_buffer">
            <summary>
            A temporary buffer where data is read/written to before it is serialized to the stream.
            </summary>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.#ctor">
            <summary>
            Creates a <see cref="T:GSF.IO.BinaryStreamBase"/>
            </summary>
        </member>
        <member name="P:GSF.IO.BinaryStreamBase.CanWrite">
            <summary>
            When overridden in a derived class, gets a value indicating whether the current stream supports writing.
            </summary>
            <returns>
            true if the stream supports writing; otherwise, false.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="P:GSF.IO.BinaryStreamBase.CanRead">
            <summary>
            When overridden in a derived class, gets a value indicating whether the current stream supports reading.
            </summary>
            <returns>
            true if the stream supports reading; otherwise, false.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="P:GSF.IO.BinaryStreamBase.CanSeek">
            <summary>
            When overridden in a derived class, gets a value indicating whether the current stream supports seeking.
            </summary>
            <returns>
            true if the stream supports seeking; otherwise, false.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="P:GSF.IO.BinaryStreamBase.Length">
            <summary>
            When overridden in a derived class, gets the length in bytes of the stream.
            </summary>
            <returns>
            A long value representing the length of the stream in bytes.
            </returns>
            <exception cref="T:System.NotSupportedException">A class derived from Stream does not support seeking. </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        </member>
        <member name="P:GSF.IO.BinaryStreamBase.Position">
            <summary>
            When overridden in a derived class, gets or sets the position within the current stream.
            </summary>
            <returns>
            The current position within the stream.
            </returns>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception><exception cref="T:System.NotSupportedException">The stream does not support seeking. </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            When overridden in a derived class, writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.
            </summary>
            <param name="buffer">An array of bytes. This method copies <paramref name="count"/> bytes from <paramref name="buffer"/> to the current stream. </param><param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which to begin copying bytes to the current stream. </param><param name="count">The number of bytes to be written to the current stream. </param><filterpriority>1</filterpriority>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.SetLength(System.Int64)">
            <summary>
            When overridden in a derived class, sets the length of the current stream.
            </summary>
            <param name="value">The desired length of the current stream in bytes. </param><exception cref="T:System.IO.IOException">An I/O error occurs. </exception><exception cref="T:System.NotSupportedException">The stream does not support both writing and seeking, such as if the stream is constructed from a pipe or console output. </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.Flush">
            <summary>
            When overridden in a derived class, clears all buffers for this stream and causes any buffered data to be written to the underlying device.
            </summary>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            When overridden in a derived class, reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.
            </summary>
            <returns>
            The total number of bytes read into the buffer. This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.
            </returns>
            <param name="buffer">An array of bytes. When this method returns, the buffer contains the specified byte array with the values between <paramref name="offset"/> and (<paramref name="offset"/> + <paramref name="count"/> - 1) replaced by the bytes read from the current source. </param><param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which to begin storing the data read from the current stream. </param><param name="count">The maximum number of bytes to be read from the current stream. </param><exception cref="T:System.ArgumentException">The sum of <paramref name="offset"/> and <paramref name="count"/> is larger than the buffer length. </exception><exception cref="T:System.ArgumentNullException"><paramref name="buffer"/> is null. </exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset"/> or <paramref name="count"/> is negative. </exception><exception cref="T:System.IO.IOException">An I/O error occurs. </exception><exception cref="T:System.NotSupportedException">The stream does not support reading. </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            When overridden in a derived class, sets the position within the current stream.
            </summary>
            <returns>
            The new position within the current stream.
            </returns>
            <param name="offset">A byte offset relative to the <paramref name="origin"/> parameter. </param><param name="origin">A value of type <see cref="T:System.IO.SeekOrigin"/> indicating the reference point used to obtain the new position. </param><exception cref="T:System.IO.IOException">An I/O error occurs. </exception><exception cref="T:System.NotSupportedException">The stream does not support seeking, such as if the stream is constructed from a pipe or console output. </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.UpdateLocalBuffer(System.Boolean)">
            <summary>
            Updates the local buffer data.
            </summary>
            <param name="isWriting">hints to the stream if write access is desired.</param>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.Copy(System.Int64,System.Int64,System.Int32)">
            <summary>
            Copies a specified number of bytes to a new location
            </summary>
            <param name="source"></param>
            <param name="destination"></param>
            <param name="length"></param>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.InsertBytes(System.Int32,System.Int32)">
            <summary>
            Inserts a certain number of bytes into the stream, shifting valid data to the right.  The stream's position remains unchanged. 
            (ie. pointing to the beginning of the newly inserted bytes).
            </summary>
            <param name="numberOfBytes">The number of bytes to insert</param>
            <param name="lengthOfValidDataToShift">The number of bytes that will need to be shifted to perform this insert</param>
            <remarks>Internally this fuction merely acomplishes an Array.Copy(stream,position,stream,position+numberOfBytes,lengthOfValidDataToShift)
            However, it's much more complicated than this. So this is a pretty useful function.
            The newly created space is uninitialized. 
            </remarks>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.RemoveBytes(System.Int32,System.Int32)">
            <summary>
            Removes a certain number of bytes from the stream, shifting valid data after this location to the left.  The stream's position remains unchanged. 
            (ie. pointing to where the data used to exist).
            </summary>
            <param name="numberOfBytes">The distance to shift.  Positive means shifting to the right (ie. inserting data)
            Negative means shift to the left (ie. deleteing data)</param>
            <param name="lengthOfValidDataToShift">The number of bytes that will need to be shifted to perform the remove. 
            This only includes the data that is valid after the shift is complete, and not the data that will be removed.</param>
            <remarks>Internally this fuction merely acomplishes an Array.Copy(stream,position+numberOfBytes,stream,position,lengthOfValidDataToShift)
            However, it's much more complicated than this. So this is a pretty useful function.
            The space at the end of the copy is uninitialized. 
            </remarks>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.Write(System.SByte)">
            <summary>
            Writes the specifed <see cref="!:value"/> to the underlying stream in little-endian format.
            </summary>
            <param name="value">the value to write</param>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.Write(System.Boolean)">
            <summary>
            Writes the specifed <see cref="!:value"/> to the underlying stream in little-endian format.
            </summary>
            <param name="value">the value to write</param>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.Write(System.UInt16)">
            <summary>
            Writes the specifed <see cref="!:value"/> to the underlying stream in little-endian format.
            </summary>
            <param name="value">the value to write</param>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.Write(System.UInt32)">
            <summary>
            Writes the specifed <see cref="!:value"/> to the underlying stream in little-endian format.
            </summary>
            <param name="value">the value to write</param>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.Write(System.UInt64)">
            <summary>
            Writes the specifed <see cref="!:value"/> to the underlying stream in little-endian format.
            </summary>
            <param name="value">the value to write</param>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.Write(System.Single)">
            <summary>
            Writes the specifed <see cref="!:value"/> to the underlying stream in little-endian format.
            </summary>
            <param name="value">the value to write</param>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.Write(System.Double)">
            <summary>
            Writes the specifed <see cref="!:value"/> to the underlying stream in little-endian format.
            </summary>
            <param name="value">the value to write</param>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.Write(System.DateTime)">
            <summary>
            Writes the specifed <see cref="!:value"/> to the underlying stream in little-endian format.
            </summary>
            <param name="value">the value to write</param>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.Write(System.Byte)">
            <summary>
            Writes the specifed <see cref="!:value"/> to the underlying stream in little-endian format.
            </summary>
            <param name="value">the value to write</param>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.Write(System.Int16)">
            <summary>
            Writes the specifed <see cref="!:value"/> to the underlying stream in little-endian format.
            </summary>
            <param name="value">the value to write</param>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.Write(System.Int32)">
            <summary>
            Writes the specifed <see cref="!:value"/> to the underlying stream in little-endian format.
            </summary>
            <param name="value">the value to write</param>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.Write(System.Int64)">
            <summary>
            Writes the specifed <see cref="!:value"/> to the underlying stream in little-endian format.
            </summary>
            <param name="value">the value to write</param>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.Write(System.Decimal)">
            <summary>
            Writes the specifed <see cref="!:value"/> to the underlying stream in little-endian format.
            </summary>
            <param name="value">the value to write</param>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.Write(System.Guid)">
            <summary>
            Writes the specifed <see cref="!:value"/> to the underlying stream in little-endian format.
            </summary>
            <param name="value">the value to write</param>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.WriteUInt24(System.UInt32)">
            <summary>
            Writes the specifed <see cref="!:value"/> to the underlying stream in little-endian format.
            </summary>
            <param name="value">the value to write</param>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.WriteUInt40(System.UInt64)">
            <summary>
            Writes the specifed <see cref="!:value"/> to the underlying stream in little-endian format.
            </summary>
            <param name="value">the value to write</param>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.WriteUInt48(System.UInt64)">
            <summary>
            Writes the specifed <see cref="!:value"/> to the underlying stream in little-endian format.
            </summary>
            <param name="value">the value to write</param>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.WriteUInt56(System.UInt64)">
            <summary>
            Writes the specifed <see cref="!:value"/> to the underlying stream in little-endian format.
            </summary>
            <param name="value">the value to write</param>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.WriteUInt(System.UInt64,System.Int32)">
            <summary>
            Writes the specifed <see cref="!:value"/> to the underlying stream in little-endian format.
            </summary>
            <param name="value">the value to write</param>
            <param name="bytes">the number of bytes to write.</param>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.Write7Bit(System.UInt32)">
            <summary>
            Writes the specifed <see cref="!:value"/> to the underlying stream in little-endian format.
            </summary>
            <param name="value">the value to write</param>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.Write7Bit(System.UInt64)">
            <summary>
            Writes the specifed <see cref="!:value"/> to the underlying stream in little-endian format.
            </summary>
            <param name="value">the value to write</param>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.Write(System.String)">
            <summary>
            Writes the specifed <see cref="!:value"/> to the underlying stream in little-endian format.
            </summary>
            <param name="value">the value to write</param>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.Write(System.Byte[])">
            <summary>
            Writes the specifed <see cref="!:value"/> to the underlying stream in little-endian format.
            </summary>
            <param name="value">the value to write</param>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.WriteWithLength(System.Byte[])">
            <summary>
            Writes the specifed <see cref="!:value"/> to the underlying stream in little-endian format.
            </summary>
            <param name="value">the value to write</param>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.Write(System.Byte*,System.Int32)">
            <summary>
            Writes the specifed <see cref="!:buffer"/> to the underlying stream in little-endian format.
            </summary>
            <param name="buffer">the pointer to the first byte</param>
            <param name="length">the number of bytes to write</param>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.ReadInt8">
            <summary>
            Reads from the underlying stream in little endian format. Advancing the position.
            </summary>
            <returns>The data read</returns>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.ReadBoolean">
            <summary>
            Reads from the underlying stream in little endian format. Advancing the position.
            </summary>
            <returns>The data read</returns>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.ReadUInt16">
            <summary>
            Reads from the underlying stream in little endian format. Advancing the position.
            </summary>
            <returns>The data read</returns>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.ReadUInt24">
            <summary>
            Reads from the underlying stream in little endian format. Advancing the position.
            </summary>
            <returns>The data read</returns>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.ReadUInt32">
            <summary>
            Reads from the underlying stream in little endian format. Advancing the position.
            </summary>
            <returns>The data read</returns>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.ReadUInt40">
            <summary>
            Reads from the underlying stream in little endian format. Advancing the position.
            </summary>
            <returns>The data read</returns>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.ReadUInt48">
            <summary>
            Reads from the underlying stream in little endian format. Advancing the position.
            </summary>
            <returns>The data read</returns>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.ReadUInt56">
            <summary>
            Reads from the underlying stream in little endian format. Advancing the position.
            </summary>
            <returns>The data read</returns>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.ReadUInt64">
            <summary>
            Reads from the underlying stream in little endian format. Advancing the position.
            </summary>
            <returns>The data read</returns>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.ReadUInt(System.Int32)">
            <summary>
            Reads from the underlying stream in little endian format. Advancing the position.
            </summary>
            <param name="bytes">the number of bytes in the value</param>
            <returns>The data read</returns>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.ReadSingle">
            <summary>
            Reads from the underlying stream in little endian format. Advancing the position.
            </summary>
            <returns>The data read</returns>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.ReadDouble">
            <summary>
            Reads from the underlying stream in little endian format. Advancing the position.
            </summary>
            <returns>The data read</returns>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.ReadDateTime">
            <summary>
            Reads from the underlying stream in little endian format. Advancing the position.
            </summary>
            <returns>The data read</returns>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.ReadUInt8">
            <summary>
            Reads from the underlying stream in little endian format. Advancing the position.
            </summary>
            <returns>The data read</returns>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.ReadInt16">
            <summary>
            Reads from the underlying stream in little endian format. Advancing the position.
            </summary>
            <returns>The data read</returns>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.ReadInt32">
            <summary>
            Reads from the underlying stream in little endian format. Advancing the position.
            </summary>
            <returns>The data read</returns>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.ReadInt64">
            <summary>
            Reads from the underlying stream in little endian format. Advancing the position.
            </summary>
            <returns>The data read</returns>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.ReadDecimal">
            <summary>
            Reads from the underlying stream in little endian format. Advancing the position.
            </summary>
            <returns>The data read</returns>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.ReadGuid">
            <summary>
            Reads from the underlying stream in little endian format. Advancing the position.
            </summary>
            <returns>The data read</returns>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.Read7BitUInt32">
            <summary>
            Reads from the underlying stream in little endian format. Advancing the position.
            </summary>
            <returns>The data read</returns>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.Read7BitUInt64">
            <summary>
            Reads from the underlying stream in little endian format. Advancing the position.
            </summary>
            <returns>The data read</returns>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.ReadBytes(System.Int32)">
            <summary>
            Reads from the underlying stream in little endian format. Advancing the position.
            </summary>
            <param name="count">the number of bytes to read</param>
            <returns>The data read</returns>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.ReadBytes">
            <summary>
            Reads from the underlying stream in little endian format. Advancing the position.
            </summary>
            <returns>The data read</returns>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.TryReadBytes(System.Int32,System.Byte[]@)">
            <summary>
            Reads a byte array from the provided stream. 
            If the size of the stream exceedes <see cref="!:maxLength"/>
            <see cref="!:value"/> is set to null and this function returns false.
            </summary>
            <param name="maxLength"></param>
            <param name="value"></param>
            <returns></returns>
            <remarks>
            This method can be used to limit the byte size returned.
            Since an untrusted source could claim that the length is 
            <see cref="F:System.Int32.MaxValue"/>, this prevents allocating 2GB
            of RAM to store the result.
            </remarks>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.ReadString">
            <summary>
            Reads from the underlying stream in little endian format. Advancing the position.
            </summary>
            <returns>The data read</returns>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.TryReadString(System.Int32,System.String@)">
            <summary>
            Reads a string from the provided stream. 
            If the size of the string exceedes <see cref="!:maxLength"/>
            <see cref="!:value"/> is set to null and this function returns false.
            </summary>
            <param name="maxLength">The maximum number of characters in the string.</param>
            <param name="value">an output</param>
            <returns></returns>
            <remarks>
            This method can be used to limit the byte size returned.
            Since an untrusted source could claim that the length is 
            <see cref="F:System.Int32.MaxValue"/>, this prevents allocating 2GB
            of RAM to store the result.
            </remarks>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.ReadAll(System.Byte*,System.Int32)">
            <summary>
            Reads from the underlying stream in little endian format. Advancing the position.
            </summary>
            <param name="buffer">the pointer to write the data to</param>
            <param name="length">the number of bytes to read</param>
            <returns>The data read</returns>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.ReadAll(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads all of the provided bytes. Will not return prematurely, 
            but continue to execute a <see cref="M:GSF.IO.BinaryStreamBase.Read(System.Byte[],System.Int32,System.Int32)"/> command until the entire
            <see cref="!:length"/> has been read.
            </summary>
            <param name="buffer"></param>
            <param name="position"></param>
            <param name="length"></param>
            <exception cref="T:System.IO.EndOfStreamException">occurs if the end of the stream has been reached.</exception>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.Dispose">
            <summary>
            Releases all the resources used by the <see cref="T:GSF.IO.BinaryStreamBase"/> object.
            </summary>
        </member>
        <member name="M:GSF.IO.BinaryStreamBase.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:GSF.IO.BinaryStreamBase"/> object and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="T:GSF.IO.BinaryStreamPointerBase">
            <summary>
            An implementation of <see cref="T:GSF.IO.BinaryStreamBase"/> that is pointer based.
            </summary>
        </member>
        <member name="M:GSF.IO.BinaryStreamPointerBase.#ctor">
            <summary>
            Creates a <see cref="T:GSF.IO.BinaryStreamPointerBase"/>.
            </summary>
        </member>
        <member name="P:GSF.IO.BinaryStreamPointerBase.PointerVersion">
            <summary>
            Gets the pointer version number assuming that this binary stream has an unmanaged buffer backing this stream. 
            If the pointer version is the same, than any pointer acquired is still valid.
            </summary>
        </member>
        <member name="F:GSF.IO.BinaryStreamPointerBase.FirstPosition">
            <summary>
            The position that corresponds to the first byte in the buffer.
            </summary>
        </member>
        <member name="F:GSF.IO.BinaryStreamPointerBase.LastPosition">
            <summary>
            Contains the position for the last position
            </summary>
        </member>
        <member name="F:GSF.IO.BinaryStreamPointerBase.Current">
            <summary>
            the current position data.
            </summary>
        </member>
        <member name="F:GSF.IO.BinaryStreamPointerBase.First">
            <summary>
            the first position of the block
            </summary>
        </member>
        <member name="F:GSF.IO.BinaryStreamPointerBase.LastRead">
            <summary>
            one past the last address for reading
            </summary>
        </member>
        <member name="F:GSF.IO.BinaryStreamPointerBase.LastWrite">
            <summary>
            one past the last address for writing
            </summary>
        </member>
        <member name="P:GSF.IO.BinaryStreamPointerBase.Position">
            <summary>
            Gets/Sets the current position for the stream.
            <remarks>It is important to use this to Get/Set the position from the underlying stream since 
            this class buffers the results of the query.  Setting this field does not gaurentee that
            the underlying stream will get set. Call FlushToUnderlyingStream to acomplish this.</remarks>
            </summary>
        </member>
        <member name="P:GSF.IO.BinaryStreamPointerBase.RemainingReadLength">
            <summary>
            Returns the number of bytes available at the end of the stream.
            </summary>
        </member>
        <member name="P:GSF.IO.BinaryStreamPointerBase.RemainingWriteLength">
            <summary>
            Returns the number of bytes available at the end of the stream for writing purposes.
            </summary>
        </member>
        <member name="M:GSF.IO.BinaryStreamPointerBase.GetWritePointer(System.Int64,System.Int32)">
            <summary>
            Gets a pointer from the current position that can be used for writing up the the provided length.
            The current position is not advanced after calling this function.
            </summary>
            <param name="position"></param>
            <param name="length">the number of bytes valid for the writing.</param>
            <returns></returns>
            <remarks>This method will throw an exeption if the provided length cannot be provided.</remarks>
        </member>
        <member name="M:GSF.IO.BinaryStreamPointerBase.GetReadPointer(System.Int64,System.Int32)">
            <summary>
            Gets a pointer from the current position that can be used for writing up the the provided length.
            The current position is not advanced after calling this function.
            </summary>
            <param name="position"></param>
            <param name="length">the number of bytes valid for the writing.</param>
            <returns></returns>
            <remarks>This method will throw an exeption if the provided length cannot be provided.</remarks>
        </member>
        <member name="M:GSF.IO.BinaryStreamPointerBase.GetReadPointer(System.Int64,System.Int32,System.Boolean@)">
            <summary>
            Gets a pointer from the current position that can be used for writing up the the provided length.
            The current position is not advanced after calling this function.
            </summary>
            <param name="position"></param>
            <param name="length">the number of bytes valid for the writing.</param>
            <param name="supportsWriting">an output parameter detailing if writing to this block is supported.</param>
            <returns></returns>
            <remarks>This method will throw an exeption if the provided length cannot be provided.</remarks>
        </member>
        <member name="M:GSF.IO.BinaryStreamPointerBase.Copy(System.Int64,System.Int64,System.Int32)">
            <summary>
            Copies a specified number of bytes to a new location
            </summary>
            <param name="source"></param>
            <param name="destination"></param>
            <param name="length"></param>
        </member>
        <member name="T:GSF.IO.BinaryStreamStream">
            <summary>
            A <see cref="T:System.IO.Stream"/> wrapper around a <see cref="T:GSF.IO.BinaryStreamBase"/>. 
            </summary>
            <remarks>
            A <see cref="T:System.IO.Stream"/> inherits from <see cref="T:System.MarshalByRefObject"/>
            which prevents any methods from inlining. Therefore a <see cref="T:GSF.IO.BinaryStreamBase"/>
            will not inhert from <see cref="T:System.IO.Stream"/>.
            </remarks>
        </member>
        <member name="M:GSF.IO.BinaryStreamStream.#ctor(GSF.IO.BinaryStreamBase)">
            <summary>
            Creates a <see cref="T:System.IO.Stream"/> wrapper around a <see cref="T:GSF.IO.BinaryStreamBase"/>.
            </summary>
            <param name="baseStream"></param>
        </member>
        <member name="M:GSF.IO.BinaryStreamStream.Flush">
            <summary>
            When overridden in a derived class, clears all buffers for this stream and causes any buffered data to be written to the underlying device.
            </summary>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:GSF.IO.BinaryStreamStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            When overridden in a derived class, sets the position within the current stream.
            </summary>
            <returns>
            The new position within the current stream.
            </returns>
            <param name="offset">A byte offset relative to the <paramref name="origin"/> parameter. </param><param name="origin">A value of type <see cref="T:System.IO.SeekOrigin"/> indicating the reference point used to obtain the new position. </param><exception cref="T:System.IO.IOException">An I/O error occurs. </exception><exception cref="T:System.NotSupportedException">The stream does not support seeking, such as if the stream is constructed from a pipe or console output. </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        </member>
        <member name="M:GSF.IO.BinaryStreamStream.SetLength(System.Int64)">
            <summary>
            When overridden in a derived class, sets the length of the current stream.
            </summary>
            <param name="value">The desired length of the current stream in bytes. </param><exception cref="T:System.IO.IOException">An I/O error occurs. </exception><exception cref="T:System.NotSupportedException">The stream does not support both writing and seeking, such as if the stream is constructed from a pipe or console output. </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:GSF.IO.BinaryStreamStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            When overridden in a derived class, reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.
            </summary>
            <returns>
            The total number of bytes read into the buffer. This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.
            </returns>
            <param name="buffer">An array of bytes. When this method returns, the buffer contains the specified byte array with the values between <paramref name="offset"/> and (<paramref name="offset"/> + <paramref name="count"/> - 1) replaced by the bytes read from the current source. </param><param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which to begin storing the data read from the current stream. </param><param name="count">The maximum number of bytes to be read from the current stream. </param><exception cref="T:System.ArgumentException">The sum of <paramref name="offset"/> and <paramref name="count"/> is larger than the buffer length. </exception><exception cref="T:System.ArgumentNullException"><paramref name="buffer"/> is null. </exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset"/> or <paramref name="count"/> is negative. </exception><exception cref="T:System.IO.IOException">An I/O error occurs. </exception><exception cref="T:System.NotSupportedException">The stream does not support reading. </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        </member>
        <member name="M:GSF.IO.BinaryStreamStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            When overridden in a derived class, writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.
            </summary>
            <param name="buffer">An array of bytes. This method copies <paramref name="count"/> bytes from <paramref name="buffer"/> to the current stream. </param><param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which to begin copying bytes to the current stream. </param><param name="count">The number of bytes to be written to the current stream. </param><filterpriority>1</filterpriority>
        </member>
        <member name="P:GSF.IO.BinaryStreamStream.CanRead">
            <summary>
            When overridden in a derived class, gets a value indicating whether the current stream supports reading.
            </summary>
            <returns>
            true if the stream supports reading; otherwise, false.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="P:GSF.IO.BinaryStreamStream.CanSeek">
            <summary>
            When overridden in a derived class, gets a value indicating whether the current stream supports seeking.
            </summary>
            <returns>
            true if the stream supports seeking; otherwise, false.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="P:GSF.IO.BinaryStreamStream.CanWrite">
            <summary>
            When overridden in a derived class, gets a value indicating whether the current stream supports writing.
            </summary>
            <returns>
            true if the stream supports writing; otherwise, false.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="P:GSF.IO.BinaryStreamStream.Length">
            <summary>
            When overridden in a derived class, gets the length in bytes of the stream.
            </summary>
            <returns>
            A long value representing the length of the stream in bytes.
            </returns>
            <exception cref="T:System.NotSupportedException">A class derived from Stream does not support seeking. </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        </member>
        <member name="P:GSF.IO.BinaryStreamStream.Position">
            <summary>
            When overridden in a derived class, gets or sets the position within the current stream.
            </summary>
            <returns>
            The current position within the stream.
            </returns>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception><exception cref="T:System.NotSupportedException">The stream does not support seeking. </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        </member>
        <member name="T:GSF.IO.BinaryStreamWrapper">
            <summary>
            A simple wrapper of a <see cref="T:System.IO.Stream"/>. Provides no caching functionality.
            </summary>
        </member>
        <member name="P:GSF.IO.BinaryStreamWrapper.Position">
            <summary>
            Gets/Sets the current position for the stream.
            <remarks>It is important to use this to Get/Set the position from the underlying stream since 
            this class buffers the results of the query.  Setting this field does not gaurentee that
            the underlying stream will get set. Call FlushToUnderlyingStream to acomplish this.</remarks>
            </summary>
        </member>
        <member name="T:GSF.IO.FileStructure.SimplifiedSubFileStreamIoSession">
            <summary>
            An IoSession for a Simplified Sub File Stream
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.SimplifiedSubFileStreamIoSession.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:GSF.IO.FileStructure.SimplifiedSubFileStreamIoSession"/> object and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="M:GSF.IO.FileStructure.SimplifiedSubFileStreamIoSession.Clear">
            <summary>
            Sets the current usage of the <see cref="T:GSF.IO.Unmanaged.BinaryStreamIoSessionBase"/> to null.
            </summary>
        </member>
        <member name="T:GSF.IO.FileStructure.SimplifiedSubFileStream">
            <summary>
            Provides a file stream that can be used to open a file and does all of the background work 
            required to translate virtual position data into physical ones.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.SimplifiedSubFileStream.m_disposed">
            <summary>
            Determines if the file stream has been disposed.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.SimplifiedSubFileStream.m_fileHeaderBlock">
            <summary>
            The FileAllocationTable
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.SimplifiedSubFileStream.m_blockSize">
            <summary>
            The size of the block.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.SimplifiedSubFileStream.m_stream">
            <summary>
            The Disk Subsystem.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.SimplifiedSubFileStream.m_subFile">
            <summary>
            The file used by the stream.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.SimplifiedSubFileStream.#ctor(System.IO.FileStream,GSF.IO.FileStructure.SubFileHeader,GSF.IO.FileStructure.FileHeaderBlock)">
            <summary>
            Creates an SimplifiedSubFileStream
            </summary>
            <param name="stream">The location to read from.</param>
            <param name="subFile">The file to read.</param>
            <param name="fileHeaderBlock">The FileAllocationTable</param>
        </member>
        <member name="P:GSF.IO.FileStructure.SimplifiedSubFileStream.IsReadOnly">
            <summary>
            Gets if this file was opened in readonly mode.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.SimplifiedSubFileStream.IsDisposed">
            <summary>
            Determines if the file system has been disposed yet.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.SimplifiedSubFileStream.RemainingSupportedIoSessions">
            <summary>
            Gets the number of available simultaneous read/write sessions.
            </summary>
            <remarks>This value is used to determine if a binary stream can be cloned
            to improve read/write/copy performance.</remarks>
        </member>
        <member name="M:GSF.IO.FileStructure.SimplifiedSubFileStream.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:GSF.IO.FileStructure.SimplifiedSubFileStream.GSF#IO#Unmanaged#ISupportsBinaryStream#CreateIoSession">
            <summary>
            Aquire an IO Session.
            </summary>
        </member>
        <member name="T:GSF.IO.FileStructure.SimplifiedFileWriter">
            <summary>
            Assists in the writing of a simplified file. This file can only be appended to 
            and it must be sequentially written.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.SimplifiedFileWriter.#ctor(System.String,System.String,System.Int32,System.Guid[])">
            <summary>
            Creates a simplified file writer.
            </summary>
            <param name="pendingFileName"></param>
            <param name="completeFileName"></param>
            <param name="blockSize"></param>
            <param name="flags"></param>
        </member>
        <member name="M:GSF.IO.FileStructure.SimplifiedFileWriter.CreateFile(GSF.IO.FileStructure.SubFileName)">
            <summary>
            Creates and Opens a new file on the current file system.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.IO.FileStructure.SimplifiedFileWriter.Commit">
            <summary>
            Commits the changes to the disk.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.SimplifiedFileWriter.Dispose">
            <summary>
            Releases all the resources used by the <see cref="T:GSF.IO.FileStructure.SimplifiedFileWriter"/> object.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.SimplifiedFileWriter.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:GSF.IO.FileStructure.SimplifiedFileWriter"/> object and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="T:GSF.IO.FileStructure.SubFileStream">
            <summary>
            Provides a file stream that can be used to open a file and does all of the background work 
            required to translate virtual position data into physical ones.
            </summary>
        </member>
        <member name="T:GSF.IO.FileStructure.SubFileStream.SimplifiedIoSession">
            <summary>
            An IoSession for the sub file stream.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.SubFileStream.SimplifiedIoSession.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:GSF.IO.FileStructure.SubFileStream.IoSession"/> object and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="M:GSF.IO.FileStructure.SubFileStream.SimplifiedIoSession.Clear">
            <summary>
            Sets the current usage of the <see cref="T:GSF.IO.Unmanaged.BinaryStreamIoSessionBase"/> to null.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.SubFileStream.m_disposed">
            <summary>
            Determines if the file stream has been disposed.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.SubFileStream.m_isReadOnly">
            <summary>
            Determines if the filestream can be written to.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.SubFileStream.m_fileHeaderBlock">
            <summary>
            The FileAllocationTable
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.SubFileStream.m_dataReader">
            <summary>
            The Disk Subsystem.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.SubFileStream.m_subFile">
            <summary>
            The file used by the stream.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.SubFileStream.#ctor(GSF.IO.FileStructure.Media.DiskIo,GSF.IO.FileStructure.SubFileHeader,GSF.IO.FileStructure.FileHeaderBlock,System.Boolean)">
            <summary>
            Creates an SubFileStream
            </summary>
            <param name="dataReader">The location to read from.</param>
            <param name="subFile">The file to read.</param>
            <param name="fileHeaderBlock">The FileAllocationTable</param>
            <param name="isReadOnly">Determines if the stream allows editing.</param>
        </member>
        <member name="P:GSF.IO.FileStructure.SubFileStream.IsReadOnly">
            <summary>
            Gets if this file was opened in readonly mode.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.SubFileStream.IsDisposed">
            <summary>
            Determines if the file system has been disposed yet.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.SubFileStream.RemainingSupportedIoSessions">
            <summary>
            Gets the number of available simultaneous read/write sessions.
            </summary>
            <remarks>This value is used to determine if a binary stream can be cloned
            to improve read/write/copy performance.</remarks>
        </member>
        <member name="M:GSF.IO.FileStructure.SubFileStream.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:GSF.IO.FileStructure.SubFileStream.GSF#IO#Unmanaged#ISupportsBinaryStream#CreateIoSession">
            <summary>
            Aquire an IO Session.
            </summary>
        </member>
        <member name="T:GSF.IO.FileStructure.SubFileStream.IoSession">
            <summary>
            An IoSession for the sub file stream.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.SubFileStream.IoSession.m_parser">
            <summary>
            The address parser
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.SubFileStream.IoSession.m_pager">
            <summary>
            The shadow copier if the address translation allows for editing.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.SubFileStream.IoSession.m_ioSessions">
            <summary>
            Contains the read/write buffer.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.SubFileStream.IoSession.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:GSF.IO.FileStructure.SubFileStream.IoSession"/> object and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="M:GSF.IO.FileStructure.SubFileStream.IoSession.Clear">
            <summary>
            Sets the current usage of the <see cref="T:GSF.IO.Unmanaged.BinaryStreamIoSessionBase"/> to null.
            </summary>
        </member>
        <member name="T:GSF.IO.FileStructure.FileHeaderAttributes">
            <summary>
            Defined attribute flags for the archive header.
            </summary>
        </member>
        <member name="T:GSF.IO.FileStructure.Media.CustomFileStream">
            <summary>
            A functional wrapper around a <see cref="T:System.IO.FileStream"/>
            specific to how the <see cref="T:GSF.IO.FileStructure.TransactionalFileStructure"/> uses the <see cref="T:System.IO.FileStream"/>.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.Media.CustomFileStream.m_disposed">
            <summary>
            Needed since this class computes footer checksums.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.Media.CustomFileStream.m_isUsingStream">
            <summary>
            Lock this first. Allows the <see cref="F:GSF.IO.FileStructure.Media.CustomFileStream.m_stream"/> item to be replaced in 
            a synchronized fashion. 
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.Media.CustomFileStream.m_syncRoot">
            <summary>
            Needed to properly synchronize Read/Write operations.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.CustomFileStream.#ctor(System.Int32,System.Int32,System.String,System.Boolean,System.Boolean)">
            <summary>
            Creates a new CustomFileStream
            </summary>
            <param name="stream">The filestream to use as the base stream</param>
            <param name="ioSize">The size of a buffer pool entry</param>
            <param name="fileStructureBlockSize">The size of an individual block</param>
            <param name="fileName">The filename</param>
            <param name="isReadOnly">If the file is read only</param>
            <param name="isSharingEnabled">if the file is exclusively opened</param>
        </member>
        <member name="P:GSF.IO.FileStructure.Media.CustomFileStream.IsReadOnly">
            <summary>
            Gets if the file was opened read only.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.Media.CustomFileStream.IsSharingEnabled">
            <summary>
            Gets if the file was opened allowing shared read access.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.Media.CustomFileStream.FileName">
            <summary>
            Gets the name of the file
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.Media.CustomFileStream.FileStructureBlockSize">
            <summary>
            Gets the number of bytes in a file structure block.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.Media.CustomFileStream.IOSize">
            <summary>
            Gets the number of bytes in each IO operation.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.Media.CustomFileStream.Length">
            <summary>
            Gets the length of the stream.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.CustomFileStream.Open">
            <summary>
            Opens the underlying file stream
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.CustomFileStream.Close">
            <summary>
            Closes the underlying file stream
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.CustomFileStream.ReadRaw(System.Int64,System.Byte[],System.Int32)">
            <summary>
            Reads data from the disk
            </summary>
            <param name="position">The starting position</param>
            <param name="buffer">the byte buffer of data to read</param>
            <param name="length">the number of bytes to read</param>
            <returns>the number of bytes read</returns>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.CustomFileStream.WriteRaw(System.Int64,System.Byte[],System.Int32)">
            <summary>
            Writes data to the disk
            </summary>
            <param name="position">The starting position</param>
            <param name="buffer">the byte buffer of data to write</param>
            <param name="length">the number of bytes to write</param>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.CustomFileStream.Read(System.Int64,System.IntPtr)">
            <summary>
            Reads an entire page at the provided location. Also computes the checksum information.
            </summary>
            <param name="position">The stream position. May be any position inside the desired block</param>
            <param name="locationToCopyData">The place where to write the data to.</param>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.CustomFileStream.Write(System.Int64,GSF.IO.Unmanaged.MemoryPoolStreamCore,System.Int64,System.Boolean)">
            <summary>
            Writes all of the dirty blocks passed onto the disk subsystem. Also computes the checksum for the data.
            </summary>
            <param name="currentEndOfCommitPosition">the last valid byte of the file system where this data will be appended to.</param>
            <param name="stream">the source of the data to dump to the disk</param>
            <param name="length">The number by bytes to write to the file system.</param>
            <param name="waitForWriteToDisk">True to wait for a complete commit to disk before returning from this function.</param>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.CustomFileStream.FlushFileBuffers">
            <summary>
            Flushes any temporary data to the disk. This also calls WindowsAPI function 
            to have the OS flush to the disk.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.CustomFileStream.ChangeExtension(System.String,System.Boolean,System.Boolean)">
            <summary>
            Changes the extension of the current file.
            </summary>
            <param name="extension">the new extension</param>
            <param name="isReadOnly">If the file should be reopened as readonly</param>
            <param name="isSharingEnabled">If the file should share read privileges.</param>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.CustomFileStream.ChangeShareMode(System.Boolean,System.Boolean)">
            <summary>
            Reopens the file with different permissions.
            </summary>
            <param name="isReadOnly">If the file should be reopened as readonly</param>
            <param name="isSharingEnabled">If the file should share read privileges.</param>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.CustomFileStream.Dispose">
            <summary>
            Releases all the resources used by the <see cref="T:GSF.IO.FileStructure.Media.CustomFileStream"/> object.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.CustomFileStream.CreateFile(System.String,System.Int32,System.Int32)">
            <summary>
            Creates a file with the supplied name
            </summary>
            <param name="fileName">the name of the file</param>
            <param name="ioBlockSize">the number of bytes to do all io with</param>
            <param name="fileStructureBlockSize">the number of bytes in the file structure so checksums can be properly computed.</param>
            <returns></returns>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.CustomFileStream.OpenFile(System.String,System.Int32,System.Int32@,System.Boolean,System.Boolean)">
            <summary>
            Opens a file
            </summary>
            <param name="fileName">the name of the file.</param>
            <param name="ioBlockSize">the number of bytes to do all of the io</param>
            <param name="fileStructureBlockSize">The number of bytes in the file structure</param>
            <param name="isReadOnly">if the file should be opened in read only</param>
            <param name="isSharingEnabled">if the file should be opened with read sharing permissions.</param>
            <returns></returns>
        </member>
        <member name="F:GSF.IO.FileStructure.Media.CustomFileStream.ResourceList">
            <summary>
            Queues byte[] blocks.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.CustomFileStream.#cctor">
            <summary>
            Creates a resource list that everyone shares.
            </summary>
        </member>
        <member name="T:GSF.IO.FileStructure.Media.BufferedFile">
            <summary>
            A buffered file stream utilizes the <see cref="T:GSF.IO.Unmanaged.MemoryPool"/> to intellectually cache
            the contents of files.  
            </summary>
            <remarks>
            This class is a special purpose class that can only be used for the <see cref="T:GSF.IO.FileStructure.TransactionalFileStructure"/>
            and can not buffer general purpose file.
            
            The cache algorithm is a least recently used algorithm.
            This is accomplised by incrementing a counter every time a page is accessed 
            and dividing by 2 every time a collection occurs from the <see cref="T:GSF.IO.Unmanaged.MemoryPool"/>.
            </remarks>
        </member>
        <member name="F:GSF.IO.FileStructure.Media.BufferedFile.m_writeBuffer">
            <summary>
            Any uncommitted data resides in this location.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.Media.BufferedFile.m_lengthOfCommittedData">
            <summary>
            The number of bytes contained in the committed area of the file.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.Media.BufferedFile.m_lengthOfHeader">
            <summary>
            The length of the 10 header pages. 
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.Media.BufferedFile.m_syncRoot">
            <summary>
            Synchronize all calls to this class.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.Media.BufferedFile.m_pool">
            <summary>
            The <see cref="T:GSF.IO.Unmanaged.MemoryPool"/> where the memory pages come from.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.Media.BufferedFile.m_pageReplacementAlgorithm">
            <summary>
            Location to store cached memory pages.
            This class is thread safe.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.Media.BufferedFile.m_disposed">
            <summary>
            Gets if the class has been disposed.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.Media.BufferedFile.m_diskBlockSize">
            <summary>
            All I/O to the disk is done at this maximum block size. Usually 64KB
            This value is equal to the MemoryPool's Page Size.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.Media.BufferedFile.m_fileStructureBlockSize">
            <summary>
            The size of an individual block of the FileStructure. Usually 4KB.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.Media.BufferedFile.m_queue">
            <summary>
            Manages all I/O done to the physical file.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.BufferedFile.#ctor(GSF.IO.FileStructure.Media.CustomFileStream,GSF.IO.Unmanaged.MemoryPool,GSF.IO.FileStructure.FileHeaderBlock,System.Boolean)">
            <summary>
            Creates a file backed memory stream.
            </summary>
            <param name="stream">The <see cref="T:GSF.IO.FileStructure.Media.CustomFileStream"/> to buffer</param>
            <param name="pool">The <see cref="T:GSF.IO.Unmanaged.MemoryPool"/> to allocate memory from</param>
            <param name="header">The <see cref="T:GSF.IO.FileStructure.FileHeaderBlock"/> to be managed when modifications occur</param>
            <param name="isNewFile">Tells if this is a newly created file. This will make sure that the 
            first 10 pages have the header data copied to it.</param>
        </member>
        <member name="P:GSF.IO.FileStructure.Media.BufferedFile.Length">
            <summary>
            Gets the current number of bytes used by the file system. 
            This is only intended to be an approximate figure. 
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.Media.BufferedFile.FileName">
            <summary>
            Gets the file name associated with the medium. Returns an empty string if a memory file.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.BufferedFile.CommitChanges(GSF.IO.FileStructure.FileHeaderBlock)">
            <summary>
            Executes a commit of data. This will flush the data to the disk use the provided header data to properly
            execute this function.
            </summary>
            <param name="header"></param>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.BufferedFile.CreateIoSession">
            <summary>
            Creates a <see cref="T:GSF.IO.Unmanaged.BinaryStreamIoSessionBase"/> that can be used to read from this disk medium.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.BufferedFile.RollbackChanges">
            <summary>
            Rolls back all edits to the DiskMedium
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.BufferedFile.ChangeExtension(System.String,System.Boolean,System.Boolean)">
            <summary>
            Changes the extension of the current file.
            </summary>
            <param name="extension">the new extension</param>
            <param name="isReadOnly">If the file should be reopened as readonly</param>
            <param name="isSharingEnabled">If the file should share read privileges.</param>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.BufferedFile.ChangeShareMode(System.Boolean,System.Boolean)">
            <summary>
            Reopens the file with different permissions.
            </summary>
            <param name="isReadOnly">If the file should be reopened as readonly</param>
            <param name="isSharingEnabled">If the file should share read privileges.</param>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.BufferedFile.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.BufferedFile.GetBlock(GSF.IO.FileStructure.Media.PageReplacementAlgorithm.PageLock,GSF.IO.Unmanaged.BlockArguments)">
            <summary>
            Populates the pointer data inside <see cref="!:args"/> for the desired block as specified in <see cref="!:args"/>.
            This function will block if needing to retrieve data from the disk.
            </summary>
            <param name="pageLock">The reusable lock information about what this block is currently using.</param>
            <param name="args">Contains what block needs to be read and when this function returns, 
            it will contain the proper pointer information for this block.</param>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.BufferedFile.GetBlockFromCommittedSpace(GSF.IO.FileStructure.Media.PageReplacementAlgorithm.PageLock,System.Int64,System.IntPtr@)">
            <summary>
            Processes the GetBlock from the committed area.
            </summary>
            <param name="pageLock"></param>
            <param name="position"></param>
            <param name="pointer">an output parameter that contains the pointer for the provided position</param>
            <remarks>The valid length is at least the size of the buffer pools page size.</remarks>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.BufferedFile.m_pool_RequestCollection(System.Object,GSF.IO.Unmanaged.CollectionEventArgs)">
            <summary>
            Handles the <see cref="E:GSF.IO.Unmanaged.MemoryPool.RequestCollection"/> event.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.BufferedFile.ReleaseWriteBufferSpace">
            <summary>
            Releases the buffered data contained in the buffer pool.
            This is acomplished by disposing of the writer and recreating it.
            </summary>
        </member>
        <member name="T:GSF.IO.FileStructure.Media.BufferedFile.IoSession">
            <summary>
            The <see cref="T:GSF.IO.Unmanaged.BinaryStreamIoSessionBase"/> utilized by the <see cref="T:GSF.IO.FileStructure.Media.BufferedFile"/>.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.Media.BufferedFile.IoSession.m_stream">
            <summary>
            The base stream
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.BufferedFile.IoSession.#ctor(GSF.IO.FileStructure.Media.BufferedFile,GSF.IO.FileStructure.Media.PageReplacementAlgorithm)">
            <summary>
            Creates a new <see cref="T:GSF.IO.FileStructure.Media.BufferedFile.IoSession"/>
            </summary>
            <param name="stream">the base class</param>
            <param name="pageReplacement">The page Replacement Algorithm</param>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.BufferedFile.IoSession.GetBlock(GSF.IO.Unmanaged.BlockArguments)">
            <summary>
            Gets a block for the following Io session.
            </summary>
            <param name="args">the <see cref="T:GSF.IO.Unmanaged.BlockArguments"/> to use to read and write to a block</param>
        </member>
        <member name="T:GSF.IO.FileStructure.Media.DiskIo">
            <summary>
            The IO system that the entire file structure uses to acomplish it's IO operations.
            This class hands data one block at a time to requesting classes
            and is responsible for checking the footer data of the file for corruption.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.Media.DiskIo.BlockSize">
            <summary>
            Gets the number of bytes in a single block.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.Media.DiskIo.IsReadOnly">
            <summary>
            Gets if the disk supports writing.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.Media.DiskIo.IsDisposed">
            <summary>
            Gets if the class has been disposed.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.Media.DiskIo.FileSize">
            <summary>
            Gets the current size of the file.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.Media.DiskIo.LastReadonlyBlock">
            <summary>
            Returns the last block that is readonly.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.Media.DiskIo.LastCommittedHeader">
            <summary>
            Gets the file header that was the last header to be committed to the disk.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.DiskIo.RollbackChanges">
            <summary>
            Occurs when rolling back a transaction. This will free up
            any temporary space allocated for the change. 
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.DiskIo.CommitChanges(GSF.IO.FileStructure.FileHeaderBlock)">
            <summary>
            Occurs when committing the following data to the disk.
            This will copy any pending data to the disk in a manner that
            will protect against corruption.
            </summary>
            <param name="header"></param>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.DiskIo.CreateDiskIoSession(GSF.IO.FileStructure.FileHeaderBlock,GSF.IO.FileStructure.SubFileHeader)">
            <summary>
            Creates a <see cref="T:GSF.IO.FileStructure.Media.DiskIoSession"/> that can be used to perform basic read/write functions.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.DiskIo.ChangeExtension(System.String,System.Boolean,System.Boolean)">
            <summary>
            Changes the extension of the current file.
            </summary>
            <param name="extension">the new extension</param>
            <param name="isReadOnly">If the file should be reopened as readonly</param>
            <param name="isSharingEnabled">If the file should share read privileges.</param>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.DiskIo.ChangeShareMode(System.Boolean,System.Boolean)">
            <summary>
            Reopens the file with different permissions.
            </summary>
            <param name="isReadOnly">If the file should be reopened as readonly</param>
            <param name="isSharingEnabled">If the file should share read privileges.</param>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.DiskIo.Dispose">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:GSF.IO.FileStructure.Media.DiskIo"/> object and optionally releases the managed resources.
            </summary>
        </member>
        <member name="T:GSF.IO.FileStructure.Media.DiskIoSession">
            <summary>
            Provides a data IO session with the disk subsystem to perform basic read and write operations.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.DiskIoSession.#ctor(GSF.IO.FileStructure.Media.DiskIo,GSF.IO.Unmanaged.BinaryStreamIoSessionBase,GSF.IO.FileStructure.FileHeaderBlock,GSF.IO.FileStructure.SubFileHeader)">
            <summary>
            Creates a new DiskIoSession that can be used to read from the disk subsystem.
            </summary>
            <param name="diskIo">owner of the disk</param>
            <param name="ioSession">the base ioSession to use for this io session</param>
            <param name="file">The file that will be read from this diskIoSession</param>
        </member>
        <member name="P:GSF.IO.FileStructure.Media.DiskIoSession.IsDisposed">
            <summary>
            Returns true if this class is disposed
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.Media.DiskIoSession.IsValid">
            <summary>
            Gets if the block in this IO Session is valid.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.Media.DiskIoSession.Length">
            <summary>
            Gets the number of bytes valid in this block.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.Media.DiskIoSession.BlockIndex">
            <summary>
            Gets the indexed page of this block.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.Media.DiskIoSession.Pointer">
            <summary>
            Gets a pointer to the block
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.DiskIoSession.WriteToNewBlock(System.UInt32,GSF.IO.FileStructure.BlockType,System.UInt32)">
            <summary>
            Navigates to a block that will be written to. 
            This class does not check if overwriting an existing block. So be careful not to corrupt the file.
            </summary>
            <param name="blockIndex">the index value of this block</param>
            <param name="blockType">the type of this block.</param>
            <param name="indexValue">a value put in the footer of the block designating the index of this block</param>
            <remarks>This function will increase the size of the file if the block excedes the current size of the file.</remarks>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.DiskIoSession.WriteToExistingBlock(System.UInt32,GSF.IO.FileStructure.BlockType,System.UInt32)">
            <summary>
            Navigates to a block that will be written to.
            This block must currently exist and have the correct parameters passed to this function
            In order to allow this block to be modified.
            </summary>
            <param name="blockIndex">the index value of this block</param>
            <param name="blockType">the type of this block.</param>
            <param name="indexValue">a value put in the footer of the block designating the index of this block</param>
            <returns></returns>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.DiskIoSession.Read(System.UInt32,GSF.IO.FileStructure.BlockType,System.UInt32)">
            <summary>
            Navigates to a block that will be only read and not modified.
            </summary>
            <param name="blockIndex"></param>
            <param name="blockType">the type of this block.</param>
            <param name="indexValue">a value put in the footer of the block designating the index of this block</param>
            <returns></returns>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.DiskIoSession.ReadOld(System.UInt32,GSF.IO.FileStructure.BlockType,System.UInt32)">
            <summary>
            Navigates to a block that will be only read and not modified.
            </summary>
            <param name="blockIndex"></param>
            <param name="blockType">the type of this block.</param>
            <param name="indexValue">a value put in the footer of the block designating the index of this block</param>
            <returns></returns>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.DiskIoSession.Dispose">
            <summary>
            Releases all the resources used by the <see cref="T:GSF.IO.FileStructure.Media.DiskIoSession"/> object.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.DiskIoSession.ReadBlock(System.Boolean)">
            <summary>
            Tries to read data from the following file
            </summary>
            <param name="requestWriteAccess">true if reading data from this block for the purpose of writing to it later</param>
        </member>
        <member name="T:GSF.IO.FileStructure.Media.DiskMedium">
            <summary>
            Provides read/write access to all of the different types of disk types
            to use to store the file structure.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.Media.DiskMedium.m_header">
            <summary>
            The file block header
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.Media.DiskMedium.m_disk">
            <summary>
            The underlying disk implementation
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.Media.DiskMedium.m_blockSize">
            <summary>
            The number of bytes in a given block. Typically 4KB in size.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.Media.DiskMedium.m_disposed">
            <summary>
            Prevents duplicate calls to dispose.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.DiskMedium.#ctor(GSF.IO.FileStructure.Media.IDiskMediumCoreFunctions,GSF.IO.FileStructure.FileHeaderBlock)">
            <summary>
            Class is created through static methods of this class.
            </summary>
            <param name="disk">the underlying disk medium</param>
            <param name="header">the header data to use.</param>
        </member>
        <member name="P:GSF.IO.FileStructure.Media.DiskMedium.Length">
            <summary>
            Gets the current number of bytes used by the file system. 
            This is only intended to be an approximate figure. 
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.Media.DiskMedium.Header">
            <summary>
            Gets the most recent committed header from the archive file.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.Media.DiskMedium.BlockSize">
            <summary>
            Gets the number of bytes in the file structure block size.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.DiskMedium.RollbackChanges">
            <summary>
            Occurs when rolling back a transaction. This will free up
            any temporary space allocated for the change. 
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.DiskMedium.CommitChanges(GSF.IO.FileStructure.FileHeaderBlock)">
            <summary>
            Occurs when committing the following data to the disk.
            This will copy any pending data to the disk in a manner that
            will protect against corruption.
            </summary>
            <param name="header"></param>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.DiskMedium.CreateIoSession">
            <summary>
            Creates a <see cref="T:GSF.IO.Unmanaged.BinaryStreamIoSessionBase"/> that can be used to read from this disk medium.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.DiskMedium.ChangeExtension(System.String,System.Boolean,System.Boolean)">
            <summary>
            Changes the extension of the current file.
            </summary>
            <param name="extension">the new extension</param>
            <param name="isReadOnly">If the file should be reopened as readonly</param>
            <param name="isSharingEnabled">If the file should share read privileges.</param>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.DiskMedium.ChangeShareMode(System.Boolean,System.Boolean)">
            <summary>
            Reopens the file with different permissions.
            </summary>
            <param name="isReadOnly">If the file should be reopened as readonly</param>
            <param name="isSharingEnabled">If the file should share read privileges.</param>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.DiskMedium.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.DiskMedium.CreateMemoryFile(GSF.IO.Unmanaged.MemoryPool,System.Int32,System.Guid[])">
            <summary>
            Creates a <see cref="T:GSF.IO.FileStructure.Media.DiskMedium"/> that is entirely based in memory.
            </summary>
            <param name="pool">the <see cref="T:GSF.IO.Unmanaged.MemoryPool"/> to allocate data from</param>
            <param name="fileStructureBlockSize">the block size of the file structure. Usually 4kb.</param>
            <param name="flags">Flags to write to the file</param>
            <returns></returns>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.DiskMedium.CreateFile(GSF.IO.FileStructure.Media.CustomFileStream,GSF.IO.Unmanaged.MemoryPool,System.Int32,System.Guid[])">
            <summary>
            Creates a <see cref="T:GSF.IO.FileStructure.Media.DiskMedium"/> from a <see cref="!:stream"/>. 
            This will initialize the <see cref="!:stream"/> as an empty file structure.
            </summary>
            <param name="stream">An open <see cref="T:System.IO.FileStream"/> to use. The <see cref="T:GSF.IO.FileStructure.Media.DiskMedium"/>
                will assume ownership of this <see cref="T:System.IO.FileStream"/>.</param>
            <param name="pool">the <see cref="T:GSF.IO.Unmanaged.MemoryPool"/> to allocate data from</param>
            <param name="fileStructureBlockSize">the block size of the file structure. Usually 4kb.</param>
            <param name="flags">Flags to write to the file</param>
            <returns></returns>
            <remarks>
            This will not check if the file is truely a new file. If calling this with an existing
            archive file, it will overwrite the table of contents, corrupting the file.
            </remarks>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.DiskMedium.OpenFile(GSF.IO.FileStructure.Media.CustomFileStream,GSF.IO.Unmanaged.MemoryPool,System.Int32)">
            <summary>
            Creates a <see cref="T:GSF.IO.FileStructure.Media.DiskMedium"/> from a <see cref="!:stream"/>. 
            This will read the existing header from the <see cref="!:stream"/>.
            </summary>
            <param name="stream">An open <see cref="T:System.IO.FileStream"/> to use. The <see cref="T:GSF.IO.FileStructure.Media.DiskMedium"/>
            will assume ownership of this <see cref="T:System.IO.FileStream"/>.</param>
            <param name="pool">The <see cref="T:GSF.IO.Unmanaged.MemoryPool"/> to allocate data from.</param>
            <param name="fileStructureBlockSize">the block size of the file structure. Usually 4kb.</param>
            <returns></returns>
        </member>
        <member name="T:GSF.IO.FileStructure.Media.IoReadState">
            <summary>
            Since exceptions are very expensive, this enum will be returned for basic
            I/O operations to let the reader know what to do with the data.  
            </summary>
            <remarks>There two overarching conditions.  Valid or not Valid.  
            If not valid, the reason why the page failed will be given.
            If a page is returned as valid, this does not mean that the 
            page being referenced is the correct page, it is up to the class
            to check the footer of the page to verify that the page being read
            is the correct page.</remarks>
        </member>
        <member name="F:GSF.IO.FileStructure.Media.IoReadState.Valid">
            <summary>
            Indicates that the read completed sucessfully.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.Media.IoReadState.ChecksumInvalid">
            <summary>
            The checksum failed to compute
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.Media.IoReadState.PageNewerThanSnapshotSequenceNumber">
            <summary>
            The page that was requested came from a newer version of the file.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.Media.IoReadState.FileIdNumberDidNotMatch">
            <summary>
            The page came from a different file.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.Media.IoReadState.IndexNumberMissmatch">
            <summary>
            The index value did not match that of the file.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.Media.IoReadState.BlockTypeMismatch">
            <summary>
            The page type requested did not match what was received
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.Footer.ComputeChecksum(System.IntPtr,System.Int64@,System.Int32@,System.Int32)">
            <summary>
            Computes the custom checksum of the data.
            </summary>
            <param name="data">the data to compute the checksum for.</param>
            <param name="checksum1">the 64 bit component of this checksum</param>
            <param name="checksum2">the 32 bit component of this checksum</param>
            <param name="length">the number of bytes to have in the checksum,Must </param>
            <remarks>This checksum is similiar to Adler</remarks>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.Footer.WriteChecksumResultsToFooter(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            This event occurs any time new data is added to the BinaryStream's 
            internal memory. It gives the consumer of this class an opportunity to 
            properly initialize the data before it is handed to an IoSession.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.Footer.WriteChecksumResultsToFooter(System.IntPtr,System.Int32)">
            <summary>
            This event occurs any time new data is added to the BinaryStream's 
            internal memory. It gives the consumer of this class an opportunity to 
            properly initialize the data before it is handed to an IoSession.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.Footer.ComputeChecksumAndClearFooter(System.IntPtr,System.Int32)">
            <summary>
            This event occurs right before something is committed to the disk. 
            This gives the opportunity to finalize the data, such as updating checksums.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.Footer.ComputeChecksumAndClearFooter(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            This event occurs right before something is committed to the disk. 
            This gives the opportunity to finalize the data, such as updating checksums.
            </summary>
        </member>
        <member name="T:GSF.IO.FileStructure.Media.IDiskMediumCoreFunctions">
            <summary>
            The interface that is required construct a <see cref="T:GSF.IO.FileStructure.Media.DiskMedium"/> class.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.IDiskMediumCoreFunctions.CreateIoSession">
            <summary>
            Creates a <see cref="T:GSF.IO.Unmanaged.BinaryStreamIoSessionBase"/> that can be used to read from this disk medium.
            </summary>
            <returns></returns>
        </member>
        <member name="P:GSF.IO.FileStructure.Media.IDiskMediumCoreFunctions.Length">
            <summary>
            Gets the current number of bytes used by the file system. 
            This is only intended to be an approximate figure. 
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.Media.IDiskMediumCoreFunctions.FileName">
            <summary>
            Gets the file name associated with the medium. Returns an empty string if a memory file.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.IDiskMediumCoreFunctions.CommitChanges(GSF.IO.FileStructure.FileHeaderBlock)">
            <summary>
            Executes a commit of data. This will flush the data to the disk use the provided header data to properly
            execute this function.
            </summary>
            <param name="header"></param>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.IDiskMediumCoreFunctions.RollbackChanges">
            <summary>
            Rolls back all edits to the DiskMedium
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.IDiskMediumCoreFunctions.ChangeExtension(System.String,System.Boolean,System.Boolean)">
            <summary>
            Changes the extension of the current file.
            </summary>
            <param name="extension">the new extension</param>
            <param name="isReadOnly">If the file should be reopened as readonly</param>
            <param name="isSharingEnabled">If the file should share read privileges.</param>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.IDiskMediumCoreFunctions.ChangeShareMode(System.Boolean,System.Boolean)">
            <summary>
            Reopens the file with different permissions.
            </summary>
            <param name="isReadOnly">If the file should be reopened as readonly</param>
            <param name="isSharingEnabled">If the file should share read privileges.</param>
        </member>
        <member name="T:GSF.IO.FileStructure.Media.MemoryPoolFile">
            <summary>
            Provides a in memory stream that uses pages that are pooled in the unmanaged buffer pool.
            </summary>
            <summary>
            Provides a in memory stream that uses pages that are pooled in the unmanaged buffer pool.
            </summary>
        </member>
        <member name="T:GSF.IO.FileStructure.Media.MemoryPoolFile.IoSession">
            <summary>
            An I/O session for the <see cref="T:GSF.IO.FileStructure.Media.MemoryPoolFile"/>.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.MemoryPoolFile.IoSession.#ctor(GSF.IO.FileStructure.Media.MemoryPoolFile)">
            <summary>
            Creates a new <see cref="T:GSF.IO.FileStructure.Media.MemoryPoolFile.IoSession"/>
            </summary>
            <param name="file">the base file</param>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.MemoryPoolFile.IoSession.Clear">
            <summary>
            Sets the current usage of the <see cref="T:GSF.IO.Unmanaged.BinaryStreamIoSessionBase"/> to null.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.Media.MemoryPoolFile.m_ioSession">
            <summary>
            A Reusable I/O session for all BinaryStreams
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.MemoryPoolFile.#ctor(GSF.IO.Unmanaged.MemoryPool)">
            <summary>
            Create a new <see cref="T:GSF.IO.FileStructure.Media.MemoryPoolFile"/>
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.MemoryPoolFile.CreateIoSession">
            <summary>
            Creates a <see cref="T:GSF.IO.Unmanaged.BinaryStreamIoSessionBase"/> that can be used to read from this disk medium.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.MemoryPoolFile.CommitChanges(GSF.IO.FileStructure.FileHeaderBlock)">
            <summary>
            Executes a commit of data. This will flush the data to the disk use the provided header data to properly
            execute this function.
            </summary>
            <param name="headerBlock"></param>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.MemoryPoolFile.RollbackChanges">
            <summary>
            Rolls back all edits to the DiskMedium
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.MemoryPoolFile.ChangeExtension(System.String,System.Boolean,System.Boolean)">
            <summary>
            Changes the extension of the current file.
            </summary>
            <param name="extension">the new extension</param>
            <param name="isReadOnly">If the file should be reopened as readonly</param>
            <param name="isSharingEnabled">If the file should share read privileges.</param>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.MemoryPoolFile.ChangeShareMode(System.Boolean,System.Boolean)">
            <summary>
            Reopens the file with different permissions.
            </summary>
            <param name="isReadOnly">If the file should be reopened as readonly</param>
            <param name="isSharingEnabled">If the file should share read privileges.</param>
        </member>
        <member name="T:GSF.IO.FileStructure.Media.PageList">
            <summary>
            Contains a list of page meta data. Provides a simplified way to interact with this list.
            This class is not thread safe.
            </summary>
        </member>
        <member name="T:GSF.IO.FileStructure.Media.PageList.InternalPageMetaData">
            <summary>
            The internal data stored about each page. This is address information, Position information
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.Media.PageList.InternalPageMetaData.LocationOfPage">
            <summary>
            The pointer to the page.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.Media.PageList.InternalPageMetaData.MemoryPoolIndex">
            <summary>
            The index assigned by the <see cref="T:GSF.IO.Unmanaged.MemoryPool"/>.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.Media.PageList.InternalPageMetaData.ReferencedCount">
            <summary>
            The number of times this page has been referenced
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.Media.PageList.m_memoryPool">
            <summary>
            Note: Memory pool must not be used to allocate memory since this is a blocking method.
            Otherwise, there exists the potential to deadlock.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.Media.PageList.m_pageIndexLookupByPositionIndex">
            <summary>
            Contains all of the pages that are cached for the file stream.
            Map is PositionIndex,PageIndex
            </summary>
            ToDO: Change this to something faster than a sorted list.
        </member>
        <member name="F:GSF.IO.FileStructure.Media.PageList.m_listOfPages">
            <summary>
            A list of all pages that have been cached.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.PageList.#ctor(GSF.IO.Unmanaged.MemoryPool)">
            <summary>
            Creates a new PageMetaDataList.
            </summary>
            <param name="memoryPool">The buffer pool to utilize if any unmanaged memory needs to be created.</param>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.PageList.TryGetPageIndex(System.Int32,System.Int32@)">
            <summary>
            Converts a number from its position index into a page index.
            </summary>
            <param name="positionIndex">the position divided by the page size.</param>
            <param name="pageIndex">the page index</param>
            <returns>true if found, false if not found</returns>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.PageList.AddNewPage(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Finds the next unused cache page index. Marks it as used.
            Assigns the page information that comes from the memory pool.
            </summary>
            <returns>The Page Index</returns>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.PageList.GetPointerToPage(System.Int32,System.Int32)">
            <summary>
            Returns the pointer for the provided page index. 
            </summary>
            <param name="pageIndex">the index of the page that has been looked up for the position.</param>
            <param name="incrementReferencedCount">the value to increment the referenced count.</param>
            <returns></returns>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.PageList.DoCollection(System.Int32,System.Collections.Generic.HashSet{System.Int32},GSF.IO.Unmanaged.CollectionEventArgs)">
            <summary>
            Executes a collection cycle on the pages in this list.
            </summary>
            <param name="shiftLevel">the number of bits to shift the referenced counter by.
            Value may be zero but cannot be negative</param>
            <param name="excludedList">A set of values to exclude from the collection process</param>
            <param name="e">Arguments for the collection.</param>
            <returns>The number of pages returned to the memory pool</returns>
            <remarks>If the collection mode is Emergency or Critical, it will only release the required number of pages and no more</remarks>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.PageList.Dispose">
            <summary>
            Releases all the resources used by the <see cref="T:GSF.IO.FileStructure.Media.PageList"/> object.
            </summary>
        </member>
        <member name="T:GSF.IO.FileStructure.Media.PageReplacementAlgorithm">
            <summary>
            A page replacement algorithm that utilizes a quasi LRU algorithm. This class is thread safe.
            </summary>
            <remarks>
            This class is used by <see cref="T:GSF.IO.FileStructure.Media.BufferedFile"/> to decide which pages should be replaced.
            </remarks>
        </member>
        <member name="T:GSF.IO.FileStructure.Media.PageReplacementAlgorithm.PageLock">
            <summary>
            Used to hold a lock on a page to prevent it from being collected by the collection engine.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.PageReplacementAlgorithm.PageLock.#ctor(GSF.IO.FileStructure.Media.PageReplacementAlgorithm)">
            <summary>
            Creates an unallocated block.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.Media.PageReplacementAlgorithm.PageLock.CurrentPageIndex">
            <summary>
            Gets the page index associated with the page
            that is cached. 
            Returns a -1 if no page is currently being used.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.PageReplacementAlgorithm.PageLock.Clear">
            <summary>
            Releases a lock
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.PageReplacementAlgorithm.PageLock.TryGetSubPage(System.Int64,System.IntPtr@)">
            <summary>
            Attempts to get a sub page. 
            </summary>
            <param name="position">the absolute position in the stream to get the page for.</param>
            <param name="location">a pointer for the page</param>
            <returns>False if the page does not exists and needs to be added.</returns>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.PageReplacementAlgorithm.PageLock.GetOrAddPage(System.Int64,System.IntPtr,System.Int32,System.Boolean@)">
            <summary>
            Adds a page to the list of available pages if it does not exist.
            otherwise, returns the page already in the list.
            </summary>
            <param name="position">The position of the first byte in the page</param>
            <param name="startOfMemoryPoolPage">the pointer acquired by the memory pool to this data.</param>
            <param name="memoryPoolIndex">the memory pool index for this data</param>
            <param name="wasPageAdded">Determines if the page provided was indeed added to the list.</param>
            <returns>The pointer to the page for this position</returns>
            <remarks>If <see cref="!:wasPageAdded"/> is false, the calling function should 
            return the page back to the memory pool.
            </remarks>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.PageReplacementAlgorithm.PageLock.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.PageReplacementAlgorithm.PageLock.Equals(GSF.IO.FileStructure.Media.PageReplacementAlgorithm.PageLock)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.PageReplacementAlgorithm.PageLock.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="F:GSF.IO.FileStructure.Media.PageReplacementAlgorithm.m_pageList">
            <summary>
            Contains a list of all the memory pages.
            </summary>
            <remarks>These items in the list are not in any particular order.</remarks>
        </member>
        <member name="F:GSF.IO.FileStructure.Media.PageReplacementAlgorithm.m_arrayIndexLocks">
            <summary>
            Contains the currently active IO sessions.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.PageReplacementAlgorithm.#ctor(GSF.IO.Unmanaged.MemoryPool)">
            <summary>
            Creates a new instance of <see cref="T:GSF.IO.FileStructure.Media.PageReplacementAlgorithm"/>.
            </summary>
            <param name="pool">The memory pool that blocks will be allocated from.</param>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.PageReplacementAlgorithm.TryAddPage(System.Int64,System.IntPtr,System.Int32)">
            <summary>
            Attempts to add the page to this <see cref="T:GSF.IO.FileStructure.Media.PageReplacementAlgorithm"/>. 
            Fails if the page already exists.
            </summary>
            <param name="position">the absolute position that the page references</param>
            <param name="locationOfPage">the pointer to the page</param>
            <param name="memoryPoolIndex">the index value of the memory pool page so it can be released back to the memory pool</param>
            <returns>True if the page was added to the class. False if the page already exists and the data was not replaced.</returns>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.PageReplacementAlgorithm.DoCollection(GSF.IO.Unmanaged.CollectionEventArgs)">
            <summary>
            Executes a collection cycle of the pages that are unused.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.IO.FileStructure.Media.PageReplacementAlgorithm.Dispose">
            <summary>
            Releases all the resources used by the <see cref="T:GSF.IO.FileStructure.Media.PageReplacementAlgorithm"/> object.
            </summary>
        </member>
        <member name="T:GSF.IO.FileStructure.BlockType">
            <summary>
            Each block of bytes in a file is one of these types.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.BlockType.FileAllocationTable">
            <summary>
            The first few pages of a file system
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.BlockType.DataBlock">
            <summary>
            Contains the actual data.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.BlockType.IndexIndirect1">
            <summary>
            A metadata block. Contains a set of pointer blocks that point to <see cref="F:GSF.IO.FileStructure.BlockType.IndexIndirect2"/> blocks.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.BlockType.IndexIndirect2">
            <summary>
            A metadata block. Contains a set of pointer blocks that point to <see cref="F:GSF.IO.FileStructure.BlockType.IndexIndirect3"/> blocks.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.BlockType.IndexIndirect3">
            <summary>
            A metadata block. Contains a set of pointer blocks that point to <see cref="F:GSF.IO.FileStructure.BlockType.IndexIndirect4"/> blocks.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.BlockType.IndexIndirect4">
            <summary>
            A metadata block. Contains a set of pointer blocks that point to the actual data.
            </summary>
        </member>
        <member name="T:GSF.IO.FileStructure.FileHeaderBlock">
            <summary>
            Contains the information that is in the header page of an archive file.  
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.FileHeaderBlock.FileAllocationTableHeaderBytes">
            <summary>
            The file header bytes which equals: "openHistorian 2.0 Archive\00"
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.FileHeaderBlock.m_blockSize">
            <summary>
            The size of the block.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.FileHeaderBlock.m_minimumReadVersion">
            <summary>
            The version number required to read the file system.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.FileHeaderBlock.m_minimumWriteVersion">
            <summary>
            The version number required to write to the file system.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.FileHeaderBlock.m_headerVersion">
            <summary>
            The version of the header.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.FileHeaderBlock.m_isSimplifiedFileFormat">
            <summary>
            Gets if this file uses the simplifed file format.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.FileHeaderBlock.m_headerBlockCount">
            <summary>
            Gets the number of times the file header is repeated
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.FileHeaderBlock.m_lastAllocatedBlock">
            <summary>
            Returns the last allocated block.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.FileHeaderBlock.m_snapshotSequenceNumber">
            <summary>
            This will be updated every time the file system has been modified. Initially, it will be one.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.FileHeaderBlock.m_nextFileId">
            <summary>
            Since files are allocated sequentially, this value is the next file id that is not used.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.FileHeaderBlock.m_archiveId">
            <summary>
            The GUID for this archive file system.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.FileHeaderBlock.m_archiveType">
            <summary>
            The GUID to represent the type of this archive file.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.FileHeaderBlock.m_files">
            <summary>
            Provides a list of all of the Features that are contained within the file.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.FileHeaderBlock.m_flags">
            <summary>
            A set of file flags describing this file.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.FileHeaderBlock.BlockSize">
            <summary>
            The number of bytes per block for the file structure.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.FileHeaderBlock.CanWrite">
            <summary>
            Determines if the file can be written to because enough features are recgonized by this current version to do it without corrupting the file system.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.FileHeaderBlock.CanRead">
            <summary>
            Determines if the archive file can be read
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.FileHeaderBlock.ArchiveId">
            <summary>
            The GUID number for this archive.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.FileHeaderBlock.ArchiveType">
            <summary>
            The GUID number for this archive.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.FileHeaderBlock.IsSimplifiedFileFormat">
            <summary>
            Gets if this file uses the simplifed file format.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.FileHeaderBlock.HeaderBlockCount">
            <summary>
            Gets the number of times the file header exists in the archive file.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.FileHeaderBlock.SnapshotSequenceNumber">
            <summary>
            Maintains a sequential number that represents the version of the file.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.FileHeaderBlock.LastAllocatedBlock">
            <summary>
            Represents the last block that has been allocated
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.FileHeaderBlock.FileCount">
            <summary>
            Returns the number of files that are in this file system. 
            </summary>
            <returns></returns>
        </member>
        <member name="P:GSF.IO.FileStructure.FileHeaderBlock.DataBlockSize">
            <summary>
            Gets the size of each data block (block size - overhead)
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.FileHeaderBlock.Flags">
            <summary>
            User definable flags to associate with archive files.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.FileHeaderBlock.Files">
            <summary>
            A list of all of the files in this collection.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.FileHeaderBlock.CloneEditable">
            <summary>
            Clones the object, while incrementing the sequence number.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.IO.FileStructure.FileHeaderBlock.SetMembersAsReadOnly">
            <summary>
            Requests that member fields be set to readonly. 
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.FileHeaderBlock.CloneMembersAsEditable">
            <summary>
            Request that member fields be cloned and marked as editable.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.FileHeaderBlock.AllocateFreeBlocks(System.UInt32)">
            <summary>
            Allocates a sequential number of blocks at the end of the file and returns the starting address of the allocation
            </summary>
            <param name="count">the number of blocks to allocate</param>
            <returns>the address of the first block of the allocation </returns>
        </member>
        <member name="M:GSF.IO.FileStructure.FileHeaderBlock.CreateNewFile(GSF.IO.FileStructure.SubFileName)">
            <summary>
            Creates a new file on the file system and returns the <see cref="T:GSF.IO.FileStructure.SubFileHeader"/> associated with the new file.
            </summary>
            <param name="fileName">Represents the nature of the data that will be stored in this file.</param>
            <returns></returns>
            <remarks>A file system only supports 64 files. This is a fundamental limitation and cannot be changed easily.</remarks>
        </member>
        <member name="M:GSF.IO.FileStructure.FileHeaderBlock.ContainsSubFile(GSF.IO.FileStructure.SubFileName)">
            <summary>
            Determines if the file contains the subfile
            </summary>
            <param name="fileName">the subfile to look for</param>
            <returns>true if contained, false otherwise</returns>
        </member>
        <member name="M:GSF.IO.FileStructure.FileHeaderBlock.IsFileAllocationTableValid">
            <summary>
            Checks all of the information in the header file 
            to verify if it is valid.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.FileHeaderBlock.GetBytes">
            <summary>
            This will return a byte array of data that can be written to an archive file.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.FileHeaderBlock.LoadFromBuffer(System.Byte[])">
            <summary>
            This procedure will attempt to read all of the data out of the file allocation table
            If the file allocation table is corrupt, an error will be generated.
            </summary>
            <param name="buffer">the block that contains the buffer data.</param>
        </member>
        <member name="M:GSF.IO.FileStructure.FileHeaderBlock.SearchForBlockSize(System.IO.Stream)">
            <summary>
            Looks in the contents of a file for the block size of the file.
            </summary>
            <param name="stream">the stream to look</param>
            <returns>the number of bytes in a block. Always a power of 2.</returns>
        </member>
        <member name="M:GSF.IO.FileStructure.FileHeaderBlock.CreateNew(System.Int32,System.Guid[])">
            <summary>
            Creates a new file header.
            </summary>
            <param name="blockSize">The block size to make the header</param>
            <param name="flags">Flags to write to the file</param>
            <returns></returns>
        </member>
        <member name="M:GSF.IO.FileStructure.FileHeaderBlock.CreateNewSimplified(System.Int32,System.Guid[])">
            <summary>
            Creates a new file header.
            </summary>
            <param name="blockSize">The block size to make the header</param>
            <param name="flags">Flags to write to the file</param>
            <returns></returns>
        </member>
        <member name="M:GSF.IO.FileStructure.FileHeaderBlock.Open(System.Byte[])">
            <summary>
            Opens a file header
            </summary>
            <param name="data">The block of data to be loaded. The length of this block must be equal to the
            block size of a partition.</param>
            <returns></returns>
        </member>
        <member name="T:GSF.IO.FileStructure.FileStructureConstants">
            <summary>
            Maintains some global constants for the archive file.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.FileStructureConstants.BlockFooterLength">
            <summary>
            The number of bytes in the footer of a block
            </summary>
        </member>
        <member name="T:GSF.IO.FileStructure.IndexMapper">
            <summary>
            This class is used to convert the position of a file into a set of directions 
            that <see cref="T:GSF.IO.FileStructure.IndexParser"/> can use to lookup the data cluster.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.IndexMapper.#ctor(System.Int32)">
            <summary>
            Creates a <see cref="T:GSF.IO.FileStructure.IndexMapper"/> that is based on a given <see cref="!:blockSize"/>.
            </summary>
            <param name="blockSize">the number of bytes per block. Cannot be less than 64, greater than 1048576</param>
        </member>
        <member name="P:GSF.IO.FileStructure.IndexMapper.BaseVirtualAddressIndexValue">
            <summary>
            Determines the block index value that will be stored in the footer of the data block.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.IndexMapper.FirstIndirectOffset">
            <summary>
            Gets the offset position for the address that must be read within the indirect block
            at the first indirect block. 
            </summary>
            <remarks>Returns a -1 of invalid.  -1 was chosen since it will likely generate an error if not handled properly.</remarks>
        </member>
        <member name="P:GSF.IO.FileStructure.IndexMapper.SecondIndirectOffset">
            <summary>
            Gets the offset position for the address that must be read within the indirect block
            at the second indirect block. 
            </summary>
            <remarks>Returns a -1 of invalid.  -1 was chosen since it will likely generate an error if not handled properly.</remarks>
        </member>
        <member name="P:GSF.IO.FileStructure.IndexMapper.ThirdIndirectOffset">
            <summary>
            Gets the offset position for the address that must be read within the indirect block
            at the third indirect block. 
            </summary>
            <remarks>Returns a -1 of invalid.  -1 was chosen since it will likely generate an error if not handled properly.</remarks>
        </member>
        <member name="P:GSF.IO.FileStructure.IndexMapper.FourthIndirectOffset">
            <summary>
            Gets the offset position for the address that must be read within the indirect block
            at the forth indirect block. 
            </summary>
            <remarks>Returns a -1 of invalid.  -1 was chosen since it will likely generate an error if not handled properly.</remarks>
        </member>
        <member name="F:GSF.IO.FileStructure.IndexMapper.FirstIndirectBaseIndex">
            <summary>
            Gets the index of the first cluster that can be accessed by this indirect block.  This value is useful because 
            the footer of the indirect page will have this address.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.IndexMapper.SecondIndirectBaseIndex">
            <summary>
            Gets the index of the second cluster that can be accessed by this indirect block.  This value is useful because 
            the footer of the indirect page will have this address.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.IndexMapper.ThirdIndirectBaseIndex">
            <summary>
            Gets the index of the third cluster that can be accessed by this indirect block.  This value is useful because 
            the footer of the indirect page will have this address.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.IndexMapper.FourthIndirectBaseIndex">
            <summary>
            Gets the index of the third cluster that can be accessed by this indirect block.  This value is useful because 
            the footer of the indirect page will have this address.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.IndexMapper.MapPosition(System.UInt32)">
            <summary>
            Updates this class to reflect the path that must be taken to reach the cluster that contains this virtual point
            </summary>
            <param name="positionIndex">The address that is being translated</param>
            <returns>
            This determines what has changed in the most recent update request.
            The calling classes can use this to determine what lookup information needs to be 
            scrapped, and what can be kept.
            0=Immediate, 1=Single, 2=Double, 3=Triple, 4=NoChange
            </returns>
        </member>
        <member name="T:GSF.IO.FileStructure.IndexParser">
            <summary>
            This class provides passthrough properties for the <see cref="T:GSF.IO.FileStructure.IndexMapper"/> class as well follows the directions
            of the Index Mapper to find the data cluster that contains the point in question.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.IndexParser.m_subFile">
            <summary>
            The file that is being read by this parser.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.IndexParser.#ctor(GSF.IO.FileStructure.SubFileDiskIoSessionPool)">
            <summary>
            Creates a new instance of this class.
            </summary>
            <param name="ioSessions">IoSessions to use to read from this disk</param>
        </member>
        <member name="F:GSF.IO.FileStructure.IndexParser.FirstIndirectBlockAddress">
            <summary>
            The address of the first indirect block
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.IndexParser.SecondIndirectBlockAddress">
            <summary>
            The address of the second indirect block
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.IndexParser.ThirdIndirectBlockAddress">
            <summary>
            The address of the third indirect block
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.IndexParser.FourthIndirectBlockAddress">
            <summary>
            The address of the third indirect block
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.IndexParser.DataClusterAddress">
            <summary>
            The address of the first block of the data cluster.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.IndexParser.m_oldFirstOffset">
            <summary>
            The address of the first indirect block
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.IndexParser.m_oldSecondOffset">
            <summary>
            The address of the second indirect block
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.IndexParser.m_oldThirdOffset">
            <summary>
            The address of the third indirect block
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.IndexParser.m_oldFourthOffset">
            <summary>
            The address of the fourth indirect block
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.IndexParser.VirtualToPhysical(System.UInt32)">
            <summary>
            This function will also call <see cref="M:GSF.IO.FileStructure.IndexMapper.MapPosition(System.UInt32)"/> so after it returns, the current block data will be updated.
            </summary>
            <param name="positionIndex">The virtual index address.</param>
            <returns>the physical position index for the provided virtual position</returns>
        </member>
        <member name="M:GSF.IO.FileStructure.IndexParser.SetPositionAndLookup(System.UInt32)">
            <summary>
            Determines if the current sector contains the position passed. If not, it updates the current sector to the one that contains the passed position.
            </summary>
            <param name="positionIndex">The position to navigate to indexed to the block data block size.</param>
        </member>
        <member name="M:GSF.IO.FileStructure.IndexParser.ClearIndexCache(GSF.IO.FileStructure.IndexParser)">
            <summary>
            Resets the index cache with the information from the supplied <see cref="!:mostRecentParser"/>
            </summary>
            <param name="mostRecentParser"></param>
        </member>
        <member name="M:GSF.IO.FileStructure.IndexParser.UpdateBlockInformation">
            <summary>
            Looks up the physical/virtual block positions for the address given.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.IO.FileStructure.IndexParser.GetBlockIndexValue(System.UInt32,System.Int32,GSF.IO.FileStructure.BlockType,System.UInt32)">
            <summary>
            This uses the (blockIndex,offset) values to determine what the next block index is.
            This also has consistency checks to determine if the file is inconsistent (potentially corruption)
            </summary>
            <param name="blockIndex">the index of the block to read</param>
            <param name="offset">the offset inside the block to use to determine the next index block</param>
            <param name="blockType">the value 1-4 which tell what indirect block this is</param>
            <param name="blockBaseIndex">the lowest virtual address that can be referenced from this indirect block</param>
            <returns></returns>
        </member>
        <member name="T:GSF.IO.FileStructure.Murmur3">
            <summary>
            A specialized implementation of MurMur3 that requires the data be aligned 
            to 16-byte boundaries.
            </summary>
        </member>
        <member name="T:GSF.IO.FileStructure.ShadowCopyAllocator">
            <summary>
            This class will make shadow copies of blocks or, if the block has never been written to, prepare the block to be written to.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.ShadowCopyAllocator.m_lastReadOnlyBlock">
            <summary>
            This address is used to determine if the block being referenced is an old block or a new one. 
            Any addresses greater than or equal to this are new blocks for this transaction. Values before this are old.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.ShadowCopyAllocator.m_subFileHeader">
            <summary>
            The file being read.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.ShadowCopyAllocator.m_fileHeaderBlock">
            <summary>
            The FileAllocationTable that can be used to allocate space.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.ShadowCopyAllocator.#ctor(GSF.IO.FileStructure.SubFileDiskIoSessionPool)">
            <summary>
            Creates a <see cref="T:GSF.IO.FileStructure.ShadowCopyAllocator"/> that is used make shadow copies of blocks.
            </summary>
            <param name="ioSessions"></param>
        </member>
        <member name="M:GSF.IO.FileStructure.ShadowCopyAllocator.VirtualToShadowPagePhysical(System.UInt32,System.Boolean@)">
            <summary>
            This will make a shadow copy of the block that contains the position provided.  
            If the block does not exist, space is allocated and the indexes are 
            set up to allow the block to be writen to.
            </summary>
            <param name="positionIndex">The position the application intents to write to.</param>
            <param name="wasShadowed"></param>
            <remarks>Calling this function automatically updates the underlying parser.</remarks>
        </member>
        <member name="M:GSF.IO.FileStructure.ShadowCopyAllocator.ShadowCopyIndexIndirect(System.UInt32@,System.UInt32,GSF.IO.FileStructure.BlockType,System.Int32,System.UInt32)">
            <summary>
            Makes a shadow copy of the indirect index passed to this function. If the block does not exists, it creates it.
            </summary>
            <param name="sourceBlockAddress">The block to be copied</param>
            <param name="indexValue">the index value that goes in the footer of the file.</param>
            <param name="blockType">Gets the expected block type</param>
            <param name="remoteAddressOffset">the offset of the remote address that needs to be updated.</param>
            <param name="remoteBlockAddress">the value of the remote address.</param>
            <returns>Returns true if the block had to be shadowed, false if it did not change</returns>
        </member>
        <member name="M:GSF.IO.FileStructure.ShadowCopyAllocator.ReadThenWriteIndexIndirectBlock(System.UInt32,System.UInt32,System.UInt32,GSF.IO.FileStructure.BlockType,System.Int32,System.UInt32)">
            <summary>
            Makes a shadow copy of an index indirect block and updates a remote address. 
            </summary>
            <param name="sourceBlockAddress">the address of the source.</param>
            <param name="destinationBlockAddress">the address of the destination. This can be the same as the source.</param>
            <param name="indexValue">the index value that goes in the footer of the file.</param>
            <param name="blockType">Gets the expected block type</param>
            <param name="remoteAddressOffset">the offset of the remote address that needs to be updated.</param>
            <param name="remoteBlockAddress">the value of the remote address.</param>
        </member>
        <member name="M:GSF.IO.FileStructure.ShadowCopyAllocator.WriteIndexIndirectBlock(System.Byte*,System.Int32,System.UInt32)">
            <summary>
            Writes an Indirect Block to the drive. This sets the indexIndirectNumber and updates one of the addresses within this index.
            </summary>
            <param name="pointer"> </param>
            <param name="remoteAddressOffset">the offset of the remote address that needs to be updated</param>
            <param name="remoteBlockAddress">the value of the remote address</param>
        </member>
        <member name="M:GSF.IO.FileStructure.ShadowCopyAllocator.TryShadowCopyDataBlock">
            <summary>
            Makes a copy of the data block. Returns true if a copy was made. False if no copy was made
            </summary>
            <returns>True if the block's address was changed.</returns>
        </member>
        <member name="M:GSF.IO.FileStructure.ShadowCopyAllocator.ShadowCopyDataCluster(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Makes a shadow copy of a data cluster.
            </summary>
            <param name="sourceClusterAddress">the address of the first block in the cluster. 
            If address is zero, it simply creates an empty cluster.</param>
            <param name="indexValue">the index value of this first block</param>
            <param name="destinationClusterAddress">the first block of the destination cluster</param>
        </member>
        <member name="T:GSF.IO.FileStructure.SubFileDiskIoSessionPool">
            <summary>
            Contains a set of <see cref="T:GSF.IO.FileStructure.Media.DiskIoSession"/>s that speed up the I/O operations associated with
            reading and writing to an archive disk. This class contains two I/O Sessions if the file
            supports modification to speed up the copy operation when doing shadow copies.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.SubFileDiskIoSessionPool.SourceData">
            <summary>
            
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.SubFileDiskIoSessionPool.DestinationData">
            <summary>
            Null if in readonly mode
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.SubFileDiskIoSessionPool.SourceIndex">
            <summary>
            
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.SubFileDiskIoSessionPool.DestinationIndex">
            <summary>
            Null if in readonly mode
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.SubFileDiskIoSessionPool.File">
            <summary>
            The file
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.SubFileDiskIoSessionPool.Header">
            <summary>
            The Header
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.SubFileDiskIoSessionPool.LastReadonlyBlock">
            <summary>
            Contains the last block that is considered as read only. This is the same as the end of the committed space
            in the transactional file system.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.SubFileDiskIoSessionPool.IsReadOnly">
            <summary>
            Gets if the file is read only.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.SubFileDiskIoSessionPool.IsDisposed">
            <summary>
            Gets if this class has been disposed.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.SubFileDiskIoSessionPool.#ctor(GSF.IO.FileStructure.Media.DiskIo,GSF.IO.FileStructure.FileHeaderBlock,GSF.IO.FileStructure.SubFileHeader,System.Boolean)">
            <summary>
            Creates this file with the following data.
            </summary>
            <param name="diskIo"></param>
            <param name="header"></param>
            <param name="file"></param>
            <param name="isReadOnly"></param>
        </member>
        <member name="M:GSF.IO.FileStructure.SubFileDiskIoSessionPool.SwapIndex">
            <summary>
            Swaps the source and destination index I/O Sessions.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.SubFileDiskIoSessionPool.SwapData">
            <summary>
            Swaps the source and destination Data I/O Sessions
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.SubFileDiskIoSessionPool.Clear">
            <summary>
            Releases all of the data associated with the I/O Sessions.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.SubFileDiskIoSessionPool.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:GSF.IO.FileStructure.SubFileHeader">
            <summary>
            This contains the meta data of the file along with index information to map all of the blocks of the file.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.SubFileHeader.#ctor(System.IO.BinaryReader,System.Boolean,System.Boolean)">
            <summary>
            Creates a <see cref="T:GSF.IO.FileStructure.SubFileHeader"/> from the data stream.
            </summary>
            <param name="dataReader"></param>
            <param name="isImmutable">Determines if this class will be immutable upon creation</param>
            <param name="isSimplified">gets if the file structure is the simplified type</param>
        </member>
        <member name="M:GSF.IO.FileStructure.SubFileHeader.#ctor(System.UInt16,GSF.IO.FileStructure.SubFileName,System.Boolean,System.Boolean)">
            <summary>
            Creates a new <see cref="T:GSF.IO.FileStructure.SubFileHeader"/>.
            </summary>
            <param name="fileId"></param>
            <param name="fileName"></param>
            <param name="isImmutable">Determines if this class will be immutable upon creation</param>
            <param name="isSimplified">if this header is a simplified header.</param>
        </member>
        <member name="P:GSF.IO.FileStructure.SubFileHeader.FileIdNumber">
            <summary>
            Gets the unique file identifier for this file.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.SubFileHeader.FileName">
            <summary>
            Gets the <see cref="T:GSF.IO.FileStructure.SubFileName"/> that represents what type of data is contained in this file.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.SubFileHeader.DataBlockCount">
            <summary>
            Gets the number of blocks the data portion of this file contains
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.SubFileHeader.TotalBlockCount">
            <summary>
            Gets the total number of blocks that has been used by this file. 
            This includes meta data blocks and previous version blocks
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.SubFileHeader.DirectBlock">
            <summary>
            Gets the block address for the first direct block of this file.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.SubFileHeader.SingleIndirectBlock">
            <summary>
            Gets the block address for the single indirect block.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.SubFileHeader.DoubleIndirectBlock">
            <summary>
            Gets the block address for the double indirect block.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.SubFileHeader.TripleIndirectBlock">
            <summary>
            Gets the block address for the tripple indirect block.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.SubFileHeader.QuadrupleIndirectBlock">
            <summary>
            Gets the block address for the quadruple indirect block.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.SubFileHeader.Save(System.IO.BinaryWriter)">
            <summary>
            Writes the data contained in <see cref="T:GSF.IO.FileStructure.SubFileHeader"/> to the data stream.
            </summary>
            <param name="dataWriter">The stream to write to.</param>
        </member>
        <member name="M:GSF.IO.FileStructure.SubFileHeader.TestSimplifiedFile">
            <summary>
            Test if the class has been marked as readonly. Throws an exception if editing cannot occur.
            </summary>
        </member>
        <member name="T:GSF.IO.FileStructure.SubFileName">
            <summary>
            This is used to generate the file name that will be used for the sub file. 
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.SubFileName.RawValue1">
            <summary>
            the first 8 bytes of the <see cref="T:GSF.IO.FileStructure.SubFileName"/>
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.SubFileName.RawValue2">
            <summary>
            the next 8 bytes of the <see cref="T:GSF.IO.FileStructure.SubFileName"/>
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.SubFileName.RawValue3">
            <summary>
            The final 4 bytes of the <see cref="T:GSF.IO.FileStructure.SubFileName"/>
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.SubFileName.Save(System.IO.BinaryWriter)">
            <summary>
            Writes the <see cref="T:GSF.IO.FileStructure.SubFileName"/> to the <see cref="!:writer"/>.
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:GSF.IO.FileStructure.SubFileName.CompareTo(GSF.IO.FileStructure.SubFileName)">
            <summary>
            Compares the current object with another object of the same type.
            </summary>
            <returns>
            A value that indicates the relative order of the objects being compared. The return value has the following meanings: Value Meaning Less than zero This object is less than the <paramref name="other"/> parameter.Zero This object is equal to <paramref name="other"/>. Greater than zero This object is greater than <paramref name="other"/>. 
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:GSF.IO.FileStructure.SubFileName.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:GSF.IO.FileStructure.SubFileName.Equals(GSF.IO.FileStructure.SubFileName)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:GSF.IO.FileStructure.SubFileName.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:GSF.IO.FileStructure.SubFileName.Empty">
            <summary>
            An empty sub file name. Should not generally be used as a single file system 
            must have unique file names.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.SubFileName.CreateRandom">
            <summary>
            Creates a random <see cref="T:GSF.IO.FileStructure.SubFileName"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.IO.FileStructure.SubFileName.Create(System.Guid,System.Guid,System.Guid)">
            <summary>
            Creates a <see cref="T:GSF.IO.FileStructure.SubFileName"/> from the supplied data.
            </summary>
            <param name="fileType">the type identifier of the file</param>
            <param name="keyType">the guid identifier of the type of the SortedTreeStore</param>
            <param name="valueType">the guid identifier of the value type of the SortedTreeStore</param>
            <returns></returns>
        </member>
        <member name="M:GSF.IO.FileStructure.SubFileName.Create(System.String,System.Guid,System.Guid)">
            <summary>
            Creates a <see cref="T:GSF.IO.FileStructure.SubFileName"/> from the supplied data.
            </summary>
            <param name="fileName">a name associated with the data</param>
            <param name="keyType">the guid identifier of the type of the SortedTreeStore</param>
            <param name="valueType">the guid identifier of the value type of the SortedTreeStore</param>
            <returns></returns>
        </member>
        <member name="M:GSF.IO.FileStructure.SubFileName.Create(System.Byte[])">
            <summary>
            Creates a <see cref="T:GSF.IO.FileStructure.SubFileName"/> from the supplied data.
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.IO.FileStructure.SubFileName.Load(System.IO.BinaryReader)">
            <summary>
            Loads the <see cref="T:GSF.IO.FileStructure.SubFileName"/> from the supplied <see cref="!:reader"/>.
            </summary>
            <param name="reader">the reader to read from.</param>
            <returns></returns>
        </member>
        <member name="M:GSF.IO.FileStructure.SubFileName.op_Equality(GSF.IO.FileStructure.SubFileName,GSF.IO.FileStructure.SubFileName)">
            <summary>
            Compares the equality of the two file names.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.IO.FileStructure.SubFileName.op_Inequality(GSF.IO.FileStructure.SubFileName,GSF.IO.FileStructure.SubFileName)">
            <summary>
            Compares if the two files are not equal.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="T:GSF.IO.FileStructure.TransactionalEdit">
            <summary>
            Provides the state information for a transaction on the file system.
            </summary>
            <remarks>Failing to call Commit or Rollback will inhibit additional transactions to be aquired</remarks>
        </member>
        <member name="F:GSF.IO.FileStructure.TransactionalEdit.m_delHasBeenCommitted">
            <summary>
            This delegate is called when the Commit function is called and all the data has been written to the underlying file system.
            the purpose of this delegate is to notify the calling class that this transaction is concluded since
            only one write transaction can be aquired at a time.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.TransactionalEdit.m_delHasBeenRolledBack">
            <summary>
            This delegate is called when the RollBack function is called. This also occurs when the object is disposed.
            the purpose of this delegate is to notify the calling class that this transaction is concluded since
            only one write transaction can be aquired at a time.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.TransactionalEdit.m_disposed">
            <summary>
            Prevents duplicate calls to Dispose;
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.TransactionalEdit.m_dataReader">
            <summary>
            The underlying diskIO to do the read/writes against.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.TransactionalEdit.m_fileHeaderBlock">
            <summary>
            The readonly snapshot of the archive file.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.TransactionalEdit.m_openedFiles">
            <summary>
            All files that have ever been opened.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.TransactionalEdit.#ctor(GSF.IO.FileStructure.Media.DiskIo,System.Action,System.Action)">
            <summary>
            Creates an editable copy of the transaction
            </summary>
            <param name="dataReader"> </param>
            <param name="delHasBeenRolledBack">the delegate to call when this transaction has been rolled back</param>
            <param name="delHasBeenCommitted">the delegate to call when this transaction has been committed</param>
        </member>
        <member name="P:GSF.IO.FileStructure.TransactionalEdit.Files">
            <summary>
            A list of all of the files in this collection.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.TransactionalEdit.ArchiveType">
            <summary>
            The guid for this archive type.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.TransactionalEdit.CreateFile(GSF.IO.FileStructure.SubFileName)">
            <summary>
            Creates and Opens a new file on the current file system.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.IO.FileStructure.TransactionalEdit.OpenFile(System.Int32)">
            <summary>
            Opens a ArchiveFileStream that can be used to read/write to the file passed to this function.
            </summary>
            <param name="fileIndex">The index of the file to open.</param>
            <returns></returns>
        </member>
        <member name="M:GSF.IO.FileStructure.TransactionalEdit.OpenFile(GSF.IO.FileStructure.SubFileName)">
            <summary>
            Opens a ArchiveFileStream that can be used to read/write to the file passed to this function.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.IO.FileStructure.TransactionalEdit.CommitAndDispose">
            <summary>
            This will cause the transaction to be written to the database.
            Also Calls Dispose()
            </summary>
            <remarks>Duplicate calls to this function, or subsequent calls to RollbackTransaction will throw an exception</remarks>
        </member>
        <member name="M:GSF.IO.FileStructure.TransactionalEdit.RollbackAndDispose">
            <summary>
            This will rollback the transaction by not writing the table of contents to the file.
            </summary>
            <remarks>Duplicate calls to this function, or subsequent calls to CommitTransaction will throw an exception</remarks>
        </member>
        <member name="M:GSF.IO.FileStructure.TransactionalEdit.Dispose">
            <summary>
            Releases all the resources used by the <see cref="T:GSF.IO.FileStructure.ReadSnapshot"/> object.
            </summary>
        </member>
        <member name="T:GSF.IO.FileStructure.TransactionalFileStructure">
            <summary>
            This class is responsible for managing the transactions that occur on the file system.
            Therefore, it keeps up with the latest snapshot of the file allocation table, 
            permits only a single concurrent edit of the archive system, and determines when a file
            can be deleted when there are no read or write transactions. It also containst the IO system.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.TransactionalFileStructure.m_disposed">
            <summary>
            Determines if this object has been disposed.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.TransactionalFileStructure.m_diskIo">
            <summary>
            Contains the disk IO subsystem for accessing the file.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.TransactionalFileStructure.m_currentTransaction">
            <summary>
            Contains the current active transaction.  If this null, there is no active transaction.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.TransactionalFileStructure.m_currentReadTransaction">
            <summary>
            Contains the current read transaction.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.TransactionalFileStructure.CreateInMemory(System.Int32,System.Guid[])">
            <summary>
            Creates a new archive file that is completely in memory
             </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.TransactionalFileStructure.CreateFile(System.String,System.Int32,System.Guid[])">
            <summary>
            Creates a new archive file using the provided file. File is editable.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.TransactionalFileStructure.OpenFile(System.String,System.Boolean)">
            <summary>
            Opens an existing file.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.TransactionalFileStructure.ArchiveSize">
            <summary>
            Gets the current size of the archive.
            </summary>
        </member>
        <member name="P:GSF.IO.FileStructure.TransactionalFileStructure.Snapshot">
            <summary>
            Gets the last committed read snapshot on the file system.
            </summary>
            <returns></returns>
        </member>
        <member name="P:GSF.IO.FileStructure.TransactionalFileStructure.FileName">
            <summary>
            Gets the file name for the <see cref="T:GSF.IO.FileStructure.TransactionalFileStructure"/>
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.TransactionalFileStructure.BeginEdit">
            <summary>
            This will start a transactional edit on the file. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.IO.FileStructure.TransactionalFileStructure.ChangeExtension(System.String,System.Boolean,System.Boolean)">
            <summary>
            Changes the extension of the current file.
            </summary>
            <param name="extension">the new extension</param>
            <param name="isReadOnly">If the file should be reopened as readonly</param>
            <param name="isSharingEnabled">If the file should share read privileges.</param>
        </member>
        <member name="M:GSF.IO.FileStructure.TransactionalFileStructure.ChangeShareMode(System.Boolean,System.Boolean)">
            <summary>
            Reopens the file with different permissions.
            </summary>
            <param name="isReadOnly">If the file should be reopened as readonly</param>
            <param name="isSharingEnabled">If the file should share read privileges.</param>
        </member>
        <member name="M:GSF.IO.FileStructure.TransactionalFileStructure.Dispose">
            <summary>
            Releases all the resources used by the <see cref="T:GSF.IO.FileStructure.TransactionalFileStructure"/> object.
            </summary>
        </member>
        <member name="T:GSF.IO.FileStructure.ReadSnapshot">
            <summary>
            Aquires a snapshot of the file system to browse in an isolated mannor.  
            This is read only and will also block the main file from being deleted. 
            Therefore it is important to release this lock so the file can be deleted after a rollover.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.ReadSnapshot.m_fileHeaderBlock">
            <summary>
            The readonly snapshot of the archive file.
            </summary>
        </member>
        <member name="F:GSF.IO.FileStructure.ReadSnapshot.m_dataReader">
            <summary>
            The underlying diskIO to do the reads against.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.ReadSnapshot.#ctor(GSF.IO.FileStructure.Media.DiskIo)">
            <summary>
            Creates a readonly copy of a transaction.
            </summary>
            <param name="dataReader"></param>
        </member>
        <member name="P:GSF.IO.FileStructure.ReadSnapshot.Header">
            <summary>
            Gets the header of the file structure.
            </summary>
        </member>
        <member name="M:GSF.IO.FileStructure.ReadSnapshot.OpenFile(System.Int32)">
            <summary>
            Opens a ArchiveFileStream that can be used to read the file passed to this function.
            </summary>
            <param name="fileIndex">The index of the file to open.</param>
            <returns></returns>
        </member>
        <member name="M:GSF.IO.FileStructure.ReadSnapshot.OpenFile(GSF.IO.FileStructure.SubFileName)">
            <summary>
            Opens a ArchiveFileStream that can be used to read/write to the file passed to this function.
            </summary>
            <returns></returns>
        </member>
        <member name="T:GSF.IO.PathHelpers">
            <summary>
            Helper methods for path strings.
            </summary>
        </member>
        <member name="M:GSF.IO.PathHelpers.FormatExtension(System.String)">
            <summary>
            ensures that the provided extension is in the provided format:  .exe
            </summary>
            <param name="extension">the extension to format. Can be *.exe, or .exe, or exe</param>
            <returns>
            a vaild extension.
            </returns>
            <remarks>
            throws a series of exceptions if the <see cref="!:extension"/> is invalid.
            </remarks>
        </member>
        <member name="M:GSF.IO.PathHelpers.ValidateFileName(System.String)">
            <summary>
            Ensures the supplied file name is valid.
            </summary>
            <param name="fileName">any filename.</param>
            <remarks>
            throws a series of exceptions if the <see cref="!:fileName"/> is invalid.
            </remarks>
        </member>
        <member name="M:GSF.IO.PathHelpers.ValidatePathName(System.String)">
            <summary>
            Ensures the supplied path name is valid.
            </summary>
            <param name="pathName">any path.</param>
            <remarks>
            throws a series of exceptions if the <see cref="!:pathName"/> is invalid.
            </remarks>
        </member>
        <member name="T:GSF.IO.NetworkStreamSimulator">
            <summary>
            Provides a stream that functions like a network stream
            except it cuts out the socket layer.
            </summary>
        </member>
        <member name="F:GSF.IO.NetworkStreamSimulator.ClientStream">
            <summary>
            The client's stream
            </summary>
        </member>
        <member name="F:GSF.IO.NetworkStreamSimulator.ServerStream">
            <summary>
            The server's stream
            </summary>
        </member>
        <member name="M:GSF.IO.NetworkStreamSimulator.#ctor">
            <summary>
            Creates a new <see cref="T:GSF.IO.NetworkStreamSimulator"/>
            </summary>
        </member>
        <member name="T:GSF.IO.UltraStreamWriter">
            <summary>
            Represents an ultra high speed way to write data to a stream. 
            StreamWriter's methods can be slow at times.
            </summary>
        </member>
        <member name="M:GSF.IO.UltraStreamWriter.#ctor(System.IO.StreamWriter)">
            <summary>
            Creates a <see cref="T:GSF.IO.UltraStreamWriter"/> around <see cref="T:System.IO.Stream"/>
            </summary>
            <param name="stream">The stream to wrap</param>
        </member>
        <member name="M:GSF.IO.UltraStreamWriter.Write(System.Char)">
            <summary>
            Writes the provided character to the stream
            </summary>
            <param name="value">the character to write.</param>
        </member>
        <member name="M:GSF.IO.UltraStreamWriter.Write(System.Single)">
            <summary>
            Writes the provided float to the stream
            </summary>
            <param name="value">the value to write.</param>
        </member>
        <member name="M:GSF.IO.UltraStreamWriter.WriteLine">
            <summary>
            Writes a NewLine to the stream
            </summary>
        </member>
        <member name="M:GSF.IO.UltraStreamWriter.Flush">
            <summary>
            Flushes to the underlying stream
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.BinaryStream.m_leaveOpen">
            <summary>
            Determines if this class owns the underlying stream, thus when Dispose() is called
            the dispose of the underlying stream will also be called.
            </summary>
        </member>
        <member name="M:GSF.IO.Unmanaged.BinaryStream.#ctor">
            <summary>
            Creates a <see cref="T:GSF.IO.Unmanaged.BinaryStream"/> that is in memory only.
            </summary>
        </member>
        <member name="M:GSF.IO.Unmanaged.BinaryStream.#ctor(GSF.IO.Unmanaged.MemoryPool)">
            <summary>
            Creates a <see cref="T:GSF.IO.Unmanaged.BinaryStream"/> that is in memory only.
            </summary>
        </member>
        <member name="M:GSF.IO.Unmanaged.BinaryStream.#ctor(System.Boolean)">
            <summary>
            Creates a <see cref="T:GSF.IO.Unmanaged.BinaryStream"/> that is in memory only.
            </summary>
            <param name="allocatesOwnMemory">true to allowcate its own memory rather than using the <see cref="T:GSF.IO.Unmanaged.MemoryPool"/>.</param>
        </member>
        <member name="M:GSF.IO.Unmanaged.BinaryStream.#ctor(GSF.IO.Unmanaged.ISupportsBinaryStream,System.Boolean)">
            <summary>
            Creates a <see cref="T:GSF.IO.Unmanaged.BinaryStream"/> that is at position 0 of the provided stream.
            </summary>
            <param name="stream">The base stream to use.</param>
            <param name="leaveOpen">Determines if the underlying stream will automatically be 
            disposed of when this class has it's dispose method called.</param>
        </member>
        <member name="M:GSF.IO.Unmanaged.BinaryStream.ClearLocks">
            <summary>
            When accessing the underlying stream, a lock is placed on the data. Calling this method clears that lock.
            </summary>
        </member>
        <member name="M:GSF.IO.Unmanaged.BinaryStream.UpdateLocalBuffer(System.Boolean)">
            <summary>
            Updates the local buffer data.
            </summary>
            <param name="isWriting">hints to the stream if write access is desired.</param>
        </member>
        <member name="T:GSF.IO.Unmanaged.BinaryStreamPointerWrapper">
            <summary>
            Creates a <see cref="T:GSF.IO.BinaryStreamBase"/> that wraps a single pointer.
            </summary>
        </member>
        <member name="M:GSF.IO.Unmanaged.BinaryStreamPointerWrapper.#ctor(System.Byte*,System.Int32)">
            <summary>
            Creates a <see cref="T:GSF.IO.Unmanaged.BinaryStreamPointerWrapper"/>.
            </summary>
            <param name="stream">the byte pointer that starts the stream</param>
            <param name="length">the valid length of the pointer.</param>
        </member>
        <member name="M:GSF.IO.Unmanaged.BinaryStreamPointerWrapper.UpdateLocalBuffer(System.Boolean)">
            <summary>
            Updates the local buffer data.
            </summary>
            <param name="isWriting">hints to the stream if write access is desired.</param>
        </member>
        <member name="T:GSF.IO.Unmanaged.BinaryStreamIoSessionBase">
            <summary>
            Implementing this interface allows a binary stream to be attached to a buffer.
            </summary>
        </member>
        <member name="P:GSF.IO.Unmanaged.BinaryStreamIoSessionBase.IsDisposed">
            <summary>
            Gets if the object has been disposed
            </summary>
        </member>
        <member name="M:GSF.IO.Unmanaged.BinaryStreamIoSessionBase.GetBlock(GSF.IO.Unmanaged.BlockArguments)">
            <summary>
            Gets a block for the following Io session.
            </summary>
            <param name="args">The block request that needs to be fulfilled by this IoSession.</param>
        </member>
        <member name="M:GSF.IO.Unmanaged.BinaryStreamIoSessionBase.Clear">
            <summary>
            Sets the current usage of the <see cref="T:GSF.IO.Unmanaged.BinaryStreamIoSessionBase"/> to null.
            </summary>
        </member>
        <member name="M:GSF.IO.Unmanaged.BinaryStreamIoSessionBase.Dispose">
            <summary>
            Releases all the resources used by the <see cref="T:GSF.IO.Unmanaged.BinaryStreamIoSessionBase"/> object.
            </summary>
        </member>
        <member name="M:GSF.IO.Unmanaged.BinaryStreamIoSessionBase.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:GSF.IO.Unmanaged.BinaryStreamIoSessionBase"/> object and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="T:GSF.IO.Unmanaged.BlockArguments">
            <summary>
            A set of fields that are passed to a <see cref="M:GSF.IO.Unmanaged.BinaryStreamIoSessionBase.GetBlock(GSF.IO.Unmanaged.BlockArguments)"/> method to get results.
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.BlockArguments.Position">
            <summary>
            the block returned must contain this position
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.BlockArguments.IsWriting">
            <summary>
            indicates if the stream plans to write to this block
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.BlockArguments.FirstPointer">
            <summary>
            the pointer for the first byte of the block
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.BlockArguments.FirstPosition">
            <summary>
            the position that corresponds to <see cref="F:GSF.IO.Unmanaged.BlockArguments.FirstPointer"/>
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.BlockArguments.Length">
            <summary>
            the length of the block
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.BlockArguments.SupportsWriting">
            <summary>
            notifies the calling class if this block supports 
            writing without requiring this function to be called again if <see cref="F:GSF.IO.Unmanaged.BlockArguments.IsWriting"/> was set to false.
            </summary>
        </member>
        <member name="T:GSF.IO.Unmanaged.ISupportsBinaryStream">
            <summary>
            Implementing this interface allows a binary stream to be attached to a buffer.
            </summary>
        </member>
        <member name="P:GSF.IO.Unmanaged.ISupportsBinaryStream.RemainingSupportedIoSessions">
            <summary>
            Gets the number of available simultaneous read/write sessions.
            </summary>
            <remarks>This value is used to determine if a binary stream can be cloned
            to improve read/write/copy performance.</remarks>
        </member>
        <member name="P:GSF.IO.Unmanaged.ISupportsBinaryStream.IsReadOnly">
            <summary>
            Gets if the stream can be written to.
            </summary>
        </member>
        <member name="P:GSF.IO.Unmanaged.ISupportsBinaryStream.IsDisposed">
            <summary>
            Gets if the stream has been disposed.
            </summary>
        </member>
        <member name="M:GSF.IO.Unmanaged.ISupportsBinaryStream.CreateIoSession">
            <summary>
            Aquire an IO Session.
            </summary>
        </member>
        <member name="T:GSF.IO.Unmanaged.MemoryPoolStream">
            <summary>
            Provides a in memory stream that uses pages that are pooled in the unmanaged buffer pool.
            </summary>
            <summary>
            Provides a in memory stream that uses pages that are pooled in the unmanaged buffer pool.
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.MemoryPoolStream.m_blockSize">
            <summary>
            The size of each page.
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.MemoryPoolStream.m_disposed">
            <summary>
            Releases all the resources used by the <see cref="T:GSF.IO.Unmanaged.MemoryPoolStream"/> object.
            </summary>
        </member>
        <member name="M:GSF.IO.Unmanaged.MemoryPoolStream.#ctor">
            <summary>
            Creates a new <see cref="T:GSF.IO.Unmanaged.MemoryPoolStream"/> using the default <see cref="T:GSF.IO.Unmanaged.MemoryPool"/>.
            </summary>
        </member>
        <member name="M:GSF.IO.Unmanaged.MemoryPoolStream.#ctor(GSF.IO.Unmanaged.MemoryPool)">
            <summary>
            Create a new <see cref="T:GSF.IO.Unmanaged.MemoryPoolStream"/>
            </summary>
        </member>
        <member name="P:GSF.IO.Unmanaged.MemoryPoolStream.BlockSize">
            <summary>
            Gets the unit size of an individual block
            </summary>
        </member>
        <member name="P:GSF.IO.Unmanaged.MemoryPoolStream.IsReadOnly">
            <summary>
            Gets if the stream can be written to.
            </summary>
        </member>
        <member name="P:GSF.IO.Unmanaged.MemoryPoolStream.GSF#IO#Unmanaged#ISupportsBinaryStream#RemainingSupportedIoSessions">
            <summary>
            Gets the number of available simultaneous read/write sessions.
            </summary>
            <remarks>This value is used to determine if a binary stream can be cloned
            to improve read/write/copy performance.</remarks>
        </member>
        <member name="M:GSF.IO.Unmanaged.MemoryPoolStream.CreateIoSession">
            <summary>
            Aquire an IO Session.
            </summary>
        </member>
        <member name="M:GSF.IO.Unmanaged.MemoryPoolStream.CreateBinaryStream">
            <summary>
            Creates a new binary from an IO session
            </summary>
            <returns></returns>
        </member>
        <member name="T:GSF.IO.Unmanaged.MemoryPoolStreamCore">
            <summary>
            Provides a dynamically sizing sequence of unmanaged data.
            </summary>
        </member>
        <member name="T:GSF.IO.Unmanaged.MemoryPoolStreamCore.Settings">
            <summary>
            This class was created to allow settings update to be atomic.
            </summary>
        </member>
        <member name="M:GSF.IO.Unmanaged.MemoryPoolStreamCore.Settings.GetAllPageIndexes">
            <summary>
            Returns all of the buffer pool page indexes used by this class
            </summary>
            <returns></returns>
        </member>
        <member name="F:GSF.IO.Unmanaged.MemoryPoolStreamCore.m_pool">
            <summary>
            The buffer pool to utilize
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.MemoryPoolStreamCore.m_firstValidPosition">
            <summary>
            The first position that can be accessed by users of this stream
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.MemoryPoolStreamCore.m_firstAddressablePosition">
            <summary>
            The first position of this stream. This may be different from <see cref="F:GSF.IO.Unmanaged.MemoryPoolStreamCore.m_firstValidPosition"/> 
            due to alignment requirements
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.MemoryPoolStreamCore.m_shiftLength">
            <summary>
            The number of bits in the page size.
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.MemoryPoolStreamCore.m_pageSize">
            <summary>
            The size of each page.
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.MemoryPoolStreamCore.m_disposed">
            <summary>
            Releases all the resources used by the <see cref="!:MemoryFile"/> object.
            </summary>
        </member>
        <member name="M:GSF.IO.Unmanaged.MemoryPoolStreamCore.#ctor">
            <summary>
            Creates a new <see cref="T:GSF.IO.Unmanaged.MemoryPoolStreamCore"/> using the default <see cref="T:GSF.IO.Unmanaged.MemoryPool"/>.
            </summary>
        </member>
        <member name="M:GSF.IO.Unmanaged.MemoryPoolStreamCore.#ctor(GSF.IO.Unmanaged.MemoryPool)">
            <summary>
            Create a new <see cref="T:GSF.IO.Unmanaged.MemoryPoolStreamCore"/>
            </summary>
        </member>
        <member name="M:GSF.IO.Unmanaged.MemoryPoolStreamCore.Finalize">
            <summary>
            Releases the unmanaged resources before the <see cref="T:GSF.IO.Unmanaged.MemoryPoolStreamCore"/> object is reclaimed by <see cref="T:System.GC"/>.
            </summary>
        </member>
        <member name="P:GSF.IO.Unmanaged.MemoryPoolStreamCore.IsDisposed">
            <summary>
            Gets if the stream has been disposed.
            </summary>
        </member>
        <member name="P:GSF.IO.Unmanaged.MemoryPoolStreamCore.Length">
            <summary>
            Gets the length of the current stream.
            </summary>
        </member>
        <member name="M:GSF.IO.Unmanaged.MemoryPoolStreamCore.ConfigureAlignment(System.Int64)">
            <summary>
            Configure the natural alignment of the data.
            </summary>
            <param name="startPosition">The first addressable position</param>
        </member>
        <member name="M:GSF.IO.Unmanaged.MemoryPoolStreamCore.ConfigureAlignment(System.Int64,System.Int32)">
            <summary>
            Configure the natural alignment of the data.
            </summary>
            <param name="startPosition">The first addressable position</param>
            <param name="alignment">Forces alignment on this boundary.
            Alignment must be a factor of the BufferPool's page boudary.</param>
        </member>
        <member name="M:GSF.IO.Unmanaged.MemoryPoolStreamCore.GetBlock(GSF.IO.Unmanaged.BlockArguments)">
            <summary>
            Gets a block for the following Io session.
            </summary>
        </member>
        <member name="M:GSF.IO.Unmanaged.MemoryPoolStreamCore.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:GSF.IO.Unmanaged.MemoryPoolStreamCore.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="!:MemoryFile"/> object and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="M:GSF.IO.Unmanaged.MemoryPoolStreamCore.GetPage(System.Int64)">
            <summary>
            Returns the page that corresponds to the absolute position.  
            This function will also autogrow the stream.
            </summary>
            <param name="position">The position to use to calculate the page to retrieve</param>
            <returns></returns>
        </member>
        <member name="M:GSF.IO.Unmanaged.MemoryPoolStreamCore.IncreasePageCount(System.Int32)">
            <summary>
            Increases the size of the Memory Stream and updated the settings if needed
            </summary>
            <param name="pageCount"></param>
        </member>
        <member name="M:GSF.IO.Unmanaged.MemoryPoolStreamCore.ReadBlock(System.Int64,System.IntPtr@,System.Int32@)">
            <summary>
            Reads from the underlying stream the requested set of data. 
            This function is more user friendly than calling GetBlock().
            </summary>
            <param name="position">the starting position of the read</param>
            <param name="pointer">an output pointer to <see cref="!:position"/>.</param>
            <param name="validLength">the number of bytes that are valid after this position.</param>
            <returns></returns>
        </member>
        <member name="T:GSF.IO.Unmanaged.UnmanagedMemoryStream">
            <summary>
            Provides a in memory stream that allocates its own unmanaged memory
            </summary>
            <summary>
            Provides a in memory stream that allocates its own unmanaged memory
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.UnmanagedMemoryStream.m_disposed">
            <summary>
            Releases all the resources used by the <see cref="T:GSF.IO.Unmanaged.MemoryPoolStream"/> object.
            </summary>
        </member>
        <member name="M:GSF.IO.Unmanaged.UnmanagedMemoryStream.#ctor(System.Int32)">
            <summary>
            Create a new <see cref="T:GSF.IO.Unmanaged.UnmanagedMemoryStream"/> that allocates its own unmanaged memory.
            </summary>
        </member>
        <member name="P:GSF.IO.Unmanaged.UnmanagedMemoryStream.IsReadOnly">
            <summary>
            Gets if the stream can be written to.
            </summary>
        </member>
        <member name="P:GSF.IO.Unmanaged.UnmanagedMemoryStream.GSF#IO#Unmanaged#ISupportsBinaryStream#RemainingSupportedIoSessions">
            <summary>
            Gets the number of available simultaneous read/write sessions.
            </summary>
            <remarks>This value is used to determine if a binary stream can be cloned
            to improve read/write/copy performance.</remarks>
        </member>
        <member name="M:GSF.IO.Unmanaged.UnmanagedMemoryStream.CreateIoSession">
            <summary>
            Aquire an IO Session.
            </summary>
        </member>
        <member name="M:GSF.IO.Unmanaged.UnmanagedMemoryStream.CreateBinaryStream">
            <summary>
            Creates a new binary from an IO session
            </summary>
            <returns></returns>
        </member>
        <member name="T:GSF.IO.Unmanaged.UnmanagedMemoryStreamCore">
            <summary>
            Provides a dynamically sizing sequence of unmanaged data.
            </summary>
        </member>
        <member name="T:GSF.IO.Unmanaged.UnmanagedMemoryStreamCore.Settings">
            <summary>
            This class was created to allow settings update to be atomic.
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.UnmanagedMemoryStreamCore.m_firstValidPosition">
            <summary>
            The first position that can be accessed by users of this stream
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.UnmanagedMemoryStreamCore.m_firstAddressablePosition">
            <summary>
            The first position of this stream. This may be different from <see cref="F:GSF.IO.Unmanaged.UnmanagedMemoryStreamCore.m_firstValidPosition"/> 
            due to alignment requirements
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.UnmanagedMemoryStreamCore.m_shiftLength">
            <summary>
            The number of bits in the page size.
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.UnmanagedMemoryStreamCore.m_pageSize">
            <summary>
            The size of each page.
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.UnmanagedMemoryStreamCore.m_disposed">
            <summary>
            Releases all the resources used by the <see cref="!:MemoryFile"/> object.
            </summary>
        </member>
        <member name="M:GSF.IO.Unmanaged.UnmanagedMemoryStreamCore.#ctor(System.Int32)">
            <summary>
            Create a new <see cref="T:GSF.IO.Unmanaged.UnmanagedMemoryStreamCore"/> that allocates its own unmanaged memory.
            </summary>
        </member>
        <member name="P:GSF.IO.Unmanaged.UnmanagedMemoryStreamCore.IsDisposed">
            <summary>
            Gets if the stream has been disposed.
            </summary>
        </member>
        <member name="P:GSF.IO.Unmanaged.UnmanagedMemoryStreamCore.Length">
            <summary>
            Gets the length of the current stream.
            </summary>
        </member>
        <member name="M:GSF.IO.Unmanaged.UnmanagedMemoryStreamCore.ConfigureAlignment(System.Int64)">
            <summary>
            Configure the natural alignment of the data.
            </summary>
            <param name="startPosition">The first addressable position</param>
        </member>
        <member name="M:GSF.IO.Unmanaged.UnmanagedMemoryStreamCore.ConfigureAlignment(System.Int64,System.Int32)">
            <summary>
            Configure the natural alignment of the data.
            </summary>
            <param name="startPosition">The first addressable position</param>
            <param name="alignment">Forces alignment on this boundary.
            Alignment must be a factor of the BufferPool's page boudary.</param>
        </member>
        <member name="M:GSF.IO.Unmanaged.UnmanagedMemoryStreamCore.GetBlock(GSF.IO.Unmanaged.BlockArguments)">
            <summary>
            Gets a block for the following Io session.
            </summary>
        </member>
        <member name="M:GSF.IO.Unmanaged.UnmanagedMemoryStreamCore.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:GSF.IO.Unmanaged.UnmanagedMemoryStreamCore.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="!:MemoryFile"/> object and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="M:GSF.IO.Unmanaged.UnmanagedMemoryStreamCore.GetPage(System.Int64)">
            <summary>
            Returns the page that corresponds to the absolute position.  
            This function will also autogrow the stream.
            </summary>
            <param name="position">The position to use to calculate the page to retrieve</param>
            <returns></returns>
        </member>
        <member name="M:GSF.IO.Unmanaged.UnmanagedMemoryStreamCore.IncreasePageCount(System.Int32)">
            <summary>
            Increases the size of the Memory Stream and updated the settings if needed
            </summary>
            <param name="pageCount"></param>
        </member>
        <member name="M:GSF.IO.Unmanaged.UnmanagedMemoryStreamCore.ReadBlock(System.Int64,System.IntPtr@,System.Int32@)">
            <summary>
            Reads from the underlying stream the requested set of data. 
            This function is more user friendly than calling GetBlock().
            </summary>
            <param name="position">the starting position of the read</param>
            <param name="pointer">an output pointer to <see cref="!:position"/>.</param>
            <param name="validLength">the number of bytes that are valid after this position.</param>
            <returns></returns>
        </member>
        <member name="T:GSF.IO.Unmanaged.MemoryPoolCollectionMode">
            <summary>
            Speifies how critical the collection of memory blocks is.
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.MemoryPoolCollectionMode.None">
            <summary>
            This means no collection has to occur.
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.MemoryPoolCollectionMode.Normal">
            <summary>
            This is the routine mode
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.MemoryPoolCollectionMode.Emergency">
            <summary>
            This means the engine is using more memory than desired
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.MemoryPoolCollectionMode.Critical">
            <summary>
            This means any memory that can be released should be released. 
            If no memory is released after this pass, 
            an out of memory exception will occur.
            </summary>
        </member>
        <member name="T:GSF.IO.Unmanaged.CollectionEventArgs">
            <summary>
            This contains information about the collection that is requested from the system.
            </summary>
        </member>
        <member name="P:GSF.IO.Unmanaged.CollectionEventArgs.DesiredPageReleaseCount">
            <summary>
            When <see cref="P:GSF.IO.Unmanaged.CollectionEventArgs.CollectionMode"/> is <see cref="F:GSF.IO.Unmanaged.MemoryPoolCollectionMode.Emergency"/> or 
            <see cref="F:GSF.IO.Unmanaged.MemoryPoolCollectionMode.Critical"/> this field contains the number of pages
            that need to be released by all of the objects. This value will automatically decrement
            every time a page has been released.
            </summary>
        </member>
        <member name="P:GSF.IO.Unmanaged.CollectionEventArgs.CollectionMode">
            <summary>
            The mode for the collection
            </summary>
        </member>
        <member name="M:GSF.IO.Unmanaged.CollectionEventArgs.#ctor(System.Action{System.Int32},GSF.IO.Unmanaged.MemoryPoolCollectionMode,System.Int32)">
            <summary>
            Creates a new <see cref="T:GSF.IO.Unmanaged.CollectionEventArgs"/>.
            </summary>
            <param name="releasePage"></param>
            <param name="collectionMode"></param>
            <param name="desiredPageReleaseCount"></param>
        </member>
        <member name="M:GSF.IO.Unmanaged.CollectionEventArgs.ReleasePage(System.Int32)">
            <summary>
            Releases an unused page.
            </summary>
            <param name="index">the index of the page</param>
        </member>
        <member name="T:GSF.IO.Unmanaged.Memory">
            <summary>
            This class is used to allocate and free unmanaged memory.  To release memory allocated throught this class,
            call the Dispose method of the return value.
            </summary>
            <remarks>
            .NET does not respond well when managing tens of GBs of ram.  If a very large buffer pool must be created,
            it would be good to allocate that buffer pool in unmanaged memory.
            </remarks>
        </member>
        <member name="M:GSF.IO.Unmanaged.Memory.#ctor(System.Int32)">
            <summary>
            Allocates unmanaged memory. The block is uninitialized.
            </summary>
            <param name="requestedSize">The desired number of bytes to allocate. 
            Be sure to check the actual size in the return class. </param>
            <returns>The allocated memory.</returns>
        </member>
        <member name="M:GSF.IO.Unmanaged.Memory.Finalize">
            <summary>
            Releases the unmanaged resources before the <see cref="T:GSF.IO.Unmanaged.Memory"/> object is reclaimed by <see cref="T:System.GC"/>.
            </summary>
        </member>
        <member name="P:GSF.IO.Unmanaged.Memory.Address">
            <summary>
            The pointer to the first byte of this unmanaged memory. 
            Equals <see cref="F:System.IntPtr.Zero"/> if memory has been released.
            </summary>
        </member>
        <member name="P:GSF.IO.Unmanaged.Memory.Size">
            <summary>
            The number of bytes in this allocation.
            </summary>
        </member>
        <member name="M:GSF.IO.Unmanaged.Memory.Release">
            <summary>
            Releases the allocated memory back to the OS.
            Same thing as calling Dispose().
            </summary>
        </member>
        <member name="M:GSF.IO.Unmanaged.Memory.Dispose">
            <summary>
            Releases all the resources used by the <see cref="T:GSF.IO.Unmanaged.Memory"/> object.
            </summary>
        </member>
        <member name="M:GSF.IO.Unmanaged.Memory.Copy(System.Byte*,System.Byte*,System.Int32)">
            <summary>
            Does a safe copy of data from one location to another. 
            A safe copy allows for the source and destination to overlap.
            </summary>
            <param name="src"></param>
            <param name="dest"></param>
            <param name="count"></param>
        </member>
        <member name="M:GSF.IO.Unmanaged.Memory.Copy(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Does a safe copy of data from one location to another. 
            A safe copy allows for the source and destination to overlap.
            </summary>
            <param name="src"></param>
            <param name="dest"></param>
            <param name="count"></param>
        </member>
        <member name="M:GSF.IO.Unmanaged.Memory.Clear(System.Byte*,System.Int32)">
            <summary>
            Sets the data in this buffer to all zeroes
            </summary>
            <param name="pointer">the starting position.</param>
            <param name="length">the number of bytes to clear.</param>
        </member>
        <member name="M:GSF.IO.Unmanaged.Memory.Clear(System.IntPtr,System.Int32)">
            <summary>
            Sets the data in this buffer to all zeroes
            </summary>
            <param name="pointer">the starting position.</param>
            <param name="length">the number of bytes to clear.</param>
        </member>
        <member name="T:GSF.IO.Unmanaged.TargetUtilizationLevels">
            <summary>
            Deteremines the desired buffer pool utilization level.
            Setting to Low will cause collection cycles to occur more often to keep the 
            utilization level to low. 
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.TargetUtilizationLevels.Low">
            <summary>
            Collections won't occur until over 25% of the memory is consumed.
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.TargetUtilizationLevels.Medium">
            <summary>
            Collections won't occur until over 50% of the memory is consumed.
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.TargetUtilizationLevels.High">
            <summary>
            Collections won't occur until over 75% of the memory is consumed.
            </summary>
        </member>
        <member name="T:GSF.IO.Unmanaged.MemoryPool">
            <summary>
            This class allocates and pools unmanaged memory.
            Designed to be internally thread safe.
            </summary>
            <remarks>
            Be careful how this class is referenced. Deadlocks can occur
            when registering to event <see cref="E:GSF.IO.Unmanaged.MemoryPool.RequestCollection"/> and
            when calling <see cref="M:GSF.IO.Unmanaged.MemoryPool.AllocatePage(System.Int32@,System.IntPtr@)"/>. See comments for these methods
            for considerations.
            </remarks>
        </member>
        <member name="F:GSF.IO.Unmanaged.MemoryPool.MaximumTestedSupportedMemoryCeiling">
            <summary>
            Represents the ceiling for the amount of memory the buffer pool can use (124GB)
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.MemoryPool.MinimumTestedSupportedMemoryFloor">
            <summary>
            Represents the minimum amount of memory that the buffer pool needs to work properly (10MB)
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.MemoryPool.m_requestCollectionEvent">
            <summary>
            Delegates are placed in a List because
            in a later version, some sort of concurrent garbage collection may be implemented
            which means more control will need to be with the Event
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.MemoryPool.m_syncRoot">
            <summary>
            Used for synchronizing modifications to this class.
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.MemoryPool.m_syncAllocate">
            <summary>
            All allocates are synchronized seperately since an allocation can request a collection. 
            This will create a queuing nature of the allocations.
            </summary>
        </member>
        <member name="P:GSF.IO.Unmanaged.MemoryPool.TargetUtilizationLevel">
            <summary>
            Gets the current <see cref="T:GSF.IO.Unmanaged.TargetUtilizationLevels"/>.
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.MemoryPool.PageSize">
            <summary>
            Each page will be exactly this size (Based on RAM)
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.MemoryPool.PageMask">
            <summary>
            Provides a mask that the user can apply that can 
            be used to get the offset position of a page.
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.MemoryPool.PageShiftBits">
            <summary>
            Gets the number of bits that must be shifted to calculate an index of a position.
            This is not the same as a page index that is returned by the allocate functions.
            </summary>
        </member>
        <member name="E:GSF.IO.Unmanaged.MemoryPool.RequestCollection">
            <summary>
            Requests that classes using this <see cref="T:GSF.IO.Unmanaged.MemoryPool"/> release any unused buffers.
            Failing to do so may result in an <see cref="T:System.OutOfMemoryException"/> to occur.
            <remarks>IMPORTANT NOTICE: No not call <see cref="M:GSF.IO.Unmanaged.MemoryPool.AllocatePage(System.Int32@,System.IntPtr@)"/> via the thread
            that raises this event. Also, be careful about entering a lock via this thread
            because a potential deadlock might occur. 
            
            Also, Do not remove a handler from within a lock context as the remove
            blocks until all events have been called. A potential for another deadlock.</remarks>
            </summary>
        </member>
        <member name="M:GSF.IO.Unmanaged.MemoryPool.#ctor(System.Int32,System.Int64,GSF.IO.Unmanaged.TargetUtilizationLevels)">
            <summary>
            Creates a new <see cref="T:GSF.IO.Unmanaged.MemoryPool"/>.
            </summary>
            <param name="pageSize">The desired page size. Must be between 4KB and 256KB</param>
            <param name="maximumBufferSize">The desired maximum size of the allocation. Note: could be less if there is not enough system memory.</param>
            <param name="utilizationLevel">Specifies the desired utilization level of the allocated space.</param>
        </member>
        <member name="P:GSF.IO.Unmanaged.MemoryPool.AllocatedBytes">
            <summary>
            Returns the number of bytes currently allocated by the buffer pool to other objects
            </summary>
        </member>
        <member name="P:GSF.IO.Unmanaged.MemoryPool.MaximumPoolSize">
            <summary>
            The maximum amount of RAM that this memory pool is configured to support
            Attempting to allocate more than this will cause an out of memory exception
            </summary>
        </member>
        <member name="P:GSF.IO.Unmanaged.MemoryPool.CurrentAllocatedSize">
            <summary>
            Returns the number of bytes allocated by all buffer pools.
            This does not include any pages that have been allocated but are not in use.
            </summary>
        </member>
        <member name="P:GSF.IO.Unmanaged.MemoryPool.CurrentCapacity">
            <summary>
            Gets the number of bytes that have been allocated to this buffer pool 
            by the OS.
            </summary>
        </member>
        <member name="P:GSF.IO.Unmanaged.MemoryPool.IsDisposed">
            <summary>
            Gets if this pool has been disposed.
            </summary>
        </member>
        <member name="M:GSF.IO.Unmanaged.MemoryPool.AllocatePage(System.Int32@,System.IntPtr@)">
            <summary>
            Requests a page from the buffered pool.
            If there is not a free one available, method will block
            and request a collection of unused pages by raising 
            <see cref="E:GSF.IO.Unmanaged.MemoryPool.RequestCollection"/> event.
            </summary>
            <param name="index">the index id of the page that was allocated</param>
            <param name="addressPointer"> outputs a address that can be used
            to access this memory address.  You cannot call release with this parameter.
            Use the returned index to release pages.</param>
            <remarks>
            IMPORTANT NOTICE: Be careful when calling this method as the calling thread
            will block if no memory is available to have a background collection to occur.
            
            There is a possiblity for a deadlock if calling this method from within a lock.
            
            The page allocated will not be initialized, 
            so assume that the data is garbage.</remarks>
        </member>
        <member name="M:GSF.IO.Unmanaged.MemoryPool.ReleasePage(System.Int32)">
            <summary>
            Releases the page back to the buffer pool for reallocation.
            </summary>
            <param name="pageIndex">A value of zero or less will return silently</param>
            <remarks>The page released will not be initialized.
            Releasing a page is on the honor system.  
            Rereferencing a released page will most certainly cause 
            unexpected crashing or data corruption or any other unexplained behavior.
            </remarks>
        </member>
        <member name="M:GSF.IO.Unmanaged.MemoryPool.ReleasePages(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Releases all of the supplied pages
            </summary>
            <param name="pageIndexes">A collection of pages.</param>
        </member>
        <member name="M:GSF.IO.Unmanaged.MemoryPool.SetMaximumBufferSize(System.Int64)">
            <summary>
            Changes the allowable buffer size
            </summary>
            <param name="value">the number of bytes to set.</param>
            <returns></returns>
        </member>
        <member name="M:GSF.IO.Unmanaged.MemoryPool.SetTargetUtilizationLevel(GSF.IO.Unmanaged.TargetUtilizationLevels)">
            <summary>
            Changes the utilization level
            </summary>
            <param name="utilizationLevel"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.IO.Unmanaged.MemoryPool.Dispose">
            <summary>
            Releases all the resources used by the <see cref="T:GSF.IO.Unmanaged.MemoryPool"/> object.
            </summary>
        </member>
        <member name="M:GSF.IO.Unmanaged.MemoryPool.RequestMoreFreeBlocks">
            <summary>
            Determines whether to allocate more memory or to do a collection cycle on the existing pool.
            </summary>
        </member>
        <member name="M:GSF.IO.Unmanaged.MemoryPool.RemoveDeadEvents">
            <summary>
            Searches the collection events and removes any events that have been collected by
            the garbage collector.
            </summary>
        </member>
        <member name="M:GSF.IO.Unmanaged.MemoryPool.GetCollectionLevelBasedOnSize(System.Int64)">
            <summary>
            Gets the number of collection rounds base on the size.
            </summary>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.IO.Unmanaged.MemoryPool.CalculateStopShrinkingLimit(System.Int64)">
            <summary>
            Calculates at what point a collection cycle will cease prematurely.
            </summary>
            <param name="size">the current size.</param>
            <returns></returns>
        </member>
        <member name="T:GSF.IO.Unmanaged.MemoryPoolPageList">
            <summary>
            Maintains a list of all of the memory allocations for the buffer pool.
            </summary>
            <remarks>
            This class is not thread safe.
            </remarks>
        </member>
        <member name="F:GSF.IO.Unmanaged.MemoryPoolPageList.m_memoryBlocks">
            <summary>
            Pointers to each windows API allocation.
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.MemoryPoolPageList.m_isPageFree">
            <summary>
            A bit array that references each page and determines if the page is free.
            Set means page is free, cleared means page is either being used, or was never allocated from windows.
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.MemoryPoolPageList.m_pagesPerMemoryBlock">
            <summary>
            The number of pages that exist within a windows API allocation.
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.MemoryPoolPageList.m_memoryBlockSize">
            <summary>
            The number of bytes per Windows API allocation block
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.MemoryPoolPageList.m_memoryBlockAllocations">
            <summary>
            Gets the number of memory blocks that have been allocated from Windows API.
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.MemoryPoolPageList.m_usedPageCount">
            <summary>
            The number of pages that have been used.
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.MemoryPoolPageList.PageSize">
            <summary>
            Each page will be exactly this size (Based on RAM)
            </summary>
        </member>
        <member name="F:GSF.IO.Unmanaged.MemoryPoolPageList.MemoryPoolCeiling">
            <summary>
            The maximum supported number of bytes that can be allocated based
            on the amount of RAM in the system.  This is not user configurable.
            </summary>
        </member>
        <member name="M:GSF.IO.Unmanaged.MemoryPoolPageList.#ctor(System.Int32,System.Int64)">
            <summary>
            Create a thread safe list of MemoryPool pages.
            </summary>
            <param name="pageSize">The desired page size. Must be between 4KB and 256KB</param>
            <param name="maximumBufferSize">The desired maximum size of the allocation. Note: could be less if there is not enough system memory.
            A value of -1 will default based on available system memory</param>
        </member>
        <member name="P:GSF.IO.Unmanaged.MemoryPoolPageList.MaximumPoolSize">
            <summary>
            The maximum amount of RAM that this memory pool is configured to support
            Attempting to allocate more than this will cause an out of memory exception
            </summary>
        </member>
        <member name="P:GSF.IO.Unmanaged.MemoryPoolPageList.CurrentCapacity">
            <summary>
            Gets the number of bytes that have been allocated to this buffer pool 
            by the OS.
            </summary>
        </member>
        <member name="P:GSF.IO.Unmanaged.MemoryPoolPageList.CurrentAllocatedSize">
            <summary>
            Returns the number of bytes allocated by all buffer pools.
            This does not include any pages that have been allocated but are not in use.
            </summary>
        </member>
        <member name="P:GSF.IO.Unmanaged.MemoryPoolPageList.FreeSpaceBytes">
            <summary>
            Gets if there is any free space.
            </summary>
        </member>
        <member name="P:GSF.IO.Unmanaged.MemoryPoolPageList.IsFull">
            <summary>
            Gets if the pool is currently full
            </summary>
        </member>
        <member name="M:GSF.IO.Unmanaged.MemoryPoolPageList.TryGetNextPage(System.Int32@,System.IntPtr@)">
            <summary>
            Requests a new block from the buffer pool.
            </summary>
            <param name="index">the index identifier of the block</param>
            <param name="addressPointer">the address to the start of the block</param>
            <exception cref="T:System.OutOfMemoryException">Thrown if the list is full</exception>
        </member>
        <member name="M:GSF.IO.Unmanaged.MemoryPoolPageList.ReleasePage(System.Int32)">
            <summary>
            Releases a block back to the pool so it can be re-allocated.
            </summary>
            <param name="index">the index identifier of the block</param>
        </member>
        <member name="M:GSF.IO.Unmanaged.MemoryPoolPageList.ShrinkMemoryPool(System.Int64)">
            <summary>
            Tries to shrink the buffer pool to the provided size
            </summary>
            <param name="size">The size of the buffer pool</param>
            <returns>The final size of the buffer pool</returns>
            <remarks>The buffer pool shrinks to a size less than or equal to <see cref="!:size"/>.</remarks>
        </member>
        <member name="M:GSF.IO.Unmanaged.MemoryPoolPageList.SetMaximumPoolSize(System.Int64)">
            <summary>
            Changes the allowable buffer size
            </summary>
            <param name="value">the number of bytes to set.</param>
            <returns></returns>
        </member>
        <member name="M:GSF.IO.Unmanaged.MemoryPoolPageList.GrowMemoryPool(System.Int64)">
            <summary>
            Grows the buffer pool to have the desired size
            </summary>
        </member>
        <member name="M:GSF.IO.Unmanaged.MemoryPoolPageList.Dispose">
            <summary>
            Disposes of all of the memory on the list.
            </summary>
        </member>
        <member name="M:GSF.IO.Unmanaged.MemoryPoolPageList.CalculateMemoryPoolCeiling(System.Int32,System.Int64)">
            <summary>
            Computes the ceiling of the buffer pool
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.IO.Unmanaged.MemoryPoolPageList.CalculateMemoryBlockSize(System.Int32,System.Int64)">
            <summary>
            Calculates the desired allocation block size to request from the OS.
            </summary>
            <param name="pageSize">the size of each page</param>
            <param name="totalSystemMemory">the total amount of system memory</param>
            <returns>The recommended block size</returns>
            <remarks>
            The recommended block size is the <see cref="!:totalSystemMemory"/> divided by 1000 
            but must be a multiple of the system allocation size and the page size and cannot be larger than 1GB</remarks>
        </member>
        <member name="T:GSF.Net.RemoteBinaryStream">
            <summary>
            A binary stream that works on some kind of piped stream.
            This means the reader of one stream 
            is connected to the writer of another stream.
            </summary>
        </member>
        <member name="M:GSF.Net.RemoteBinaryStream.#ctor(System.IO.Stream,GSF.Threading.WorkerThreadSynchronization)">
            <summary>
            Creates a <see cref="T:GSF.Net.RemoteBinaryStream"/>
            </summary>
            <param name="stream">the underlying stream to wrap</param>
            <param name="workerThreadSynchronization">the synchronization object</param>
        </member>
        <member name="P:GSF.Net.RemoteBinaryStream.WorkerThreadSynchronization">
            <summary>
            Gets the <see cref="P:GSF.Net.RemoteBinaryStream.WorkerThreadSynchronization"/>. 
            This context will be entered when communcating to the socket layer.
            </summary>
        </member>
        <member name="M:GSF.Net.NetworkBinaryStream.Disconnect">
            <summary>
            Disconnects the socket.  Does not throw an exception.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:GSF.Number.BinToReverseBCD(System.UInt32)">
            <summary>
            Converts a uint binary value into a BCD value that is encoded in reverse order.
            This means what was the Most Significant Digit is now the lease significant digit.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:GSF.Security.Authentication.IUserToken">
            <summary>
            An interface for token data that is associated with a user. 
            </summary>
        </member>
        <member name="M:GSF.Security.Authentication.IUserToken.Save(System.IO.Stream)">
            <summary>
            Saves the token to a stream
            </summary>
            <param name="stream">the stream to save to</param>
        </member>
        <member name="M:GSF.Security.Authentication.IUserToken.Load(System.IO.Stream)">
            <summary>
            Loads the token from a stream
            </summary>
            <param name="stream">the stream to load from</param>
        </member>
        <member name="T:GSF.Security.Authentication.NullToken">
            <summary>
            An empty token that does not contain any data.
            </summary>
        </member>
        <member name="T:GSF.Security.Authentication.CertificateUserCredential">
            <summary>
            An individual server side user credential
            </summary>
        </member>
        <member name="M:GSF.Security.Authentication.CertificateUserCredential.#ctor(System.String)">
            <summary>
            Creates user credentials
            </summary>
            <param name="username"></param>
        </member>
        <member name="T:GSF.Security.Authentication.CertificateUserCredentials">
            <summary>
            Provides simple password based authentication that uses Secure Remote Password.
            </summary>
            <remarks>
            It is safe to store the user's credential on the server. This is a zero knowledge 
            password proof, meaning if this database is compromised, a brute force attack
            is the only way to reveal the password.
            </remarks>
        </member>
        <member name="M:GSF.Security.Authentication.CertificateUserCredentials.Lookup(System.String)">
            <summary>
            Looks up the username from the database.
            </summary>
            <param name="username"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Security.Authentication.CertificateUserCredentials.Exists(System.Security.Principal.IIdentity)">
            <summary>
            Gets if the user exists in the database
            </summary>
            <param name="identity">the identity to check</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Security.Authentication.CertificateUserCredentials.AddUser(System.String)">
            <summary>
            Adds the specified user to the credentials database.
            </summary>
            <param name="username"></param>
        </member>
        <member name="T:GSF.Security.Authentication.IntegratedSecurityUserCredential">
            <summary>
            An individual server side user credential
            </summary>
        </member>
        <member name="F:GSF.Security.Authentication.IntegratedSecurityUserCredential.Username">
            <summary>
            The username that was passed to the constructor.
            </summary>
        </member>
        <member name="F:GSF.Security.Authentication.IntegratedSecurityUserCredential.UserID">
            <summary>
            The security identifier for the username
            </summary>
        </member>
        <member name="F:GSF.Security.Authentication.IntegratedSecurityUserCredential.UserToken">
            <summary>
            The token associated with this user and their permissions.
            </summary>
        </member>
        <member name="M:GSF.Security.Authentication.IntegratedSecurityUserCredential.#ctor(System.String,System.Guid)">
            <summary>
            Creates user credentials
            </summary>
            <param name="username"></param>
            <param name="userToken"></param>
        </member>
        <member name="M:GSF.Security.Authentication.IntegratedSecurityUserCredential.#ctor(System.IO.Stream)">
            <summary>
            Loads user credentials from the supplied stream.
            </summary>
        </member>
        <member name="M:GSF.Security.Authentication.IntegratedSecurityUserCredential.Save(System.IO.Stream)">
            <summary>
            Saves to the supplied stream.
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:GSF.Security.Authentication.IntegratedSecurityUserCredential.Load(System.IO.Stream)">
            <summary>
            Loads from the supplied stream.
            </summary>
            <param name="stream"></param>
        </member>
        <member name="T:GSF.Security.Authentication.IntegratedSecurityUserCredentials">
            <summary>
            Provides simple password based authentication that uses Secure Remote Password.
            </summary>
            <remarks>
            It is safe to store the user's credential on the server. This is a zero knowledge 
            password proof, meaning if this database is compromised, a brute force attack
            is the only way to reveal the password.
            </remarks>
        </member>
        <member name="M:GSF.Security.Authentication.IntegratedSecurityUserCredentials.TryGetToken(System.Security.Principal.IIdentity,System.Guid@)">
            <summary>
            Gets if the user exists in the database
            </summary>
            <param name="identity">the identity to check</param>
            <param name="token">The token to extract for the user.</param>
            <returns>true if the user exists</returns>
        </member>
        <member name="M:GSF.Security.Authentication.IntegratedSecurityUserCredentials.AddUser(System.String)">
            <summary>
            Adds the specified user to the credentials database.
            </summary>
            <param name="username"></param>
        </member>
        <member name="M:GSF.Security.Authentication.IntegratedSecurityUserCredentials.AddUser(System.String,System.Guid)">
            <summary>
            Adds the specified user to the credentials database.
            </summary>
            <param name="username"></param>
            <param name="userToken"></param>
        </member>
        <member name="M:GSF.Security.Authentication.IntegratedSecurityUserCredentials.Save(System.IO.Stream)">
            <summary>
            Saves to the supplied stream.
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:GSF.Security.Authentication.IntegratedSecurityUserCredentials.Load(System.IO.Stream)">
            <summary>
            Loads from the supplied stream.
            </summary>
            <param name="stream"></param>
        </member>
        <member name="T:GSF.Security.Authentication.IntegratedSecurityClient">
            <summary>
            Uses windows integrated security to authentication.
            This uses NTLM in non-domain environments 
            and Kerberos in domain environments.
            </summary>
        </member>
        <member name="M:GSF.Security.Authentication.IntegratedSecurityClient.#ctor">
            <summary>
            Uses the default credentials of the user to authenticate
            </summary>
        </member>
        <member name="M:GSF.Security.Authentication.IntegratedSecurityClient.#ctor(System.String,System.String,System.String)">
            <summary>
            Uses the specified username and password to authenticate.
            </summary>
            <param name="username">The username to use</param>
            <param name="password">the password to use</param>
            <param name="domain">the domain to long in as.</param>
        </member>
        <member name="M:GSF.Security.Authentication.IntegratedSecurityClient.TryAuthenticateAsClient(System.IO.Stream,System.Byte[])">
            <summary>
            Authenticates the client using the supplied stream.
            </summary>
            <param name="stream">the stream to use to authenticate the connection.</param>
            <param name="additionalChallenge">Additional data that much match between the client and server
            for the connection to succeed.</param>
            <returns>
            True if authentication succeded, false otherwise.
            </returns>
        </member>
        <member name="T:GSF.Security.Authentication.IntegratedSecurityServer">
            <summary>
            Uses windows integrated security to authentication.
            This uses NTLM in non-domain environments 
            and Kerberos in domain environments.
            </summary>
        </member>
        <member name="F:GSF.Security.Authentication.IntegratedSecurityServer.Users">
            <summary>
            The location for all of the supported identities
            </summary>
        </member>
        <member name="M:GSF.Security.Authentication.IntegratedSecurityServer.#ctor">
            <summary>
            Creates a new <see cref="T:GSF.Security.Authentication.IntegratedSecurityServer"/>.
            </summary>
        </member>
        <member name="M:GSF.Security.Authentication.IntegratedSecurityServer.TryAuthenticateAsServer(System.IO.Stream,System.Guid@,System.Byte[])">
            <summary>
            Authenticates the client stream
            </summary>
            <param name="stream">The stream to autenticate</param>
            <param name="userToken">the user token associated with the identity match</param>
            <param name="additionalChallenge">Additional data that much match between the client and server
            for the connection to succeed.</param>
            <returns>true if successful authentication. False otherwise.</returns>
        </member>
        <member name="M:GSF.Security.Authentication.IntegratedSecurityServer.Save(System.IO.Stream)">
            <summary>
            Saves to the supplied stream.
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:GSF.Security.Authentication.IntegratedSecurityServer.Load(System.IO.Stream)">
            <summary>
            Loads from the supplied stream.
            </summary>
            <param name="stream"></param>
        </member>
        <member name="T:GSF.Security.Authentication.ScramUserCredential">
            <summary>
            An individual server side user credential
            </summary>
        </member>
        <member name="M:GSF.Security.Authentication.ScramUserCredential.#ctor(System.String,System.String,System.Int32,System.Int32,GSF.Security.HashMethod)">
            <summary>
            Adds the following user information to the server's user database
            </summary>
            <param name="username">the username. Cannot be more than 100 characters</param>
            <param name="password">the password. Cannot be more than 1024 characters</param>
            <param name="iterations">The number of iterations. On 2014 technology, 2000 iterations takes about 10ms to compute</param>
            <param name="saltSize">The size of the salt. Defaults to 32 bytes.</param>
            <param name="hashMethod">The hash method to use for authentication</param>
            <remarks>
            Setting a vary large Iterations will not effect how long it takes to negotiate a client on the server end. This is because
            the server precomputes the hash results. The client can optionally also precomute the results so negotiation can take
            milliseconds.
            </remarks>
        </member>
        <member name="T:GSF.Security.Authentication.SrpUserCredential">
            <summary>
            An individual server side user credential
            </summary>
        </member>
        <member name="F:GSF.Security.Authentication.SrpUserCredential.ServerKeyName">
            <summary>
            Session Resume Key Name
            </summary>
        </member>
        <member name="F:GSF.Security.Authentication.SrpUserCredential.ServerHMACKey">
            <summary>
            Session Resume HMAC key
            </summary>
        </member>
        <member name="F:GSF.Security.Authentication.SrpUserCredential.ServerEncryptionkey">
            <summary>
            Session Resume Encryption Key
            </summary>
        </member>
        <member name="F:GSF.Security.Authentication.SrpUserCredential.UserName">
            <summary>
            The normalized name of the user
            </summary>
        </member>
        <member name="F:GSF.Security.Authentication.SrpUserCredential.Salt">
            <summary>
            The salt used to compute the password bytes (x)
            </summary>
        </member>
        <member name="F:GSF.Security.Authentication.SrpUserCredential.Verification">
            <summary>
            The Srp server verification bytes. (Computed as g^x % N)
            </summary>
        </member>
        <member name="F:GSF.Security.Authentication.SrpUserCredential.Iterations">
            <summary>
            The number of SHA512 iterations using PBKDF2
            </summary>
        </member>
        <member name="F:GSF.Security.Authentication.SrpUserCredential.SrpStrength">
            <summary>
            The bit strength of the SRP algorithm.
            </summary>
        </member>
        <member name="F:GSF.Security.Authentication.SrpUserCredential.VerificationInteger">
            <summary>
            <see cref="F:GSF.Security.Authentication.SrpUserCredential.Verification"/> as a <see cref="T:Org.BouncyCastle.Math.BigInteger"/>.
            </summary>
        </member>
        <member name="M:GSF.Security.Authentication.SrpUserCredential.#ctor(System.String,System.Byte[],System.Byte[],System.Int32,GSF.Security.Authentication.SrpStrength)">
            <summary>
            Creates user credentials
            </summary>
            <param name="username"></param>
            <param name="salt"></param>
            <param name="verification"></param>
            <param name="iterations"></param>
            <param name="srpStrength"></param>
        </member>
        <member name="M:GSF.Security.Authentication.SrpUserCredential.#ctor(System.String,System.String,GSF.Security.Authentication.SrpStrength,System.Int32,System.Int32)">
            <summary>
            Creates a user credential from the provided data.
            </summary>
            <param name="username"></param>
            <param name="password"></param>
            <param name="strength"></param>
            <param name="saltSize"></param>
            <param name="iterations"></param>
            <returns></returns>
        </member>
        <member name="T:GSF.Security.Authentication.ScramServerSession">
            <summary>
            Provides simple password based authentication that uses Secure Remote Password.
            </summary>
        </member>
        <member name="T:GSF.Security.Authentication.ScramClient">
            <summary>
            Provides simple password based authentication that uses Secure Remote Password.
            </summary>
        </member>
        <member name="M:GSF.Security.Authentication.ScramClient.#ctor(System.String,System.String)">
            <summary>
            Creates a new set of client credentials.
            </summary>
            <param name="username"></param>
            <param name="password"></param>
        </member>
        <member name="M:GSF.Security.Authentication.ScramClient.SetServerValues(GSF.Security.HashMethod,System.Byte[],System.Int32)">
            <summary>
            Sets the server parameters and regenerates the salted password if 
            the salt values have changed.
            </summary>
            <param name="hashMethod">the hashing method</param>
            <param name="salt">the salt for the user credentials.</param>
            <param name="iterations">the number of iterations.</param>
        </member>
        <member name="T:GSF.Security.Authentication.ScramServer">
            <summary>
            Provides simple password based authentication that uses Secure Remote Password.
            </summary>
        </member>
        <member name="F:GSF.Security.Authentication.ScramServer.Users">
            <summary>
            Contains the user credentials database
            </summary>
        </member>
        <member name="M:GSF.Security.Authentication.ScramServer.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:GSF.Security.Authentication.ScramServer.AuthenticateAsServer(System.IO.Stream,System.Byte[])">
            <summary>
            Requests that the provided stream be authenticated 
            </summary>
            <param name="stream"></param>
            <param name="additionalChallenge">Additional data to include in the challenge. If using SSL certificates, 
            adding the thumbprint to the challenge will allow detecting man in the middle attacks.</param>
            <returns></returns>
        </member>
        <member name="T:GSF.Security.Authentication.ScramUserCredentials">
            <summary>
            Provides simple password based authentication that uses SCRAM.
            </summary>
            <remarks>
            It is safe to store the user's credential on the server. This is a zero knowledge 
            password proof, meaning if this database is compromised, a brute force attack
            is the only way to reveal the password.
            </remarks>
        </member>
        <member name="T:GSF.Security.Authentication.SrpServerSession">
            <summary>
            Provides simple password based authentication that uses Secure Remote Password.
            </summary>
        </member>
        <member name="F:GSF.Security.Authentication.SrpServerSession.SessionSecret">
            <summary>
            The session secret that is used to generate keys.
            </summary>
        </member>
        <member name="M:GSF.Security.Authentication.SrpServerSession.#ctor(GSF.Security.Authentication.SrpUserCredential)">
            <summary>
            Creates a new <see cref="T:GSF.Security.Authentication.SrpServerSession"/> that will authenticate a stream.
            </summary>
            <param name="user">The user that will be authenticated.</param>
        </member>
        <member name="M:GSF.Security.Authentication.SrpServerSession.TryAuthenticate(System.IO.Stream,System.Byte[])">
            <summary>
            Attempts to authenticate the provided stream.
            </summary>
            <param name="stream">the stream to authenticate</param>
            <param name="additionalChallenge">Any additional challenge bytes.</param>
            <returns>True if successful, false otherwise</returns>
        </member>
        <member name="M:GSF.Security.Authentication.SrpServerSession.TryLoadTicket(System.Byte[],GSF.Security.Authentication.SrpUserCredential,System.Byte[]@)">
            <summary>
            Attempts to load the session resume ticket.
            </summary>
            <param name="ticket">The serialized data for the key</param>
            <param name="user">The user's credentials so the proper encryption key can be used</param>
            <param name="sessionSecret">the session secret decoded if successful. null otherwise</param>
            <returns>
            True if the ticket is authentic
            </returns>
        </member>
        <member name="T:GSF.Security.Authentication.SrpServer">
            <summary>
            Provides simple password based authentication that uses Secure Remote Password.
            </summary>
        </member>
        <member name="F:GSF.Security.Authentication.SrpServer.Users">
            <summary>
            Contains the user credentials database
            </summary>
        </member>
        <member name="M:GSF.Security.Authentication.SrpServer.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:GSF.Security.Authentication.SrpServer.AuthenticateAsServer(System.IO.Stream,System.Byte[])">
            <summary>
            Requests that the provided stream be authenticated 
            </summary>
            <param name="stream"></param>
            <param name="additionalChallenge">Additional data to include in the challenge. If using SSL certificates, 
            adding the thumbprint to the challenge will allow detecting man in the middle attacks.</param>
            <returns></returns>
        </member>
        <member name="T:GSF.Security.Authentication.SrpUserCredentials">
            <summary>
            Provides simple password based authentication that uses Secure Remote Password.
            </summary>
            <remarks>
            It is safe to store the user's credential on the server. This is a zero knowledge 
            password proof, meaning if this database is compromised, a brute force attack
            is the only way to reveal the password.
            </remarks>
        </member>
        <member name="M:GSF.Security.Authentication.SrpUserCredentials.Lookup(System.String)">
            <summary>
            Looks up the username from the database.
            </summary>
            <param name="username"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Security.Authentication.SrpUserCredentials.AddUser(System.String,System.String,GSF.Security.Authentication.SrpStrength,System.Int32,System.Int32)">
            <summary>
            Adds the specified user to the credentials database.
            </summary>
            <param name="username"></param>
            <param name="password"></param>
            <param name="strength"></param>
            <param name="saltSize"></param>
            <param name="iterations"></param>
        </member>
        <member name="M:GSF.Security.Authentication.SrpUserCredentials.AddUser(System.String,System.Byte[],System.Byte[],System.Int32,GSF.Security.Authentication.SrpStrength)">
            <summary>
            Adds the specified user to the credential database.
            </summary>
            <param name="username"></param>
            <param name="verifier"></param>
            <param name="passwordSalt"></param>
            <param name="iterations"></param>
            <param name="strength"></param>
        </member>
        <member name="T:GSF.Security.Authentication.SrpConstants">
            <summary>
            Supplies the base constants of SRP (Secure Remote Passord) as supplied in RFC 5054 Appendix A.
            </summary>
            <remarks>
            This implementation of SRP uses SHA-512 as the performance difference between 
            SHA1 and SHA-512 is negligable.
            </remarks>
        </member>
        <member name="F:GSF.Security.Authentication.SrpConstants.kb2">
            <summary>
            H(N) xor H(g)
            </summary>
        </member>
        <member name="F:GSF.Security.Authentication.SrpConstants.s_groupParameters">
            <summary>
            Contains the standard N, g, k parameters depending on the bit size
            as specified in RFC 5054 Appendix A.
            </summary>
        </member>
        <member name="M:GSF.Security.Authentication.SrpConstants.Lookup(GSF.Security.Authentication.SrpStrength)">
            <summary>
            Looks up the valid precomputed constants for SRP given the specified bit strength.
            </summary>
            <param name="strength">the bit strength to lookup.</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Security.Authentication.SrpConstants.Xor(System.Byte[],System.Byte[])">
            <summary>
            Computes the XOR of the supplied parameters
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Security.Authentication.SrpConstants.ComputeHash(System.Byte[][])">
            <summary>
            Computes the hash of all of the supplied parameters.
            </summary>
            <param name="words"></param>
            <returns></returns>
        </member>
        <member name="T:GSF.Security.Authentication.SrpClient">
            <summary>
            Provides simple password based authentication that uses Secure Remote Password.
            </summary>
        </member>
        <member name="F:GSF.Security.Authentication.SrpClient.m_sessionSecret">
            <summary>
            Session Resume Details
            </summary>
        </member>
        <member name="M:GSF.Security.Authentication.SrpClient.#ctor(System.String,System.String)">
            <summary>
            Creates a client that will authenticate with the specified 
            username and password.
            </summary>
            <param name="username">the username</param>
            <param name="password">the password</param>
        </member>
        <member name="T:GSF.Security.Authentication.SrpStrength">
            <summary>
            Specifies the bit strength of the SRP algorithm.
            </summary>
        </member>
        <member name="F:GSF.Security.Authentication.SrpStrength.Bits1024">
            <summary>
            Bit strength takes 1x (approximately 20ms on a 3.4Ghz PC) to secure the channel.
            </summary>
        </member>
        <member name="F:GSF.Security.Authentication.SrpStrength.Bits1536">
            <summary>
            Bit strength takes 3x to secure channel.
            </summary>
        </member>
        <member name="F:GSF.Security.Authentication.SrpStrength.Bits2048">
            <summary>
            Bit strength takes 6.5x to secure channel.
            </summary>
        </member>
        <member name="F:GSF.Security.Authentication.SrpStrength.Bits3072">
            <summary>
            Bit strength takes 21x to secure channel.
            </summary>
        </member>
        <member name="F:GSF.Security.Authentication.SrpStrength.Bits4096">
            <summary>
            Bit strength takes 47x to secure channel.
            </summary>
        </member>
        <member name="F:GSF.Security.Authentication.SrpStrength.Bits6144">
            <summary>
            Bit strength takes 154x to secure channel.
            </summary>
        </member>
        <member name="F:GSF.Security.Authentication.SrpStrength.Bits8192">
            <summary>
            Bit strength takes 366x to secure channel.
            </summary>
        </member>
        <member name="T:GSF.Security.SecureStreamClientDefault">
            <summary>
            Creates a secure stream that connects via the default credential
            </summary>
        </member>
        <member name="M:GSF.Security.SecureStreamClientDefault.#ctor">
            <summary>
            Creates a new <see cref="T:GSF.Security.SecureStreamClientIntegratedSecurity"/>
            </summary>
        </member>
        <member name="M:GSF.Security.SecureStreamClientDefault.InternalTryAuthenticate(System.IO.Stream,System.Byte[])">
            <summary>
            Authenticates with the remote server.
            </summary>
            <param name="stream">the stream to authentication on</param>
            <param name="certSignatures"></param>
            <returns></returns>
        </member>
        <member name="T:GSF.Security.SecureStreamClientIntegratedSecurity">
            <summary>
            Creates a secure stream that connects to a server using windows Integrated Security.
            </summary>
        </member>
        <member name="M:GSF.Security.SecureStreamClientIntegratedSecurity.#ctor">
            <summary>
            Creates a new <see cref="T:GSF.Security.SecureStreamClientIntegratedSecurity"/>
            </summary>
        </member>
        <member name="M:GSF.Security.SecureStreamClientIntegratedSecurity.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new <see cref="T:GSF.Security.SecureStreamClientIntegratedSecurity"/>
            </summary>
        </member>
        <member name="M:GSF.Security.SecureStreamClientIntegratedSecurity.InternalTryAuthenticate(System.IO.Stream,System.Byte[])">
            <summary>
            Authenticates with the remote server.
            </summary>
            <param name="stream">the stream to authentication on</param>
            <param name="certSignatures"></param>
            <returns></returns>
        </member>
        <member name="T:GSF.Security.GenerateCertificate">
            <summary>
            Generates <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2"/>s.
            </summary>
        </member>
        <member name="M:GSF.Security.GenerateCertificate.OpenCertificate(System.String,System.String)">
            <summary>
            Opens a certificate, loading the private key of the PFX file.
            </summary>
            <param name="fileName"></param>
            <param name="password"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Security.GenerateCertificate.CreateSelfSignedCertificate(System.String,System.DateTime,System.DateTime,System.Int32,System.Int32,System.String,System.String)">
            <summary>
            Creates new certificate
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.Security.GenerateCertificate.CreateSelfSignedCertificate(System.String,System.Int32,System.Int32)">
            <summary>
            Creates a self signed certificate that can be used in SSL communications
            </summary>
            <param name="subjectDirName">A valid DirName formated string. Example: CN=ServerName</param>
            <param name="signatureBits">Bitstrength of signature algorithm. Supported Lengths are 160,256, and 384 </param>
            <param name="keyStrength">RSA key strength. Typically a multiple of 1024.</param>
            <returns></returns>
        </member>
        <member name="T:GSF.Security.ReadonlyByteArray">
            <summary>
            Provides a way for byte arrays to be added to sorted lists and dictionaries.
            </summary>
        </member>
        <member name="T:GSF.Security.SecureStreamClientBase">
            <summary>
            Creates a secure stream that connects to a server.
            </summary>
        </member>
        <member name="M:GSF.Security.SecureStreamClientBase.TryAuthenticate(System.IO.Stream,System.Boolean,System.IO.Stream@)">
            <summary>
            Attempts to authenticate the supplied stream. 
            </summary>
            <param name="stream">The stream to authenticate</param>
            <param name="useSsl"></param>
            <param name="secureStream">the secure stream if the authentication was successful.</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:GSF.Security.SecureStreamClientBase.TryAuthenticate(System.IO.Stream,System.Boolean)">
            <summary>
            Attempts to authenticate the provided stream, disposing the secure stream upon completion.
            </summary>
            <param name="stream">the stream to authenticate</param>
            <param name="useSsl">gets if SSL will be used to authenticate</param>
            <returns>true if successful, false otherwise</returns>
        </member>
        <member name="M:GSF.Security.SecureStreamClientBase.Authenticate(System.IO.Stream,System.Boolean)">
            <summary>
            Authenticates the supplied stream. Returns the secure stream.
            </summary>
            <param name="stream">the stream to authenticate</param>
            <param name="useSsl">gets if SSL will be used to authenticate</param>
            <returns></returns>
        </member>
        <member name="T:GSF.Security.SecureStreamServerCertificate">
            <summary>
            Since SecureStreamServer is a generic type,
            we will store the static key here instead.
            </summary>
        </member>
        <member name="F:GSF.Security.SecureStreamServerCertificate.TempCertificate">
            <summary>
            A RSA-1024 SHA-256 certificate. It takes about 250ms to generate this certificate.
            </summary>
        </member>
        <member name="T:GSF.Security.SecureStreamServer`1">
            <summary>
            A server host that manages a secure stream connection.
            This class is thread safe and can negotiate streams simultaneous.
            </summary>
        </member>
        <member name="F:GSF.Security.SecureStreamServer`1.TicketExpireTimeMinutes">
            <summary>
            Tickets expire every 10 minutes.
            </summary>
        </member>
        <member name="M:GSF.Security.SecureStreamServer`1.#ctor">
            <summary>
            Creates a new <see cref="T:GSF.Security.SecureStreamServer`1"/>.
            </summary>
        </member>
        <member name="M:GSF.Security.SecureStreamServer`1.InvalidateAllTickets">
            <summary>
            This will change the encryption keys used to create resume tickets, thus
            invalidating all existing tickets.
            </summary>
        </member>
        <member name="M:GSF.Security.SecureStreamServer`1.SetDefaultUser(System.Boolean,`0)">
            <summary>
            Adds the default user credential if the user logs in with no credentials specified.
            </summary>
            <param name="enabled"></param>
            <param name="userToken"></param>
        </member>
        <member name="M:GSF.Security.SecureStreamServer`1.AddUserIntegratedSecurity(System.String,`0)">
            <summary>
            Adds the specified user 
            </summary>
            <param name="username">the username to add</param>
            <param name="userToken">The token data associated with this user</param>
        </member>
        <member name="M:GSF.Security.SecureStreamServer`1.TryAuthenticateAsServer(System.IO.Stream,System.Boolean,System.IO.Stream@,`0@)">
            <summary>
            Attempts to authenticate the stream
            </summary>
            <param name="stream">the base stream to authenticate</param>
            <param name="useSsl">gets if ssl should be used</param>
            <param name="secureStream">the secure stream that is valid if the function returns true.</param>
            <param name="token">the user's token associated with what user created the stream</param>
            <returns>true if successful, false otherwise</returns>
        </member>
        <member name="T:GSF.Security.IDigestExtensions">
            <summary>
            Helper extensions for <see cref="T:Org.BouncyCastle.Crypto.IDigest"/> types.
            </summary>
        </member>
        <member name="M:GSF.Security.IDigestExtensions.ComputeHash(Org.BouncyCastle.Crypto.IDigest,System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Computes the hash of the supplied words.
            </summary>
            <param name="hash"></param>
            <param name="word1"></param>
            <param name="word2"></param>
            <param name="word3"></param>
            <param name="word4"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Security.IDigestExtensions.ComputeHash(Org.BouncyCastle.Crypto.IDigest,System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Computes the hash of the supplied words.
            </summary>
            <param name="hash"></param>
            <param name="word1"></param>
            <param name="word2"></param>
            <param name="word3"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Security.IDigestExtensions.ComputeHash(Org.BouncyCastle.Crypto.IDigest,System.Byte[],System.Byte[])">
            <summary>
            Computes the hash of the supplied words.
            </summary>
            <param name="hash"></param>
            <param name="word1"></param>
            <param name="word2"></param>
            <returns></returns>
        </member>
        <member name="T:GSF.Security.PBDKFCredentials">
            <summary>
            Computes the password credentials. 
            Optimized so duplicate calls will not recompute the password unless necessary.
            </summary>
        </member>
        <member name="F:GSF.Security.PBDKFCredentials.UsernameBytes">
            <summary>
            The UTF8 encoded normalized username.
            </summary>
        </member>
        <member name="F:GSF.Security.PBDKFCredentials.SaltedPassword">
            <summary>
            The password value 
            </summary>
        </member>
        <member name="M:GSF.Security.PBDKFCredentials.TryUpdate(GSF.Security.HashMethod,System.Byte[],System.Int32)">
            <summary>
            Updates the <see cref="F:GSF.Security.PBDKFCredentials.SaltedPassword"/>. Returns False if the password value did not change.
            </summary>
            <param name="hashMethod"></param>
            <param name="salt"></param>
            <param name="iterations"></param>
            <returns>Returns False if the password value did not change.</returns>
        </member>
        <member name="M:GSF.Security.SecurityExtensions.SecureEquals(System.Byte[],System.Byte[])">
            <summary>
            Does a time constant comparison of the two byte arrays. 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>true if both arrays are equal</returns>
            <remarks>
            If a or b is null, function returns immediately with a false.
            
            Certain cryptographic attacks can occur by comparing the amount of time it
            takes to do certain operations. Comparing two byte arrays is one example.
            Therefore this method should take constant time to do a comparison of two arrays.
            </remarks>
        </member>
        <member name="M:GSF.Security.SecurityExtensions.SecureEquals(System.Byte[],System.Byte[],System.Int32,System.Int32)">
            <summary>
            Does a time constant comparison of the two byte arrays. 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="bPosition">the start position of <see cref="!:b"/></param>
            <param name="bLength">the length of <see cref="!:b"/> to read past <see cref="!:bPosition"/></param>
            <returns>true if both arrays are equal</returns>
            <remarks>
            If a or b is null, function returns immediately with a false.
            
            Certain cryptographic attacks can occur by comparing the amount of time it
            takes to do certain operations. Comparing two byte arrays is one example.
            Therefore this method should take constant time to do a comparison of two arrays.
            </remarks>
        </member>
        <member name="M:GSF.Security.SecurityExtensions.SecureEquals(System.Guid,System.Guid)">
            <summary>
            Does a time constant comparison of the two Guids. 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>true if both Guids are equal</returns>
            <remarks>
            Certain cryptographic attacks can occur by comparing the amount of time it
            takes to do certain operations. Comparing two byte arrays is one example.
            Therefore this method should take constant time to do a comparison of two Guids.
            </remarks>
        </member>
        <member name="T:GSF.Security.HashMethod">
            <summary>
            The hash/hmac method that will be used for authentication protocols.
            </summary>
        </member>
        <member name="F:GSF.Security.HashMethod.Sha1">
            <summary>
            Uses Hash and HMAC Sha1
            </summary>
        </member>
        <member name="F:GSF.Security.HashMethod.Sha256">
            <summary>
            Uses Hash and HMAC Sha2-256
            </summary>
        </member>
        <member name="F:GSF.Security.HashMethod.Sha384">
            <summary>
            Uses Hash and HMAC Sha2-384
            </summary>
        </member>
        <member name="F:GSF.Security.HashMethod.Sha512">
            <summary>
            Uses Hash and HMAC Sha2-512
            </summary>
        </member>
        <member name="T:GSF.Security.NonceGenerator">
            <summary>
            Used to generate Nonce values. 
            </summary>
        </member>
        <member name="F:GSF.Security.NonceGenerator.m_nonceNumber">
            <summary>
            A sequence number to ensure that duplicates are never created
            </summary>
        </member>
        <member name="F:GSF.Security.NonceGenerator.m_startingNonce">
            <summary>
            The secure random number that serves as the basis for this nonce
            </summary>
        </member>
        <member name="M:GSF.Security.NonceGenerator.#ctor(System.Int32)">
            <summary>
            Creates a nonce generator of the specified length.
            </summary>
            <param name="length">the size of each nonce. Must be at least 16 bytes.</param>
        </member>
        <member name="M:GSF.Security.NonceGenerator.Next">
            <summary>
            Gets the next nonce value.
            </summary>
            <returns></returns>
        </member>
        <member name="T:GSF.Security.SaltGenerator">
            <summary>
            Generates salt values.
            </summary>
        </member>
        <member name="M:GSF.Security.SaltGenerator.Create(System.Int32)">
            <summary>
            Creates a salt of the specified length.
            </summary>
            <param name="length">the number of bytes to make the salt.</param>
            <returns>
            Returns a salt of the supplied length.
            </returns>
        </member>
        <member name="T:GSF.Security.HMACMethod">
            <summary>
            A series of HMAC implementations supported by .NET
            </summary>
        </member>
        <member name="T:GSF.Security.PBKDF2">
            <summary>
            Implements a generic PBKDF2 <see cref="T:System.Security.Cryptography.DeriveBytes"/> that will work from a custom cryptographic transform.
            <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes"/> only implements a SHA-1 underlying hash function.
            </summary>
            <remarks>
            It is recommended to use one of the HMAC-SHA implementations unless you understand the implecations
            of using something differently.
            </remarks>
        </member>
        <member name="F:GSF.Security.PBKDF2.m_saltWithBlock">
            <summary>
            Contains the salt, along with an extra 4 bytes at the end to place the block number
            </summary>
        </member>
        <member name="F:GSF.Security.PBKDF2.m_blockNumber">
            <summary>
            The block number, which starts at 1, and increases every time that a new block must be computed.
            </summary>
        </member>
        <member name="F:GSF.Security.PBKDF2.m_results">
            <summary>
            A temporary location to store the hashed bytes.
            </summary>
        </member>
        <member name="M:GSF.Security.PBKDF2.#ctor(GSF.Security.HMACMethod,System.Byte[],System.Byte[],System.Int32)">
            <summary>
            Implements a <see cref="T:GSF.Security.PBKDF2"/> algorthim with a user definded MAC method.
            </summary>
            <param name="method">the HMAC method to use.</param>
            <param name="password">the password to use</param>
            <param name="salt">the salt. recommended to be at least 64-bit</param>
            <param name="iterations">the number of iterations. Recommended to be at least 1000</param>
        </member>
        <member name="M:GSF.Security.PBKDF2.Reset">
            <summary>
            When overridden in a derived class, resets the state of the operation.
            </summary>
        </member>
        <member name="M:GSF.Security.PBKDF2.GetBytes(System.Int32)">
            <summary>
            When overridden in a derived class, returns pseudo-random key bytes.
            </summary>
            <returns>
            A byte array filled with pseudo-random key bytes.
            </returns>
            <param name="cb">The number of pseudo-random key bytes to generate. </param>
        </member>
        <member name="M:GSF.Security.PBKDF2.Dispose(System.Boolean)">
            <summary>
            When overridden in a derived class, releases the unmanaged resources used by the <see cref="T:System.Security.Cryptography.DeriveBytes"/> class and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="M:GSF.Security.PBKDF2.ComputeNextBlock">
            <summary>
            Computes the next block of crypto bytes.
            </summary>
        </member>
        <member name="M:GSF.Security.PBKDF2.ComputeSaltedPassword(GSF.Security.HMACMethod,System.Byte[],System.Byte[],System.Int32,System.Int32)">
            <summary>
            Implements a <see cref="T:GSF.Security.PBKDF2"/> algorthim with a user definded MAC method.
            </summary>
            <param name="method">the HMAC method to use.</param>
            <param name="password">the password to use</param>
            <param name="salt">the salt. Must be at least 64-bit</param>
            <param name="iterations">the number of iterations. Must be at least 1000</param>
            <param name="length">the number of bytes to return</param>
            <returns>
            A salted password based on the specified length.
            </returns>
        </member>
        <member name="T:GSF.Snap.UnionTreeStream`2">
            <summary>
            Does a union of <see cref="T:GSF.Snap.TreeStream`2"/>.
            Ensures that the data is read sequentially and duplicates are removed.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="T:GSF.Snap.UnionTreeStream`2.BufferedTreeStream">
            <summary>
            A wrapper around a <see cref="T:GSF.Snap.TreeStream`2"/> that primarily supports peaking
            a value from a stream.
            </summary>
        </member>
        <member name="M:GSF.Snap.UnionTreeStream`2.BufferedTreeStream.#ctor(GSF.Snap.TreeStream{`0,`1})">
            <summary>
            Creates the table reader.
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:GSF.Snap.UnionTreeStream`2.BufferedTreeStream.EnsureCache">
            <summary>
            Makes sure that the cache value is valid.
            </summary>
        </member>
        <member name="M:GSF.Snap.UnionTreeStream`2.BufferedTreeStream.ReadToCache">
            <summary>
            Reads the next value of the stream.
            </summary>
        </member>
        <member name="M:GSF.Snap.UnionTreeStream`2.BufferedTreeStream.Read(`0,`1)">
            <summary>
            Reads the next available value.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.UnionTreeStream`2.BufferedTreeStream.WriteToCache(`0,`1)">
            <summary>
            Writes this value back to the point buffer.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="T:GSF.Snap.UnionTreeStream`2.UnionTreeStreamSortHelper">
            <summary>
            Provides basic sorting methods that assist in UnionKeyValueStream's speed.
            </summary>
        </member>
        <member name="F:GSF.Snap.UnionTreeStream`2.UnionTreeStreamSortHelper.Items">
            <summary>
            All of the items in this list.
            </summary>
        </member>
        <member name="M:GSF.Snap.UnionTreeStream`2.UnionTreeStreamSortHelper.#ctor(System.Collections.Generic.IEnumerable{GSF.Snap.UnionTreeStream{`0,`1}.BufferedTreeStream})">
            <summary>
            Creates a new custom sort helper and presorts the list.
            </summary>
            <param name="items"></param>
        </member>
        <member name="P:GSF.Snap.UnionTreeStream`2.UnionTreeStreamSortHelper.Item(System.Int32)">
            <summary>
            Indexer to get the specified item out of the list
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.UnionTreeStream`2.UnionTreeStreamSortHelper.Sort">
            <summary>
            Resorts the entire list. Uses an insertion sort routine
            </summary>
        </member>
        <member name="M:GSF.Snap.UnionTreeStream`2.UnionTreeStreamSortHelper.SortAssumingIncreased(System.Int32)">
            <summary>
            Resorts only the item at the specified index assuming:
            1) all other items are properly sorted
            2) this items's value increased.
            </summary>
            <param name="index">the index of the item to resort.</param>
        </member>
        <member name="M:GSF.Snap.UnionTreeStream`2.#ctor(System.Collections.Generic.IEnumerable{GSF.Snap.TreeStream{`0,`1}},System.Boolean)">
            <summary>
            Creates a union stream reader from the supplied data.
            </summary>
            <param name="streams">all of the tables to combine in the union</param>
            <param name="ownsStream">if this class owns the streams, it will call dispose when <see cref="M:GSF.Snap.UnionTreeStream`2.Dispose(System.Boolean)"/> is called.
            Otherwise, the streams will not be disposed.</param>
        </member>
        <member name="M:GSF.Snap.UnionTreeStream`2.CompareStreams(GSF.Snap.UnionTreeStream{`0,`1}.BufferedTreeStream,GSF.Snap.UnionTreeStream{`0,`1}.BufferedTreeStream)">
            <summary>
            Compares two Archive Streams together for proper sorting.
            </summary>
            <param name="item1"></param>
            <param name="item2"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.UnionTreeStream`2.RemoveDuplicatesIfExists">
            <summary>
            Checks the first 2 Archive Streams for a duplicate entry. If one exists, then removes the duplicate and resorts the list.
            </summary>
        </member>
        <member name="M:GSF.Snap.UnionTreeStream`2.RemoveDuplicatesFromList">
            <summary>
            Call this function when the same point exists in multiple archive files. It will
            read past the duplicate point in all other archive files and then resort the tables.
            
            Assums that the archiveStream's cached value is current.
            </summary>
        </member>
        <member name="M:GSF.Snap.UnionTreeStream`2.SetReadWhileUpperBoundsValue">
            <summary>
            Sets the read while upper bounds value. 
            Which is the lesser of 
            The first point in the adjacent table or
            The end of the current seek window.
             </summary>
        </member>
        <member name="T:GSF.Snap.Filters.TimestampPointIDSeekFilterDefinition">
            <summary>
            Represents a seek filter definition for the <see cref="T:GSF.Snap.Filters.TimestampPointIDSeekFilter"/> methods.
            </summary>
        </member>
        <member name="F:GSF.Snap.Filters.TimestampPointIDSeekFilterDefinition.FilterGuid">
            <summary>
            Guid for the <see cref="T:GSF.Snap.Filters.TimestampPointIDSeekFilterDefinition"/>.
            </summary>
        </member>
        <member name="P:GSF.Snap.Filters.TimestampPointIDSeekFilterDefinition.FilterType">
            <summary>
            Gets the filter type Guid for the <see cref="T:GSF.Snap.Filters.TimestampPointIDSeekFilterDefinition"/>.
            </summary>
        </member>
        <member name="M:GSF.Snap.Filters.TimestampPointIDSeekFilterDefinition.Create``1(GSF.IO.BinaryStreamBase)">
            <summary>
            Creates a new seek filter for the <see cref="T:GSF.Snap.Filters.TimestampPointIDSeekFilterDefinition"/>.
            </summary>
            <typeparam name="TKey">Type of key/</typeparam>
            <param name="stream">Binary stream to create seek filter from.</param>
            <returns>New seek filter based on information in binary stream.</returns>
        </member>
        <member name="T:GSF.Snap.Filters.TimestampPointIDSeekFilter">
            <summary>
            Represents a seek filter for a specific timestamp and point ID.
            </summary>
        </member>
        <member name="M:GSF.Snap.Filters.TimestampPointIDSeekFilter.FindKey``1(System.UInt64,System.UInt64)">
            <summary>
            Creates a filter for the specified timestamp and point ID.
            </summary>
            <param name="timestamp">The specific timestamp to find.</param>
            <param name="pointID">The specific point ID to find.</param>
            <returns>Seek filter to find specific key.</returns>
        </member>
        <member name="M:GSF.Snap.Filters.TimestampPointIDSeekFilter.CreateFromStream``1(GSF.IO.BinaryStreamBase)">
            <summary>
            Loads a <see cref="T:GSF.Snap.Filters.SeekFilterBase`1"/> from the provided <see cref="!:stream"/>.
            </summary>
            <param name="stream">The stream to load the filter from</param>
            <returns>Seek filter to find specific key.</returns>
        </member>
        <member name="M:GSF.Snap.Filters.TimestampPointIDSeekFilter.SeekToKey`1.#ctor(GSF.IO.BinaryStreamBase)">
            <summary>
            Creates a filter by reading from the stream.
            </summary>
            <param name="stream">the stream to read from</param>
        </member>
        <member name="M:GSF.Snap.Filters.TimestampPointIDSeekFilter.SeekToKey`1.#ctor(System.UInt64,System.UInt64)">
            <summary>
            Creates a filter for the key.
            </summary>
            <param name="timestamp">The specific timestamp to find.</param>
            <param name="pointID">The specific point ID to find.</param>
        </member>
        <member name="M:GSF.Snap.Filters.TimestampPointIDSeekFilter.SeekToKey`1.NextWindow">
            <summary>
            Gets the next search window.
            </summary>
            <returns>true if window exists, false if finished.</returns>
        </member>
        <member name="M:GSF.Snap.Filters.TimestampPointIDSeekFilter.SeekToKey`1.Reset">
            <summary>
            Resets the iterative nature of the filter. 
            </summary>
        </member>
        <member name="M:GSF.Snap.Filters.TimestampPointIDSeekFilter.SeekToKey`1.Save(GSF.IO.BinaryStreamBase)">
            <summary>
            Serializes the filter to a stream
            </summary>
            <param name="stream">the stream to write to</param>
        </member>
        <member name="T:GSF.Snap.Filters.FilterLibrary">
            <summary>
            Contains all of the filters for the <see cref="N:GSF.Snap"/>. 
            </summary>
        </member>
        <member name="M:GSF.Snap.Filters.FilterLibrary.Register(GSF.Snap.Definitions.MatchFilterDefinitionBase)">
            <summary>
            Registers this type
            </summary>
            <param name="encoding"></param>
        </member>
        <member name="M:GSF.Snap.Filters.FilterLibrary.Register(GSF.Snap.Definitions.SeekFilterDefinitionBase)">
            <summary>
            Registers this type
            </summary>
            <param name="encoding"></param>
        </member>
        <member name="T:GSF.Snap.Filters.MatchFilterBase`2">
            <summary>
            Represents some kind of filter that does a match based on the key/value.
            </summary>
            <typeparam name="TKey">the key to match</typeparam>
            <typeparam name="TValue">the value to match</typeparam>
        </member>
        <member name="P:GSF.Snap.Filters.MatchFilterBase`2.FilterType">
            <summary>
            The filter guid 
            </summary>
        </member>
        <member name="M:GSF.Snap.Filters.MatchFilterBase`2.Save(GSF.IO.BinaryStreamBase)">
            <summary>
            Serializes the filter to a stream
            </summary>
            <param name="stream">the stream to write to</param>
        </member>
        <member name="M:GSF.Snap.Filters.MatchFilterBase`2.Contains(`0,`1)">
            <summary>
            Determines if a Key/Value is contained in the filter
            </summary>
            <param name="key">the key to check</param>
            <param name="value">the value to check</param>
            <returns></returns>
        </member>
        <member name="T:GSF.Snap.Filters.MatchFilterUniverse`2">
            <summary>
            Represents no filter
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="T:GSF.Snap.Filters.SeekFilterUniverse`1">
            <summary>
            Represents no filter
            </summary>
            <typeparam name="TKey"></typeparam>
        </member>
        <member name="T:GSF.Snap.Filters.SeekFilterBase`1">
            <summary>
            Represents a filter that is based on a series of ranges of the key value
            </summary>
            <typeparam name="TKey"></typeparam>
        </member>
        <member name="P:GSF.Snap.Filters.SeekFilterBase`1.FilterType">
            <summary>
            The filter guid 
            </summary>
        </member>
        <member name="P:GSF.Snap.Filters.SeekFilterBase`1.StartOfFrame">
            <summary>
            the start of the frame to search [Inclusive]
            </summary>
        </member>
        <member name="P:GSF.Snap.Filters.SeekFilterBase`1.EndOfFrame">
            <summary>
            the end of the frame to search [Inclusive]
            </summary>
        </member>
        <member name="P:GSF.Snap.Filters.SeekFilterBase`1.StartOfRange">
            <summary>
            the start of the entire range to search [Inclusive]
            </summary>
        </member>
        <member name="P:GSF.Snap.Filters.SeekFilterBase`1.EndOfRange">
            <summary>
            the end of the entire range to search [Inclusive]
            </summary>
        </member>
        <member name="M:GSF.Snap.Filters.SeekFilterBase`1.Save(GSF.IO.BinaryStreamBase)">
            <summary>
            Serializes the filter to a stream
            </summary>
            <param name="stream">the stream to write to</param>
        </member>
        <member name="M:GSF.Snap.Filters.SeekFilterBase`1.Reset">
            <summary>
            Resets the iterative nature of the filter. 
            </summary>
            <remarks>
            Since a time filter is a set of date ranges, this will reset the frame so a
            call to <see cref="M:GSF.Snap.Filters.SeekFilterBase`1.NextWindow"/> will return the first window of the sequence.
            </remarks>
        </member>
        <member name="M:GSF.Snap.Filters.SeekFilterBase`1.NextWindow">
            <summary>
            Gets the next search window.
            </summary>
            <returns>true if window exists, false if finished.</returns>
        </member>
        <member name="M:GSF.Snap.Filters.PointIdMatchFilter.CreateFromPointID``2(System.UInt64)">
            <summary>
            Creates a filter from the provided <paramref name="pointID"/>.
            </summary>
            <param name="pointID">Point ID to include in the filter.</param>
        </member>
        <member name="M:GSF.Snap.Filters.PointIdMatchFilter.CreateFromList``2(System.Collections.Generic.IEnumerable{System.UInt64})">
            <summary>
            Creates a filter from the list of points provided.
            </summary>
            <param name="listOfPointIDs">contains the list of pointIDs to include in the filter. List must support multiple enumerations</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Filters.PointIdMatchFilter.CreateFromStream``2(GSF.IO.BinaryStreamBase)">
            <summary>
            Loads a <see cref="!:QueryFilterPointId"/> from the provided <see cref="!:stream"/>.
            </summary>
            <param name="stream">The stream to load the filter from</param>
            <returns></returns>
        </member>
        <member name="T:GSF.Snap.Filters.PointIdMatchFilter.BitArrayFilter`2">
            <summary>
            A filter that uses a <see cref="T:GSF.Collections.BitArray"/> to set true and false values
            </summary>
        </member>
        <member name="M:GSF.Snap.Filters.PointIdMatchFilter.BitArrayFilter`2.#ctor(GSF.IO.BinaryStreamBase,System.Int32,System.UInt64)">
            <summary>
            Creates a new filter backed by a <see cref="T:GSF.Collections.BitArray"/>.
            </summary>
            <param name="stream">The the stream to load from.</param>
            <param name="pointCount">the number of points in the stream.</param>
            <param name="maxValue">the maximum value stored in the bit array. Cannot be larger than int.MaxValue-1</param>
        </member>
        <member name="M:GSF.Snap.Filters.PointIdMatchFilter.BitArrayFilter`2.#ctor(System.Collections.Generic.IEnumerable{System.UInt64},System.UInt64)">
            <summary>
            Creates a bit array filter from <see cref="!:points"/>
            </summary>
            <param name="points">the points to use.</param>
            <param name="maxValue">the maximum value stored in the bit array. Cannot be larger than int.MaxValue-1</param>
        </member>
        <member name="T:GSF.Snap.Filters.PointIdMatchFilter.UIntHashSet`2">
            <summary>
            A filter that uses a <see cref="T:GSF.Collections.BitArray"/> to set true and false values
            </summary>
        </member>
        <member name="M:GSF.Snap.Filters.PointIdMatchFilter.UIntHashSet`2.#ctor(GSF.IO.BinaryStreamBase,System.Int32,System.UInt64)">
            <summary>
            Creates a new filter backed by a <see cref="T:GSF.Collections.BitArray"/>.
            </summary>
            <param name="stream">The the stream to load from.</param>
            <param name="pointCount">the number of points in the stream.</param>
            <param name="maxValue">the maximum value stored in the bit array. Cannot be larger than int.MaxValue-1</param>
        </member>
        <member name="M:GSF.Snap.Filters.PointIdMatchFilter.UIntHashSet`2.#ctor(System.Collections.Generic.IEnumerable{System.UInt64},System.UInt64)">
            <summary>
            Creates a bit array filter from <see cref="!:points"/>
            </summary>
            <param name="points">the points to use.</param>
            <param name="maxValue">the maximum value stored in the bit array. Cannot be larger than int.MaxValue-1</param>
        </member>
        <member name="T:GSF.Snap.Filters.PointIdMatchFilter.ULongHashSet`2">
            <summary>
            A filter that uses a <see cref="T:GSF.Collections.BitArray"/> to set true and false values
            </summary>
        </member>
        <member name="M:GSF.Snap.Filters.PointIdMatchFilter.ULongHashSet`2.#ctor(GSF.IO.BinaryStreamBase,System.Int32,System.UInt64)">
            <summary>
            Creates a new filter backed by a <see cref="T:GSF.Collections.BitArray"/>.
            </summary>
            <param name="stream">The the stream to load from.</param>
            <param name="pointCount">the number of points in the stream.</param>
            <param name="maxValue">the maximum value stored in the bit array. Cannot be larger than int.MaxValue-1</param>
        </member>
        <member name="M:GSF.Snap.Filters.PointIdMatchFilter.ULongHashSet`2.#ctor(System.Collections.Generic.IEnumerable{System.UInt64},System.UInt64)">
            <summary>
            Creates a bit array filter from <see cref="!:points"/>
            </summary>
            <param name="points">the points to use.</param>
            <param name="maxValue">the maximum value stored in the bit array. Cannot be larger than int.MaxValue-1</param>
        </member>
        <member name="M:GSF.Snap.Filters.TimestampSeekFilter.CreateFromRange``1(System.DateTime,System.DateTime)">
            <summary>
            Creates a filter over a single date range. (Inclusive list)
            </summary>
            <param name="firstTime">the first time if the query (inclusive)</param>
            <param name="lastTime">the last time of the query (inclusive)</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Filters.TimestampSeekFilter.CreateFromRange``1(System.UInt64,System.UInt64)">
            <summary>
            Creates a filter over a single date range. (Inclusive list)
            </summary>
            <param name="firstTime">the first time if the query (inclusive)</param>
            <param name="lastTime">the last time of the query (inclusive)</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Filters.TimestampSeekFilter.CreateFromIntervalData``1(System.UInt64,System.UInt64,System.UInt64,System.UInt64,System.UInt64)">
            <summary>
            Creates a filter over a set of date ranges (Similar to down sampled queries)
            </summary>
            <param name="firstTime">the first time if the query (inclusive)</param>
            <param name="lastTime">the last time of the query (inclusive if contained in the intervals)</param>
            <param name="mainInterval">the smallest interval that is exact</param>
            <param name="subInterval">the interval that will be parsed. Possible to be rounded</param>
            <param name="tolerance">the width of every window</param>
            <returns>A <see cref="!:KeySeekFilterBase&lt;TKey&gt;"/> that will be able to do this parsing</returns>
            <remarks>
            Example uses. FirstTime = 1/1/2013. LastTime = 1/2/2013. 
                          MainInterval = 0.1 seconds. SubInterval = 0.0333333 seconds.
                          Tolerance = 0.001 seconds.
            </remarks>
        </member>
        <member name="M:GSF.Snap.Filters.TimestampSeekFilter.CreateFromIntervalData``1(System.UInt64,System.UInt64,System.UInt64,System.UInt64)">
            <summary>
            Creates a filter over a set of date ranges (Similar to down sampled queries)
            </summary>
            <param name="firstTime">the first time if the query (inclusive)</param>
            <param name="lastTime">the last time of the query (inclusive if contained in the intervals)</param>
            <param name="interval">the exact interval</param>
            <param name="tolerance">the width of every window</param>
            <returns>A <see cref="!:KeySeekFilterBase&lt;TKey&gt;"/> that will be able to do this parsing</returns>
            <remarks>
            Example uses. FirstTime = 1/1/2013. LastTime = 1/2/2013. 
                          MainInterval = 0.1 seconds. SubInterval = 0.0333333 seconds.
                          Tolerance = 0.001 seconds.
            </remarks>
        </member>
        <member name="M:GSF.Snap.Filters.TimestampSeekFilter.CreateFromIntervalData``1(System.DateTime,System.DateTime,System.TimeSpan,System.TimeSpan,System.TimeSpan)">
            <summary>
            Creates a filter over a single date range. (Inclusive list)
            </summary>
            <param name="firstTime">the first time if the query (inclusive)</param>
            <param name="lastTime">the last time of the query (inclusive)</param>
            <param name="mainInterval">the smallest interval that is exact</param>
            <param name="subInterval">the interval that will be parsed. Possible to be rounded</param>
            <param name="tolerance">the width of every window</param>
            <returns>A <see cref="!:KeySeekFilterBase&lt;TKey&gt;"/> that will be able to do this parsing</returns>
            <remarks>
            Example uses. FirstTime = 1/1/2013. LastTime = 1/2/2013. 
                          MainInterval = 0.1 seconds. SubInterval = 0.0333333 seconds.
                          Tolerance = 0.001 seconds.
            </remarks>
        </member>
        <member name="M:GSF.Snap.Filters.TimestampSeekFilter.CreateFromIntervalData``1(System.DateTime,System.DateTime,System.TimeSpan,System.TimeSpan)">
            <summary>
            Creates a filter over a single date range. (Inclusive list)
            </summary>
            <param name="firstTime">the first time if the query (inclusive)</param>
            <param name="lastTime">the last time of the query (inclusive)</param>
            <param name="interval">the exact interval to do the scan</param>
            <param name="tolerance">the width of every window</param>
            <returns>A <see cref="!:KeySeekFilterBase&lt;TKey&gt;"/> that will be able to do this parsing</returns>
            <remarks>
            Example uses. FirstTime = 1/1/2013. LastTime = 1/2/2013. 
                          Interval = 0.1 seconds.
                          Tolerance = 0.001 seconds.
            </remarks>
        </member>
        <member name="M:GSF.Snap.Filters.TimestampSeekFilter.CreateFromStream``1(GSF.IO.BinaryStreamBase)">
            <summary>
            Loads a <see cref="!:KeySeekFilterBase&lt;TKey&gt;"/> from the provided <see cref="!:stream"/>.
            </summary>
            <param name="stream">The stream to load the filter from</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Filters.TimestampSeekFilter.FixedRange`1.#ctor(GSF.IO.BinaryStreamBase)">
            <summary>
            Creates a filter by reading from the stream.
            </summary>
            <param name="stream">the stream to read from</param>
        </member>
        <member name="M:GSF.Snap.Filters.TimestampSeekFilter.FixedRange`1.#ctor(System.UInt64,System.UInt64)">
            <summary>
            Creates a filter from the boundary
            </summary>
            <param name="firstTime">the start of the only window.</param>
            <param name="lastTime">the stop of the only window.</param>
        </member>
        <member name="M:GSF.Snap.Filters.TimestampSeekFilter.FixedRange`1.NextWindow">
            <summary>
            Gets the next search window.
            </summary>
            <returns>true if window exists, false if finished.</returns>
        </member>
        <member name="M:GSF.Snap.Filters.TimestampSeekFilter.FixedRange`1.Reset">
            <summary>
            Resets the iterative nature of the filter. 
            </summary>
            <remarks>
            Since a time filter is a set of date ranges, this will reset the frame so a
            call to <see cref="M:GSF.Snap.Filters.TimestampSeekFilter.FixedRange`1.NextWindow"/> will return the first window of the sequence.
            </remarks>
        </member>
        <member name="M:GSF.Snap.Filters.TimestampSeekFilter.FixedRange`1.Save(GSF.IO.BinaryStreamBase)">
            <summary>
            Serializes the filter to a stream
            </summary>
            <param name="stream">the stream to write to</param>
        </member>
        <member name="M:GSF.Snap.Filters.TimestampSeekFilter.IntervalRanges`1.#ctor(GSF.IO.BinaryStreamBase)">
            <summary>
            Creates a filter by reading from the stream.
            </summary>
            <param name="stream">the stream to read from</param>
        </member>
        <member name="M:GSF.Snap.Filters.TimestampSeekFilter.IntervalRanges`1.#ctor(System.UInt64,System.UInt64,System.UInt64,System.UInt64,System.UInt64)">
            <summary>
            Creates a filter over a set of date ranges (Similiar to downsampled queries)
            </summary>
            <param name="firstTime">the first time if the query (inclusive)</param>
            <param name="lastTime">the last time of the query (inclusive if contained in the intervals)</param>
            <param name="mainInterval">the smallest interval that is exact</param>
            <param name="subInterval">the interval that will be parsed. Possible to be rounded</param>
            <param name="tolerance">the width of every window</param>
            <returns>A <see cref="!:KeySeekFilterBase&lt;TKey&gt;"/> that will be able to do this parsing</returns>
            <remarks>
            Example uses. FirstTime = 1/1/2013. LastTime = 1/2/2013. 
                          MainInterval = 0.1 seconds. SubInterval = 0.0333333 seconds.
                          Tolerance = 0.001 seconds.
            </remarks>
        </member>
        <member name="M:GSF.Snap.Filters.TimestampSeekFilter.IntervalRanges`1.NextWindow">
            <summary>
            Gets the next search window.
            </summary>
            <returns>true if window exists, false if finished.</returns>
        </member>
        <member name="M:GSF.Snap.Filters.TimestampSeekFilter.IntervalRanges`1.Reset">
            <summary>
            Resets the iterative nature of the filter. 
            </summary>
            <remarks>
            Since a time filter is a set of date ranges, this will reset the frame so a
            call to <see cref="M:GSF.Snap.Filters.TimestampSeekFilter.IntervalRanges`1.NextWindow"/> will return the first window of the sequence.
            </remarks>
        </member>
        <member name="M:GSF.Snap.Filters.TimestampSeekFilter.IntervalRanges`1.Save(GSF.IO.BinaryStreamBase)">
            <summary>
            Serializes the filter to a stream
            </summary>
            <param name="stream">the stream to write to</param>
        </member>
        <member name="T:GSF.Snap.Services.ArchiveDetails">
            <summary>
            Gets basic archive details that can be returned to the client.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.ArchiveDetails.Id">
            <summary>
            The ID for the file
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.ArchiveDetails.FileName">
            <summary>
            The name of the file
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.ArchiveDetails.IsEmpty">
            <summary>
            Gets if the file contains anything.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.ArchiveDetails.FileSize">
            <summary>
            Gets the size of the file in bytes.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.ArchiveDetails.FirstKey">
            <summary>
            Gets the first key as a string.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.ArchiveDetails.LastKey">
            <summary>
            Gets the last key as a string.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.ArchiveDetails.StartTime">
            <summary>
            Gets the start time of the archive, if applicable to Key type.
            </summary>
            <remarks>
            If Key type does not expose a TimestampAsDate property, value will be <see cref="F:System.DateTime.MinValue"/>.
            </remarks>
        </member>
        <member name="P:GSF.Snap.Services.ArchiveDetails.EndTime">
            <summary>
            Gets the end time of the archive, if applicable to Key type.
            </summary>
            <remarks>
            If Key type does not expose a TimestampAsDate property, value will be <see cref="F:System.DateTime.MaxValue"/>.
            </remarks>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveDetails.Create``2(GSF.Snap.Services.ArchiveTableSummary{``0,``1})">
            <summary>
            Creates a <see cref="T:GSF.Snap.Services.ArchiveDetails"/> from a specific <see cref="T:GSF.Snap.Services.ArchiveTableSummary`2"/>
            </summary>
        </member>
        <member name="T:GSF.Snap.Services.ArchiveDirectoryMethod">
            <summary>
            Specifies the directory structure to follow when writing archive files to the disk.
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.ArchiveDirectoryMethod.TopDirectoryOnly">
            <summary>
            Writes all files in the top directory
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.ArchiveDirectoryMethod.Year">
            <summary>
            Writes all files based on the starting year
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.ArchiveDirectoryMethod.YearMonth">
            <summary>
            Writes all files based on 'YearMonth'
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.ArchiveDirectoryMethod.YearThenMonth">
            <summary>
            Writes all files based on 'Year\Month'
            </summary>
        </member>
        <member name="T:GSF.Snap.Services.ArchiveListEditor">
            <summary>
            Provides a way to edit an <see cref="T:GSF.Snap.Services.ArchiveList"/> since all edits must be atomic.
            WARNING: Instancing this class on an <see cref="T:GSF.Snap.Services.ArchiveList"/> will lock the class
            until <see cref="M:GSF.Snap.Services.ArchiveListEditor.Dispose"/> is called. Therefore, keep locks to a minimum and always
            use a Using block.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveListEditor.RenewArchiveSnapshot(System.Guid)">
            <summary>
            Renews the snapshot of the archive file. This will acquire the latest 
            read transaction so all new snapshots will use this later version.
            </summary>
            <param name="archiveId">the ID of the archive snapshot to renew</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveListEditor.Contains(System.Guid)">
            <summary>
            Returns true if the archive list contains the provided file.
            </summary>
            <param name="archiveId">the file</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveListEditor.TryRemoveAndDispose(System.Guid)">
            <summary>
            Removes the <see cref="!:archiveId"/> from <see cref="T:GSF.Snap.Services.ArchiveList`2"/> and queues it for disposal.
            </summary>
            <param name="archiveId">the archive to remove</param>
            <returns>True if the item was removed, False otherwise.</returns>
            <remarks>
            Also unlocks the archive file.
            </remarks>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveListEditor.TryRemoveAndDelete(System.Guid)">
            <summary>
            Removes the supplied file from the <see cref="T:GSF.Snap.Services.ArchiveList`2"/> and queues it for deletion.
            </summary>
            <param name="archiveId">file to remove and delete.</param>
            <returns>true if deleted, false otherwise</returns>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveListEditor.Dispose">
            <summary>
            Releases all the resources used by the <see cref="T:GSF.Snap.Services.ArchiveListEditor"/> object.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveListEditor.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:GSF.Snap.Services.ArchiveListEditor"/> object and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="T:GSF.Snap.Services.ArchiveListSettings">
            <summary>
            Settings for <see cref="T:GSF.Snap.Services.ArchiveList`2"/>
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveListSettings.#ctor">
            <summary>
            Creates a new instance of <see cref="T:GSF.Snap.Services.ArchiveListSettings"/>
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.ArchiveListSettings.LogSettings">
            <summary>
            The log settings to use for logging deletions.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.ArchiveListSettings.ImportPaths">
            <summary>
            A set of all import paths to load upon initialization.
            Be sure to include all paths that existed last time the service
            restarted since the ArchiveListLog processes immediately upon 
            construction.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.ArchiveListSettings.ImportExtensions">
            <summary>
            A set of all file extensions that will need to be loaded from each path.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveListSettings.AddPath(System.String)">
            <summary>
            Adds the supplied path to the list.
            </summary>
            <param name="path">the path to add.</param>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveListSettings.AddPaths(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Adds the supplied paths to the list.
            </summary>
            <param name="paths">the paths to add.</param>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveListSettings.AddExtension(System.String)">
            <summary>
            Adds the supplied extension to the list.
            </summary>
            <param name="extension">the extension to add.</param>
        </member>
        <member name="T:GSF.Snap.Services.ArchiveListLogSettings">
            <summary>
            The settings for a <see cref="T:GSF.Snap.Services.ArchiveListLog"/>.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.ArchiveListLogSettings.IsFileBacked">
            <summary>
            Gets if this archive log will be file backed. 
            This is true as long as <see cref="P:GSF.Snap.Services.ArchiveListLogSettings.LogPath"/> is assigned
            a value.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.ArchiveListLogSettings.LogPath">
            <summary>
            The path to store all log files. Can be an empty string to 
            not enable file based logging.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.ArchiveListLogSettings.LogFilePrefix">
            <summary>
            The prefix to assign to all log files. Can be string.empty
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.ArchiveListLogSettings.LogFileExtension">
            <summary>
            The file extension to write the log files.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.ArchiveListLogSettings.SearchPattern">
            <summary>
            Gets the wildcard search string for a log file.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveListLogSettings.GenerateNewFileName">
            <summary>
            Generates a new file name.
            </summary>
            <returns></returns>
        </member>
        <member name="T:GSF.Snap.Services.ArchiveList">
            <summary>
            Manages the complete list of archive resources and the 
            associated reading and writing that goes along with it.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveList.#ctor">
            <summary>
            Creates a <see cref="T:GSF.Snap.Services.ArchiveList"/>
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveList.AttachFileOrPath(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Attaches the supplied paths or files.
            </summary>
            <param name="paths">the path to file names or directories to enumerate.</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveList.LoadFiles(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Loads the specified files into the archive list.
            </summary>
            <param name="archiveFiles"></param>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveList.GetFullStatus(System.Text.StringBuilder)">
            <summary>
            Appends the status of the files in the ArchiveList to the provided <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="status"></param>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveList.GetAllAttachedFiles">
            <summary>
            Gets a complete list of all archive files
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveList.AcquireEditLock">
            <summary>
            Returns an <see cref="T:System.IDisposable"/> class that can be used to edit the contents of this list.
            WARNING: Make changes quickly and dispose the returned class.  All calls to this class are blocked while
            editing this class.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveList.InternalAcquireEditLock">
            <summary>
            Necessary to provide shadow method of <see cref="M:GSF.Snap.Services.ArchiveList.AcquireEditLock"/>
            </summary>
            <returns></returns>
        </member>
        <member name="T:GSF.Snap.Services.ArchiveListEditor`2">
            <summary>
            Provides a way to edit an <see cref="T:GSF.Snap.Services.ArchiveList`2"/> since all edits must be atomic.
            WARNING: Instancing this class on an <see cref="T:GSF.Snap.Services.ArchiveList`2"/> will lock the class
            until <see cref="M:GSF.Snap.Services.ArchiveListEditor.Dispose"/> is called. Therefore, keep locks to a minimum and always
            use a Using block.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveListEditor`2.Add(GSF.Snap.Storage.SortedTreeTable{`0,`1})">
            <summary>
            Adds an archive file to the list with the given state information.
            </summary>
            <param name="sortedTree">archive table to add</param>
        </member>
        <member name="T:GSF.Snap.Services.Configuration.AdvancedServerDatabaseConfig`2">
            <summary>
            Creates a configuration for the database to utilize.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Configuration.AdvancedServerDatabaseConfig`2.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Gets a database config.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Configuration.AdvancedServerDatabaseConfig`2.DirectoryMethod">
            <summary>
            Gets the method of how the directory will be stored. Defaults to 
            top directory only.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Configuration.AdvancedServerDatabaseConfig`2.DatabaseName">
            <summary>
            The name associated with the database.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Configuration.AdvancedServerDatabaseConfig`2.TargetFileSize">
            <summary>
            The desired size of archive files
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Configuration.AdvancedServerDatabaseConfig`2.StagingCount">
            <summary>
            The number of stages.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Configuration.AdvancedServerDatabaseConfig`2.IntermediateFileExtension">
            <summary>
            The extension to use for the intermediate files
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Configuration.AdvancedServerDatabaseConfig`2.FinalFileExtension">
            <summary>
            The extension to use for the final file
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Configuration.AdvancedServerDatabaseConfig`2.ImportAttachedPathsAtStartup">
            <summary>
            Determines whether the server should import attached paths at startup.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Configuration.AdvancedServerDatabaseConfig`2.ImportPaths">
            <summary>
            Gets all of the paths that are known by this historian.
            A path can be a file name or a folder.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Configuration.AdvancedServerDatabaseConfig`2.FinalWritePaths">
            <summary>
            The list of directories where final files can be placed written. 
            If nothing is specified, the main directory is used.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Configuration.AdvancedServerDatabaseConfig`2.ArchiveEncodingMethod">
            <summary>
            Gets the default encoding methods for storing files.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Configuration.AdvancedServerDatabaseConfig`2.StreamingEncodingMethods">
            <summary>
            Gets the supported encoding methods for streaming data. This list is in a prioritized order.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Configuration.AdvancedServerDatabaseConfig`2.SupportsWriting">
            <summary>
            Gets if writing will be supported
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Configuration.AdvancedServerDatabaseConfig`2.DiskFlushInterval">
            <summary>
            The number of milliseconds before data is automatically flushed to the disk.
            </summary>
            <remarks>
            Must be between 1,000 ms and 60,000 ms.
            </remarks>
        </member>
        <member name="P:GSF.Snap.Services.Configuration.AdvancedServerDatabaseConfig`2.CacheFlushInterval">
            <summary>
            The number of milliseconds before data is taken from it's cache and put in the
            memory file.
            </summary>
            <remarks>
            Must be between 1 and 1,000
            </remarks>
        </member>
        <member name="T:GSF.Snap.Services.IToServerDatabaseSettings">
            <summary>
            Allows the creation of <see cref="T:GSF.Snap.Services.ServerDatabaseSettings"/> from a class that implements this method.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.IToServerDatabaseSettings.ToServerDatabaseSettings">
            <summary>
            Creates a <see cref="T:GSF.Snap.Services.ServerDatabaseSettings"/> configuration that can be used for <see cref="T:GSF.Snap.Services.SnapServerDatabase`2"/>
            </summary>
            <returns></returns>
        </member>
        <member name="T:GSF.Snap.Services.IToServerSettings">
            <summary>
            Allows the creation of <see cref="T:GSF.Snap.Services.ServerSettings"/> from a class that implements this method.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.IToServerSettings.ToServerSettings">
            <summary>
            Creates a <see cref="T:GSF.Snap.Services.ServerSettings"/> configuration that can be used for <see cref="T:GSF.Snap.Services.SnapServer"/>
            </summary>
            <returns></returns>
        </member>
        <member name="T:GSF.Snap.Services.Reader.ArchiveTreeStreamWrapper`2">
            <summary>
            Wraps a <see cref="T:GSF.Snap.Services.ArchiveTableSummary`2"/> within a <see cref="T:GSF.Snap.TreeStream`2"/>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:GSF.Snap.Services.Reader.ArchiveTreeStreamWrapper`2.#ctor(GSF.Snap.Storage.SortedTreeTable{`0,`1})">
            <summary>
            Creates a <see cref="T:GSF.Snap.Services.Reader.ArchiveTreeStreamWrapper`2"/>
            </summary>
            <param name="table">The table to wrap.</param>
        </member>
        <member name="M:GSF.Snap.Services.Reader.ArchiveTreeStreamWrapper`2.#ctor(GSF.Snap.Services.ArchiveTableSummary{`0,`1})">
            <summary>
            Creates a <see cref="T:GSF.Snap.Services.Reader.ArchiveTreeStreamWrapper`2"/>
            </summary>
            <param name="table">The table to wrap.</param>
        </member>
        <member name="M:GSF.Snap.Services.Reader.ArchiveTreeStreamWrapper`2.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:GSF.Snap.Services.Reader.ArchiveTreeStreamWrapper`2"/> object and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="P:GSF.Snap.Services.Reader.BufferedArchiveStream`2.Index">
            <summary>
            An index value that is used to disassociate the archive file. Passed to this class from the <see cref="!:SortedTreeEngineReaderSequential&lt;TKey,TValue&gt;"/>
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Reader.BufferedArchiveStream`2.#ctor(System.Int32,GSF.Snap.Services.ArchiveTableSummary{`0,`1})">
            <summary>
            Creates the table reader.
            </summary>
            <param name="index"></param>
            <param name="table"></param>
        </member>
        <member name="M:GSF.Snap.Services.Reader.UnionReader`2.VerifyArchiveStreamSortingOrder">
            <summary>
            Will verify that the stream is in the proper order and remove any duplicates that were found. 
            May be called after every single read, but better to be called
            when a ReadWhile function returns false.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Reader.UnionReader`2.CompareStreams(GSF.Snap.Services.Reader.BufferedArchiveStream{`0,`1},GSF.Snap.Services.Reader.BufferedArchiveStream{`0,`1})">
            <summary>
            Compares two Archive Streams together for proper sorting.
            </summary>
            <param name="item1"></param>
            <param name="item2"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Services.Reader.UnionReader`2.SeekToKey(`0)">
            <summary>
            Does an unconditional seek operation to the provided key.
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:GSF.Snap.Services.Reader.UnionReader`2.RemoveDuplicatesIfExists">
            <summary>
            Checks the first 2 Archive Streams for a duplicate entry. If one exists, then removes the duplicate and resorts the list.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Reader.UnionReader`2.RemoveDuplicatesFromList">
            <summary>
            Call this function when the same point exists in multiple archive files. It will
            read past the duplicate point in all other archive files and then resort the tables.
            
            Assums that the archiveStream's cached value is current.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Reader.UnionReader`2.SetReadWhileUpperBoundsValue">
            <summary>
            Sets the read while upper bounds value. 
            Which is the lesser of 
            The first point in the adjacent table or
            The end of the current seek window.
             </summary>
        </member>
        <member name="M:GSF.Snap.Services.Reader.SequentialReaderStream`2.CancelReader">
            <summary>
            Provides a thread safe way to cancel a reader.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Reader.SequentialReaderStream`2.VerifyArchiveStreamSortingOrder">
            <summary>
            Will verify that the stream is in the proper order and remove any duplicates that were found. 
            May be called after every single read, but better to be called
            when a ReadWhile function returns false.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Reader.SequentialReaderStream`2.AdvanceSeekableFilter(System.Boolean,`0)">
            <summary>
            Does a seek operation on the current stream when there is a seek filter on the reader.
            </summary>
            <returns>
            True if the provided key is still valid within the next best fitting frame. 
            </returns>
        </member>
        <member name="M:GSF.Snap.Services.Reader.SequentialReaderStream`2.CompareStreams(GSF.Snap.Services.Reader.BufferedArchiveStream{`0,`1},GSF.Snap.Services.Reader.BufferedArchiveStream{`0,`1})">
            <summary>
            Compares two Archive Streams together for proper sorting.
            </summary>
            <param name="item1"></param>
            <param name="item2"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Services.Reader.SequentialReaderStream`2.SeekToKey(`0)">
            <summary>
            Does an unconditional seek operation to the provided key.
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:GSF.Snap.Services.Reader.SequentialReaderStream`2.SeekAllArchiveStreamsForward(`0)">
            <summary>
            Seeks the streams only in the forward direction.
            This means that if the current position in any stream is invalid or past this point,
            the stream will not seek backwards.
            </summary>
            <param name="key">the key to seek to</param>
        </member>
        <member name="M:GSF.Snap.Services.Reader.SequentialReaderStream`2.RemoveDuplicatesIfExists">
            <summary>
            Checks the first 2 Archive Streams for a duplicate entry. If one exists, then removes the duplicate and resorts the list.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Reader.SequentialReaderStream`2.RemoveDuplicatesFromList">
            <summary>
            Call this function when the same point exists in multiple archive files. It will
            read past the duplicate point in all other archive files and then resort the tables.
            
            Assums that the archiveStream's cached value is current.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Reader.SequentialReaderStream`2.SetReadWhileUpperBoundsValue">
            <summary>
            Sets the read while upper bounds value. 
            Which is the lesser of 
            The first point in the adjacent table or
            The end of the current seek window.
             </summary>
        </member>
        <member name="T:GSF.Snap.Services.Reader.SortedTreeEngineReaderOptions">
            <summary>
            Contains the options to use for executing an individual read request.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Reader.SortedTreeEngineReaderOptions.Default">
            <summary>
            Default options. Same as default constructor
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Reader.SortedTreeEngineReaderOptions.#ctor(System.TimeSpan,System.Int64,System.Int64,System.Int64)">
            <summary>
            Creates <see cref="T:GSF.Snap.Services.Reader.SortedTreeEngineReaderOptions"/>.
            </summary>
            <param name="timeout">the time before a query will end prematurely</param>
            <param name="maxReturnedCount">the maximum number of Key/Values to send to the client before ending prematurely</param>
            <param name="maxScanCount">the maximum number of points for the database to read before ending prematurely</param>
            <param name="maxSeekCount">the maximum seeks that will occur before ending prematurely</param>
        </member>
        <member name="M:GSF.Snap.Services.Reader.SortedTreeEngineReaderOptions.#ctor(GSF.IO.BinaryStreamBase)">
            <summary>
            Creates a new <see cref="T:GSF.Snap.Services.Reader.SortedTreeEngineReaderOptions"/> from a stream
            </summary>
            <param name="stream">the stream to read from</param>
        </member>
        <member name="M:GSF.Snap.Services.Reader.SortedTreeEngineReaderOptions.Save(GSF.IO.BinaryStreamBase)">
            <summary>
            Writes this data to the <see cref="!:stream"/>.
            </summary>
            <param name="stream">the stream to write data to</param>
        </member>
        <member name="P:GSF.Snap.Services.Reader.SortedTreeEngineReaderOptions.Timeout">
            <summary>
            The time before the query times out.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Reader.SortedTreeEngineReaderOptions.MaxReturnedCount">
            <summary>
            The maximum number of points to return. 0 means no limit.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Reader.SortedTreeEngineReaderOptions.MaxScanCount">
            <summary>
            The maximum number of points to scan to get the results set. 
            This includes any point that was filtered
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Reader.SortedTreeEngineReaderOptions.MaxSeekCount">
            <summary>
            The maximum number of seeks permitted
            </summary>
        </member>
        <member name="T:GSF.Snap.Services.ServerSettings">
            <summary>
            Settings for <see cref="T:GSF.Snap.Services.SnapServer"/>
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.ServerSettings.m_databases">
            <summary>
            Lists all of the databases that are part of the server
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.ServerSettings.m_listeners">
            <summary>
            All of the socket based listeners for the database.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.ServerSettings.#ctor">
            <summary>
            Creates a new instance of <see cref="T:GSF.Snap.Services.ServerSettings"/>
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.ServerSettings.Databases">
            <summary>
            Lists all of the databases that are part of the server
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.ServerSettings.Listeners">
            <summary>
            All of the socket based listeners for the database.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.ServerSettings.GSF#Snap#Services#IToServerSettings#ToServerSettings">
            <summary>
            Creates a <see cref="T:GSF.Snap.Services.ServerSettings"/> configuration that can be used for <see cref="T:GSF.Snap.Services.SnapServer"/>
            </summary>
            <returns></returns>
        </member>
        <member name="T:GSF.Snap.Services.SettingsBase`1">
            <summary>
            Core functionality for any setting of <see cref="T:GSF.Snap.Services.SnapServer"/> or any child setting.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:GSF.Snap.Services.SettingsBase`1.Save(System.IO.Stream)">
            <summary>
            Saves the setting to the supplied stream
            </summary>
            <param name="stream">the stream to write to</param>
        </member>
        <member name="M:GSF.Snap.Services.SettingsBase`1.Load(System.IO.Stream)">
            <summary>
            Loads the settings from the supplied stream
            </summary>
            <param name="stream">the stream to load from</param>
        </member>
        <member name="M:GSF.Snap.Services.SettingsBase`1.Validate">
            <summary>
            Validates the settings before they are loaded by the main class.
            </summary>
        </member>
        <member name="T:GSF.Snap.Services.Writer.SimplifiedArchiveInitializer`2">
            <summary>
            Creates new archive files based on user settings.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Writer.SimplifiedArchiveInitializer`2.#ctor(GSF.Snap.Services.Writer.SimplifiedArchiveInitializerSettings)">
            <summary>
            Creates a <see cref="T:GSF.Snap.Services.Writer.ArchiveInitializer`2"/>
            </summary>
            <param name="settings"></param>
        </member>
        <member name="P:GSF.Snap.Services.Writer.SimplifiedArchiveInitializer`2.Settings">
            <summary>
            Gets current settings.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Writer.SimplifiedArchiveInitializer`2.UpdateSettings(GSF.Snap.Services.Writer.SimplifiedArchiveInitializerSettings)">
            <summary>
            Replaces the existing settings with this new set.
            </summary>
            <param name="settings"></param>
        </member>
        <member name="M:GSF.Snap.Services.Writer.SimplifiedArchiveInitializer`2.CreateArchiveFile(`0,`0,System.Int64,GSF.Snap.TreeStream{`0,`1},System.Action{System.Guid})">
            <summary>
            Creates a new <see cref="T:GSF.Snap.Storage.SortedTreeTable`2"/> based on the settings passed to this class.
            Once created, it is up to he caller to make sure that this class is properly disposed of.
            </summary>
            <param name="startKey">the first key in the archive file</param>
            <param name="endKey">the last key in the archive file</param>
            <param name="estimatedSize">The estimated size of the file. -1 to ignore this feature and write to the first available directory.</param>
            <param name="archiveIdCallback">the archiveId to assign to the new file.</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Services.Writer.SimplifiedArchiveInitializer`2.CreateArchiveName(System.String)">
            <summary>
            Creates a new random file in one of the provided folders in a round robin fashion.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Services.Writer.SimplifiedArchiveInitializer`2.CreateArchiveName(System.String,`0,`0)">
            <summary>
            Creates a new random file in one of the provided folders in a round robin fashion.
            </summary>
            <returns></returns>
        </member>
        <member name="T:GSF.Snap.Services.Writer.SimplifiedArchiveInitializerSettings">
            <summary>
            Settings for <see cref="T:GSF.Snap.Services.Writer.SimplifiedArchiveInitializer`2"/>.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Writer.SimplifiedArchiveInitializerSettings.#ctor">
            <summary>
            Creates a new <see cref="T:GSF.Snap.Services.Writer.ArchiveInitializerSettings"/>
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Writer.SimplifiedArchiveInitializerSettings.DirectoryMethod">
            <summary>
            Gets the method that the directory structure will follow when writing a new file.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Writer.SimplifiedArchiveInitializerSettings.Prefix">
            <summary>
            Gets/Sets the file prefix. Can be String.Empty for no prefix.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Writer.SimplifiedArchiveInitializerSettings.WritePath">
            <summary>
            The list of all available paths to write files to
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Writer.SimplifiedArchiveInitializerSettings.PendingExtension">
            <summary>
            The extension to name the file.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Writer.SimplifiedArchiveInitializerSettings.FinalExtension">
            <summary>
            The extension to name the file.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Writer.SimplifiedArchiveInitializerSettings.Flags">
            <summary>
            The flags that will be added to any created archive files.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Writer.SimplifiedArchiveInitializerSettings.EncodingMethod">
            <summary>
            The encoding method that will be used to write files.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Writer.SimplifiedArchiveInitializerSettings.DesiredRemainingSpace">
            <summary>
            The desired number of bytes to leave on the disk after a rollover has completed. 
            Otherwise, pick a different directory or throw an out of disk space exception.
            </summary>
            <remarks>
            Value must be between 100MB and 1TB
            </remarks>
        </member>
        <member name="M:GSF.Snap.Services.Writer.SimplifiedArchiveInitializerSettings.ConfigureOnDisk(System.Collections.Generic.IEnumerable{System.String},System.Int64,GSF.Snap.Services.ArchiveDirectoryMethod,GSF.Snap.EncodingDefinition,System.String,System.String,System.String,System.Guid[])">
            <summary>
            Creates a <see cref="T:GSF.Snap.Services.Writer.ArchiveInitializer`2"/> that will reside on the disk.
            </summary>
            <param name="paths">the paths to place the files.</param>
            <param name="desiredRemainingSpace">The desired free space to leave on the disk before moving to another disk.</param>
            <param name="directoryMethod">the method for storing files in a directory.</param>
            <param name="encodingMethod">the encoding method to use for the archive file.</param>
            <param name="prefix">the prefix to affix to the files created.</param>
            <param name="pendingExtension">the extension file name</param>
            <param name="finalExtension">the final extension to specify</param>
            <param name="flags">flags to include in the archive that is created.</param>
            <returns></returns>
        </member>
        <member name="T:GSF.Snap.Services.Writer.RolloverLog">
            <summary>
            The log file that describes the rollover process so if the service crashes during the rollover process,
            it can properly be recovered from.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Writer.RolloverLog.#ctor(GSF.Snap.Services.Writer.RolloverLogSettings,GSF.Snap.Services.ArchiveList)">
            <summary>
            Creates a new <see cref="T:GSF.Snap.Services.Writer.RolloverLog"/>
            </summary>
            <param name="settings">the settings</param>
            <param name="list">the list</param>
        </member>
        <member name="M:GSF.Snap.Services.Writer.RolloverLog.Create(System.Collections.Generic.List{System.Guid},System.Guid)">
            <summary>
            Creates a rollover log file
            </summary>
            <param name="sourceFiles"></param>
            <param name="destinationFile"></param>
            <returns></returns>
        </member>
        <member name="T:GSF.Snap.Services.Writer.RolloverLogSettings">
            <summary>
            The settings for a <see cref="T:GSF.Snap.Services.Writer.RolloverLogFile"/>.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Writer.RolloverLogSettings.IsFileBacked">
            <summary>
            Gets if this archive log will be file backed. 
            This is true as long as <see cref="P:GSF.Snap.Services.Writer.RolloverLogSettings.LogPath"/> is assigned
            a value.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Writer.RolloverLogSettings.LogPath">
            <summary>
            The path to store all log files. Can be an empty string to 
            not enable file based logging.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Writer.RolloverLogSettings.LogFilePrefix">
            <summary>
            The prefix to assign to all log files. Can be string.empty
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Writer.RolloverLogSettings.LogFileExtension">
            <summary>
            The file extension to write the log files.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Writer.RolloverLogSettings.SearchPattern">
            <summary>
            Gets the wildcard search string for a log file.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Writer.RolloverLogSettings.GenerateNewFileName">
            <summary>
            Generates a new file name.
            </summary>
            <returns></returns>
        </member>
        <member name="T:GSF.Snap.Services.Writer.ArchiveInitializerSettings">
            <summary>
            Settings for <see cref="T:GSF.Snap.Services.Writer.ArchiveInitializer`2"/>.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Writer.ArchiveInitializerSettings.#ctor">
            <summary>
            Creates a new <see cref="T:GSF.Snap.Services.Writer.ArchiveInitializerSettings"/>
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Writer.ArchiveInitializerSettings.DirectoryMethod">
            <summary>
            Gets the method that the directory structure will follow when writing a new file.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Writer.ArchiveInitializerSettings.IsMemoryArchive">
            <summary>
            Gets if the archive file is a memory archive or a file archive.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Writer.ArchiveInitializerSettings.Prefix">
            <summary>
            Gets/Sets the file prefix. Can be String.Empty for no prefix.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Writer.ArchiveInitializerSettings.WritePath">
            <summary>
            The list of all available paths to write files to
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Writer.ArchiveInitializerSettings.FileExtension">
            <summary>
            The extension to name the file.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Writer.ArchiveInitializerSettings.Flags">
            <summary>
            The flags that will be added to any created archive files.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Writer.ArchiveInitializerSettings.EncodingMethod">
            <summary>
            The encoding method that will be used to write files.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Writer.ArchiveInitializerSettings.DesiredRemainingSpace">
            <summary>
            The desired number of bytes to leave on the disk after a rollover has completed. 
            Otherwise, pick a different directory or throw an out of disk space exception.
            </summary>
            <remarks>
            Value must be between 100MB and 1TB
            </remarks>
        </member>
        <member name="M:GSF.Snap.Services.Writer.ArchiveInitializerSettings.ConfigureInMemory(GSF.Snap.EncodingDefinition,System.Guid[])">
            <summary>
            Creates a <see cref="T:GSF.Snap.Services.Writer.ArchiveInitializer`2"/> that will reside in memory.
            </summary>
            <param name="encodingMethod">the encoding method to use for the archive file.</param>
            <param name="flags">flags to include in the archive that is created.</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Services.Writer.ArchiveInitializerSettings.ConfigureOnDisk(System.Collections.Generic.IEnumerable{System.String},System.Int64,GSF.Snap.Services.ArchiveDirectoryMethod,GSF.Snap.EncodingDefinition,System.String,System.String,System.Guid[])">
            <summary>
            Creates a <see cref="T:GSF.Snap.Services.Writer.ArchiveInitializer`2"/> that will reside on the disk.
            </summary>
            <param name="paths">the paths to place the files.</param>
            <param name="desiredRemainingSpace">The desired free space to leave on the disk before moving to another disk.</param>
            <param name="directoryMethod">the method for storing files in a directory.</param>
            <param name="encodingMethod">the encoding method to use for the archive file.</param>
            <param name="prefix">the prefix to affix to the files created.</param>
            <param name="extension">the extension file name</param>
            <param name="flags">flags to include in the archive that is created.</param>
            <returns></returns>
        </member>
        <member name="T:GSF.Snap.Services.Writer.CombineFilesSettings">
            <summary>
            A collection of settings for <see cref="T:GSF.Snap.Services.Writer.CombineFiles`2"/>.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Writer.CombineFilesSettings.ExecuteTimer">
            <summary>
            Gets the rate a which a rollover check is executed
            Time is in milliseconds.
            </summary>
            <remarks>
            Default is every 60,000 milliseconds. 
            Must be between 1 second and 10 minutes. 
            Anything outside this range will substitute for the closest valid value.
            </remarks>
        </member>
        <member name="P:GSF.Snap.Services.Writer.CombineFilesSettings.LogPath">
            <summary>
            The path to write the log file for the rollover process.
            </summary>
            <remarks>
            A value of String.Empty means that rollover logs will not be created.
            </remarks>
        </member>
        <member name="P:GSF.Snap.Services.Writer.CombineFilesSettings.CombineOnFileCount">
            <summary>
            The number of files with the specified <see cref="P:GSF.Snap.Services.Writer.CombineFilesSettings.MatchFlag"/>
            before they will be combined. 
            </summary>
            <remarks>
            Must be between 2 and 1000.
            </remarks>
        </member>
        <member name="P:GSF.Snap.Services.Writer.CombineFilesSettings.CombineOnFileSize">
            <summary>
            The size at which to create a rolled over file
            </summary>
            <remarks>
            Must be between 1MB and 100GB
            </remarks>
        </member>
        <member name="P:GSF.Snap.Services.Writer.CombineFilesSettings.MatchFlag">
            <summary>
            The archive flag to do the file combination on.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Writer.CombineFilesSettings.ArchiveSettings">
            <summary>
            The settings for the archive initializer. This value cannot be null.
            </summary>
        </member>
        <member name="T:GSF.Snap.Services.Writer.CombineFiles`2">
            <summary>
            Represents a series of stages that an archive file progresses through
            in order to properly condition the data.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Writer.CombineFiles`2.#ctor(GSF.Snap.Services.Writer.CombineFilesSettings,GSF.Snap.Services.ArchiveList{`0,`1},GSF.Snap.Services.Writer.RolloverLog)">
            <summary>
            Creates a stage writer.
            </summary>
            <param name="settings">the settings for this stage</param>
            <param name="archiveList">the archive list</param>
            <param name="rolloverLog">the rollover log</param>
        </member>
        <member name="M:GSF.Snap.Services.Writer.CombineFiles`2.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="!:LogSourceBase"/> object and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="T:GSF.Snap.Services.Writer.FirstStageWriterSettings">
            <summary>
            The settings for the <see cref="T:GSF.Snap.Services.Writer.FirstStageWriter`2"/>
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Writer.FirstStageWriterSettings.RolloverInterval">
            <summary>
            The number of milliseconds before data is flushed to the disk. 
            </summary>
            <remarks>
            Must be between 1,000 ms and 60,000 ms.
            </remarks>
        </member>
        <member name="P:GSF.Snap.Services.Writer.FirstStageWriterSettings.RolloverSizeMb">
            <summary>
            The size at which a rollover will be signaled
            </summary>
            <remarks>
            Must be at least 1MB. Upper Limit should be Memory Constrained, but not larger than 1024MB.
            </remarks>
        </member>
        <member name="P:GSF.Snap.Services.Writer.FirstStageWriterSettings.MaximumAllowedMb">
            <summary>
            The size after which the incoming write queue will pause
            to wait for rollovers to complete.
            </summary>
            <remarks>
            It is recommended to make this value larger than <see cref="P:GSF.Snap.Services.Writer.FirstStageWriterSettings.RolloverSizeMb"/>.
            If this value is smaller than <see cref="P:GSF.Snap.Services.Writer.FirstStageWriterSettings.RolloverSizeMb"/> then <see cref="P:GSF.Snap.Services.Writer.FirstStageWriterSettings.RolloverSizeMb"/> will be used.
            Must be at least 1MB. Upper Limit should be Memory Constrained, but not larger than 1024MB.
            </remarks>
        </member>
        <member name="P:GSF.Snap.Services.Writer.FirstStageWriterSettings.EncodingMethod">
            <summary>
            The encoding method that will be used to write files.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Writer.FirstStageWriterSettings.FinalSettings">
            <summary>
            The settings that will be used for the rolled over files.
            </summary>
        </member>
        <member name="T:GSF.Snap.Services.Writer.FirstStageWriter`2">
            <summary>
            Handles how data is initially taken from prestage chunks and serialized to the disk.
            </summary>
        </member>
        <member name="E:GSF.Snap.Services.Writer.FirstStageWriter`2.SequenceNumberCommitted">
            <summary>
            Event that notifies that a certain sequence number has been committed.
            </summary>
        </member>
        <member name="E:GSF.Snap.Services.Writer.FirstStageWriter`2.RolloverComplete">
            <summary>
            Occurs after a rollover operation has completed and provides the sequence number associated with
            the rollover.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Writer.FirstStageWriter`2.#ctor(GSF.Snap.Services.Writer.FirstStageWriterSettings,GSF.Snap.Services.ArchiveList{`0,`1})">
            <summary>
            Creates a stage writer.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Writer.FirstStageWriter`2.AppendData(GSF.Snap.Services.Writer.PrebufferRolloverArgs{`0,`1})">
            <summary>
            Appends this data to this stage. Also queues up for deletion if necessary.
            </summary>
            <param name="args">arguments handed to this class from either the 
            PrestageWriter or another StageWriter of a previous generation</param>
            <remarks>
            This method must be called in a single threaded manner.
            </remarks>
        </member>
        <member name="M:GSF.Snap.Services.Writer.FirstStageWriter`2.Stop">
            <summary>
            Stop all writing to this class.
            Once stopped, it cannot be resumed.
            All data is then immediately flushed to the output.
            This method calls Dispose()
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Services.Writer.FirstStageWriter`2.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:GSF.Snap.Services.Writer.FirstStageWriter`2"/> object and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="M:GSF.Snap.Services.Writer.FirstStageWriter`2.Commit(System.Int64)">
            <summary>
            Triggers a rollover if the provided sequence id has not yet been committed.
            </summary>
            <param name="sequenceId"></param>
        </member>
        <member name="T:GSF.Snap.Services.Writer.PrebufferRolloverArgs`2">
            <summary>
            A set of variables that are generated in the prebuffer stage that are provided to the onRollover 
            <see cref="T:System.Action"/> passed to the constructor of <see cref="T:GSF.Snap.Services.Writer.PrebufferWriter`2"/>.
            </summary>
            <typeparam name="TKey">The key</typeparam>
            <typeparam name="TValue">The value</typeparam>
        </member>
        <member name="F:GSF.Snap.Services.Writer.PrebufferRolloverArgs`2.Stream">
            <summary>
            The stream of points that need to be rolled over. 
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Writer.PrebufferRolloverArgs`2.TransactionId">
            <summary>
            The transaction id assoicated with the points in this buffer. 
            This is the id of the last point in this buffer.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Writer.PrebufferRolloverArgs`2.#ctor(GSF.Snap.TreeStream{`0,`1},System.Int64)">
            <summary>
            Creates a set of args
            </summary>
            <param name="stream">the stream to specify</param>
            <param name="transactionId">the number to specify</param>
        </member>
        <member name="T:GSF.Snap.Services.Writer.PrebufferWriterSettings">
            <summary>
            All of the settings for the prebuffer writer
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Writer.PrebufferWriterSettings.RolloverInterval">
            <summary>
            The maximum interval to wait in milliseconds before taking the prebuffer and rolling it into a Stage 0 Archive.
            </summary>
            <remarks>
            Must be between 1 and 1,000
            </remarks>
        </member>
        <member name="P:GSF.Snap.Services.Writer.PrebufferWriterSettings.MaximumPointCount">
            <summary>
            The maximum number of points to have in the prebuffer before rolling this into the Stage 0 Archive.
            </summary>
            <remarks>
            Must be between 1,000 and 100,000
            </remarks>
        </member>
        <member name="P:GSF.Snap.Services.Writer.PrebufferWriterSettings.RolloverPointCount">
            <summary>
            The number of points before a rollover is queued. This should be before the maximum point 
            count since once the maximum point count has been reached, a thread pause will result.
            </summary>
            <remarks>
            Must be between 1,000 and 100,000
            </remarks>
        </member>
        <member name="T:GSF.Snap.Services.Writer.RolloverLogFile">
            <summary>
            Logs the rollover process so that it can be properly finished in the event of a power outage or process crash
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Writer.RolloverLogFile.IsValid">
            <summary>
            Gets if the file is valid and not corrupt.
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Writer.RolloverLogFile.SourceFiles">
            <summary>
            Gets all of the source files.
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Writer.RolloverLogFile.DestinationFile">
            <summary>
            Gets the destination file
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Writer.RolloverLogFile.FileName">
            <summary>
            Gets the filename of this log file. String.Empty if not currently associated with a file.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Writer.RolloverLogFile.#ctor(System.String,System.Collections.Generic.List{System.Guid},System.Guid)">
            <summary>
            Creates a new rollover log
            </summary>
            <param name="fileName">the name of the file to save</param>
            <param name="sourceFiles">the source files in the rollover process</param>
            <param name="destinationFile">the destination file in the rollover process.</param>
        </member>
        <member name="M:GSF.Snap.Services.Writer.RolloverLogFile.#ctor(System.String)">
            <summary>
            Resumes a rollover log
            </summary>
            <param name="fileName">the name of the log file to load.</param>
        </member>
        <member name="M:GSF.Snap.Services.Writer.RolloverLogFile.Recover(GSF.Snap.Services.ArchiveList)">
            <summary>
            Recovers this rollover during an application crash.
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:GSF.Snap.Services.Writer.RolloverLogFile.Delete">
            <summary>
            Deletes the file associated with this ArchiveLog
            </summary>
        </member>
        <member name="T:GSF.Snap.Services.Writer.TransactionTracker`2">
            <summary>
            Handles the transactions and any waits/notifications associated with transaction numbers.
            </summary>
            <typeparam name="TKey">The key</typeparam>
            <typeparam name="TValue">The value</typeparam>
            <remarks>
            Transaction IDs are long values, starting with zero. The reason behind this, even if 2 billion transactions
            could happen per second, it would still take over 100 years without an application restart to loop around. 
            Realistically a therotical peak would be 200 million transactions per second (An Interlocked.Increment).
            </remarks>
        </member>
        <member name="T:GSF.Snap.Services.Writer.TransactionTracker`2.WaitForCommit">
            <summary>
            An internal class created for each thread that is waiting for a transaction to committ.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Writer.TransactionTracker`2.#ctor(GSF.Snap.Services.Writer.PrebufferWriter{`0,`1},GSF.Snap.Services.Writer.FirstStageWriter{`0,`1})">
            <summary>
            Creates a new transaction tracker that monitors the provided buffers.
            </summary>
            <param name="prebuffer"></param>
            <param name="firstStageWriter"></param>
        </member>
        <member name="M:GSF.Snap.Services.Writer.TransactionTracker`2.TransactionSoftCommitted(System.Int64)">
            <summary>
            Event handler.
            </summary>
            <param name="transactionId"></param>
        </member>
        <member name="M:GSF.Snap.Services.Writer.TransactionTracker`2.TransactionHardCommitted(System.Int64)">
            <summary>
            Event handler.
            </summary>
            <param name="transactionId"></param>
        </member>
        <member name="M:GSF.Snap.Services.Writer.TransactionTracker`2.WaitForSoftCommit(System.Int64)">
            <summary>
            Wait for the specified transaction to commit to memory.
            </summary>
            <param name="transactionId"></param>
        </member>
        <member name="M:GSF.Snap.Services.Writer.TransactionTracker`2.WaitForHardCommit(System.Int64)">
            <summary>
            Waits for the specified transaction to commit to the disk.
            </summary>
            <param name="transactionId"></param>
        </member>
        <member name="T:GSF.Snap.Services.Writer.WriteProcessorSettings">
            <summary>
            The settings for the Write Processor
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Writer.WriteProcessorSettings.#ctor">
            <summary>
            The default write processor settings
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Writer.WriteProcessorSettings.PrebufferWriter">
            <summary>
            The settings for the prebuffer.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Writer.WriteProcessorSettings.FirstStageWriter">
            <summary>
            The settings for the first stage writer.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Writer.WriteProcessorSettings.StagingRollovers">
            <summary>
            Contains all of the staging rollovers.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Writer.WriteProcessorSettings.IsEnabled">
            <summary>
            Gets/Sets if writing will be enabled
            </summary>
        </member>
        <member name="T:GSF.Snap.Services.Writer.ArchiveInitializer`2">
            <summary>
            Creates new archive files based on user settings.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Writer.ArchiveInitializer`2.#ctor(GSF.Snap.Services.Writer.ArchiveInitializerSettings)">
            <summary>
            Creates a <see cref="T:GSF.Snap.Services.Writer.ArchiveInitializer`2"/>
            </summary>
            <param name="settings"></param>
        </member>
        <member name="P:GSF.Snap.Services.Writer.ArchiveInitializer`2.Settings">
            <summary>
            Gets current settings.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Writer.ArchiveInitializer`2.UpdateSettings(GSF.Snap.Services.Writer.ArchiveInitializerSettings)">
            <summary>
            Replaces the existing settings with this new set.
            </summary>
            <param name="settings"></param>
        </member>
        <member name="M:GSF.Snap.Services.Writer.ArchiveInitializer`2.CreateArchiveFile(System.Int64)">
            <summary>
            Creates a new <see cref="T:GSF.Snap.Storage.SortedTreeTable`2"/> based on the settings passed to this class.
            Once created, it is up to he caller to make sure that this class is properly disposed of.
            </summary>
            <param name="estimatedSize">The estimated size of the file. -1 to ignore this feature and write to the first available directory.</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Services.Writer.ArchiveInitializer`2.CreateArchiveFile(`0,`0,System.Int64)">
            <summary>
            Creates a new <see cref="T:GSF.Snap.Storage.SortedTreeTable`2"/> based on the settings passed to this class.
            Once created, it is up to he caller to make sure that this class is properly disposed of.
            </summary>
            <param name="startKey">the first key in the archive file</param>
            <param name="endKey">the last key in the archive file</param>
            <param name="estimatedSize">The estimated size of the file. -1 to ignore this feature and write to the first available directory.</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Services.Writer.ArchiveInitializer`2.CreateArchiveName(System.String)">
            <summary>
            Creates a new random file in one of the provided folders in a round robin fashion.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Services.Writer.ArchiveInitializer`2.CreateArchiveName(System.String,`0,`0)">
            <summary>
            Creates a new random file in one of the provided folders in a round robin fashion.
            </summary>
            <returns></returns>
        </member>
        <member name="T:GSF.Snap.Services.Writer.PrebufferWriter`2">
            <summary>
            Where uncommitted data is collected before it is 
            inserted into an archive file in a bulk operation.
            </summary>
            <remarks>
            This class is thread safe
            </remarks>
        </member>
        <member name="F:GSF.Snap.Services.Writer.PrebufferWriter`2.m_disposed">
            <summary>
            Specifies that this class has been disposed.
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Writer.PrebufferWriter`2.m_currentlyRollingOverFullQueue">
            <summary>
            Gets if the rollover thread is currently working.
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Writer.PrebufferWriter`2.m_stopped">
            <summary>
            Specifies that the prebuffer has been requested to stop processing data. 
            This occurs when gracefully shutting down the Engine, 
            allowing for all points to be rolled over and written to the underlying disk.
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Writer.PrebufferWriter`2.m_latestTransactionId">
            <summary>
            The point sequence number assigned to points when they are added to the prebuffer.
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Writer.PrebufferWriter`2.m_currentTransactionIdRollingOver">
            <summary>
            The Transaction Id that is currently being processed by the rollover thread.
            Its possible that it has not completed rolling over yet.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Writer.PrebufferWriter`2.#ctor(GSF.Snap.Services.Writer.PrebufferWriterSettings,System.Action{GSF.Snap.Services.Writer.PrebufferRolloverArgs{`0,`1}})">
            <summary>
            Creates a prestage writer.
            </summary>
            <param name="settings">The settings to use for this prebuffer writer</param>
            <param name="onRollover">delegate to call when a file is done with this stage.</param>
        </member>
        <member name="P:GSF.Snap.Services.Writer.PrebufferWriter`2.LatestTransactionId">
            <summary>
            Gets the latest transaction id which is a sequential counter 
            based on the number of insert operations that have occured.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Writer.PrebufferWriter`2.Commit(System.Int64)">
            <summary>
            Triggers a rollover if the provided transaction id has not yet been triggered.
            This method does not block
            </summary>
            <param name="transactionId">the transaction id to execute the commit on.</param>
        </member>
        <member name="M:GSF.Snap.Services.Writer.PrebufferWriter`2.Write(`0,`1)">
            <summary>
            Writes the provided key/value to the prebuffer
            </summary>
            <param name="key">the key to write</param>
            <param name="value">the value to write</param>
            <returns>the transaction id identifying this point</returns>
            <remarks>Calls to this function are thread safe</remarks>
        </member>
        <member name="M:GSF.Snap.Services.Writer.PrebufferWriter`2.m_rolloverTask_Running(System.Object,GSF.EventArgs{GSF.Threading.ScheduledTaskRunningReason})">
            <summary>
            Processes the rollover of this file.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Writer.PrebufferWriter`2.Stop">
            <summary>
            Stop all writing to this class.
            Once stopped, it cannot be resumed.
            All data is then immediately flushed to the output.
            This method calls Dispose()
            </summary>
            <returns>the transaction number of the last point that written</returns>
        </member>
        <member name="M:GSF.Snap.Services.Writer.PrebufferWriter`2.Dispose(System.Boolean)">
            <summary>
            Disposes the underlying queues contained in this class. 
            This method is not thread safe.
            It is assumed this will be called after <see cref="M:GSF.Snap.Services.Writer.PrebufferWriter`2.Stop"/>.
            </summary>
        </member>
        <member name="T:GSF.Snap.Services.Writer.WriteProcessor`2">
            <summary>
            Houses all of the write operations for the historian
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:GSF.Snap.Services.Writer.WriteProcessor`2.#ctor(GSF.Snap.Services.ArchiveList{`0,`1},GSF.Snap.Services.Writer.WriteProcessorSettings,GSF.Snap.Services.Writer.RolloverLog)">
            <summary>
            Creates a <see cref="T:GSF.Snap.Services.Writer.WriteProcessor`2"/>.
            </summary>
            <param name="list">the master list of archive files</param>
            <param name="settings">the settings</param>
            <param name="rolloverLog">the rollover log value</param>
        </member>
        <member name="M:GSF.Snap.Services.Writer.WriteProcessor`2.Write(`0,`1)">
            <summary>
            Writes the provided key/value to the engine.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns>the transaction code so this write can be tracked.</returns>
        </member>
        <member name="M:GSF.Snap.Services.Writer.WriteProcessor`2.Write(GSF.Snap.TreeStream{`0,`1})">
            <summary>
            Writes the provided stream to the engine.
            </summary>
            <param name="stream"></param>
            <returns>the transaction code so this write can be tracked.</returns>
        </member>
        <member name="M:GSF.Snap.Services.Writer.WriteProcessor`2.SoftCommit(System.Int64)">
            <summary>
            Blocks until the specified point has progressed beyond the prestage level and can be queried by the user.
            </summary>
            <param name="transactionId">the sequence number representing the desired point that was committed</param>
        </member>
        <member name="M:GSF.Snap.Services.Writer.WriteProcessor`2.HardCommit(System.Int64)">
            <summary>
            Blocks until the specified point has been committed to the disk subsystem. If running in a In-Memory mode, will return
            as soon as it has been moved beyond the prestage level and can be queried by the user.
            </summary>
            <param name="transactionId">the sequence number representing the desired point that was committed</param>
        </member>
        <member name="M:GSF.Snap.Services.Writer.WriteProcessor`2.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:GSF.Snap.Services.Writer.WriteProcessor`2"/> object and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="T:GSF.Snap.Services.ServerDatabaseSettings">
            <summary>
            The settings for a <see cref="T:GSF.Snap.Services.SnapServerDatabase`2"/>
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.ServerDatabaseSettings.#ctor">
            <summary>
            Creates a new <see cref="T:GSF.Snap.Services.ServerDatabaseSettings"/>
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.ServerDatabaseSettings.KeyType">
            <summary>
            Gets the type of the key componenet
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.ServerDatabaseSettings.ValueType">
            <summary>
            Gets the type of the value componenent.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.ServerDatabaseSettings.DatabaseName">
            <summary>
            The name associated with the database.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.ServerDatabaseSettings.StreamingEncodingMethods">
            <summary>
            Gets the supported streaming methods.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.ServerDatabaseSettings.ArchiveList">
            <summary>
            The settings for the ArchiveList.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.ServerDatabaseSettings.WriteProcessor">
            <summary>
            Settings for the writer. Null if the server does not support writing.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.ServerDatabaseSettings.RolloverLog">
            <summary>
            The settings for the rollover log.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.ServerDatabaseSettings.SupportsWriting">
            <summary>
            Gets if writing or file combination will be enabled.
            </summary>
        </member>
        <member name="T:GSF.Snap.Services.SnapClient">
            <summary>
            Represents a client connection to a <see cref="T:GSF.Snap.Services.SnapServer"/>.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.SnapClient.GetDatabase(System.String)">
            <summary>
            Gets the database that matches <see cref="!:databaseName"/>
            </summary>
            <param name="databaseName">the case insensitive name of the databse</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Services.SnapClient.GetDatabase``2(System.String)">
            <summary>
            Accesses <see cref="T:GSF.Snap.Services.ClientDatabaseBase`2"/> for given <paramref name="databaseName"/>.
            </summary>
            <param name="databaseName">Name of database instance to access.</param>
            <returns><see cref="T:GSF.Snap.Services.ClientDatabaseBase`2"/> for given <paramref name="databaseName"/>.</returns>
        </member>
        <member name="M:GSF.Snap.Services.SnapClient.GetDatabaseInfo">
            <summary>
            Gets basic information for every database connected to the server.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Services.SnapClient.Contains(System.String)">
            <summary>
            Determines if <see cref="!:databaseName"/> is contained in the database.
            </summary>
            <param name="databaseName">Name of database instance to access.</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Services.SnapClient.Connect(GSF.Snap.Services.SnapServer)">
            <summary>
            Connects to a local <see cref="T:GSF.Snap.Services.SnapServer"/>.
            </summary>
            <param name="host"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Services.SnapClient.Connect(System.String,System.Int32)">
            <summary>
            Connects to a server over a network socket.
            </summary>
            <param name="serverOrIp">The name of the server to connect to, or the IP address to use.</param>
            <param name="port">The port number to connect to.</param>
            <returns>A <see cref="T:GSF.Snap.Services.SnapClient"/></returns>
        </member>
        <member name="T:GSF.Snap.Services.ArchiveListLog">
            <summary>
            Contains the Pending Deletions for the <see cref="T:GSF.Snap.Services.ArchiveList`2"/>.
            This class is thread safe.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveListLog.#ctor(GSF.Snap.Services.ArchiveListLogSettings)">
            <summary>
            Creates a log that monitors pending deletions.
            </summary>
            <param name="settings">Optional settings for the log. If none are specified, the default will not load the settings.</param>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveListLog.SaveLogToDisk">
            <summary>
            If the log is file backed
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveListLog.ClearCompletedLogs(System.Collections.Generic.HashSet{System.Guid})">
            <summary>
            Removes any log that is no longer valid from this list.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveListLog.AddFileToDelete(System.Guid)">
            <summary>
            Appends the specified file to the list of files that should be deleted.
            </summary>
            <param name="archiveId"></param>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveListLog.ShouldBeDeleted(System.Guid)">
            <summary>
            Gets if the specified file Id should be deleted based on the delete log.
            </summary>
            <param name="fileId">the id of the file.</param>
            <returns>true if the file should be deleted. False otherwise.</returns>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveListLog.GetAllFilesToDelete">
            <summary>
            Verify that none of the pending deletion files exist in the editor.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveListLog.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:GSF.Snap.Services.ArchiveListLog"/> object and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="T:GSF.Snap.Services.Net.SocketUserPermissions">
            <summary>
            Permissions associated with an individual user.
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.SocketUserPermissions.CanWrite">
            <summary>
            Gets if the user can perform write operations
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.SocketUserPermissions.CanRead">
            <summary>
            Gets if the user can perform read operations
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.SocketUserPermissions.IsAdmin">
            <summary>
            Gets if the user can perform admin operations
            </summary>
            <remarks>
            Admin operations would include 
            Detatching/Deleting/Moving
            archive file.
            </remarks>
        </member>
        <member name="M:GSF.Snap.Services.Net.SocketUserPermissions.Save(System.IO.Stream)">
            <summary>
            Saves the token to a stream
            </summary>
            <param name="stream">the stream to save to</param>
        </member>
        <member name="M:GSF.Snap.Services.Net.SocketUserPermissions.Load(System.IO.Stream)">
            <summary>
            Loads the token from a stream
            </summary>
            <param name="stream">the stream to load from</param>
        </member>
        <member name="T:GSF.Snap.Services.Net.SnapStreamingServer">
            <summary>
            This is a single server socket that handles an individual client connection.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Net.SnapStreamingServer.#ctor">
            <summary>
            Allows derived classes to call <see cref="M:GSF.Snap.Services.Net.SnapStreamingServer.Initialize(GSF.Security.SecureStreamServer{GSF.Snap.Services.Net.SocketUserPermissions},System.IO.Stream,GSF.Snap.Services.SnapServer,System.Boolean)"/> after the inheriting class 
            has done something in the constructor.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Net.SnapStreamingServer.Initialize(GSF.Security.SecureStreamServer{GSF.Snap.Services.Net.SocketUserPermissions},System.IO.Stream,GSF.Snap.Services.SnapServer,System.Boolean)">
            <summary>
            Creates a <see cref="T:GSF.Snap.Services.Net.SnapStreamingServer"/>
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Net.SnapStreamingServer.ProcessClient">
            <summary>
            This function will verify the connection, create all necessary streams, set timeouts, and catch any exceptions and terminate the connection
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:GSF.Snap.Services.Net.SnapStreamingServer.ProcessRootLevelCommands">
            <summary>
            This function will process any of the packets that come in.  It will throw an error if anything happens.  
            This will cause the calling function to close the connection.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:GSF.Snap.Services.Net.SnapStreamingServer.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:GSF.Snap.Services.Net.SnapNetworkServer"/> object and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="T:GSF.Snap.Services.Net.SnapStreamingClient">
            <summary>
            A client that communicates over a stream.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Net.SnapStreamingClient.#ctor(System.IO.Stream,GSF.Security.SecureStreamClientBase,System.Boolean)">
            <summary>
            Creates a <see cref="T:GSF.Snap.Services.Net.SnapStreamingClient"/>
            </summary>
            <param name="stream">The config to use for the client</param>
            <param name="credentials">Authenticates using the supplied user credentials.</param>
            <param name="useSsl">specifies if a ssl connection is desired.</param>
        </member>
        <member name="M:GSF.Snap.Services.Net.SnapStreamingClient.#ctor">
            <summary>
            Allows derived classes to call <see cref="M:GSF.Snap.Services.Net.SnapStreamingClient.Initialize(System.IO.Stream,GSF.Security.SecureStreamClientBase,System.Boolean)"/> after the inheriting class 
            has done something in the constructor.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Net.SnapStreamingClient.Initialize(System.IO.Stream,GSF.Security.SecureStreamClientBase,System.Boolean)">
            <summary>
            Creates a <see cref="T:GSF.Snap.Services.Net.SnapStreamingClient"/>
            </summary>
            <param name="stream">The config to use for the client</param>
            <param name="credentials">Authenticates using the supplied user credentials.</param>
            <param name="useSsl">specifies if a ssl connection is desired.</param>
        </member>
        <member name="M:GSF.Snap.Services.Net.SnapStreamingClient.GetDatabase(System.String)">
            <summary>
            Gets the database that matches <see cref="!:databaseName"/>
            </summary>
            <param name="databaseName">the case insensitive name of the databse</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Services.Net.SnapStreamingClient.GetDatabase``2(System.String)">
            <summary>
            Accesses <see cref="T:GSF.Snap.Services.ClientDatabaseBase`2"/> for given <paramref name="databaseName"/>.
            </summary>
            <param name="databaseName">Name of database instance to access.</param>
            <returns><see cref="T:GSF.Snap.Services.ClientDatabaseBase`2"/> for given <paramref name="databaseName"/>.</returns>
        </member>
        <member name="M:GSF.Snap.Services.Net.SnapStreamingClient.GetDatabaseInfo">
            <summary>
            Gets basic information for every database connected to the server.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Services.Net.SnapStreamingClient.Contains(System.String)">
            <summary>
            Determines if <see cref="!:databaseName"/> is contained in the database.
            </summary>
            <param name="databaseName">Name of database instance to access.</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Services.Net.SnapStreamingClient.GetDatabase``2(System.String,GSF.Snap.EncodingDefinition)">
            <summary>
            Accesses <see cref="T:GSF.Snap.Services.Net.StreamingClientDatabase`2"/> for given <paramref name="databaseName"/>.
            </summary>
            <param name="databaseName">Name of database instance to access.</param>
            <param name="encodingMethod"></param>
            <returns><see cref="T:GSF.Snap.Services.Net.StreamingClientDatabase`2"/> for given <paramref name="databaseName"/>.</returns>
        </member>
        <member name="M:GSF.Snap.Services.Net.SnapStreamingClient.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:GSF.Snap.Services.Net.SnapNetworkClient"/> object and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="T:GSF.Snap.Services.Net.SnapSocketListenerSettings">
            <summary>
            Contains the basic config for a socket interface.
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.SnapSocketListenerSettings.DefaultNetworkPort">
            <summary>
            Defines the default network port for a <see cref="T:GSF.Snap.Services.Net.SnapSocketListener"/>.
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.SnapSocketListenerSettings.DefaultIPAddress">
            <summary>
            Defines the default network IP address for the <see cref="T:GSF.Snap.Services.Net.SnapSocketListener"/>.
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.SnapSocketListenerSettings.DefaultServerName">
            <summary>
            A server name that must be supplied at startup before a key exchange occurs.
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.SnapSocketListenerSettings.m_localIpAddress">
            <summary>
            The local IP address to host on. Leave empty to bind to all local interfaces.
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.SnapSocketListenerSettings.m_localTcpPort">
            <summary>
            The local TCP port to host on. 
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.SnapSocketListenerSettings.m_serverName">
            <summary>
            A server name that must be supplied at startup before a key exchange occurs.
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.SnapSocketListenerSettings.m_users">
            <summary>
            A list of all windows users that are allowed to connnect to the historian.
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.SnapSocketListenerSettings.m_forceSsl">
            <summary>
            Force the use of Ssl for all clients connecting to this socket.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Net.SnapSocketListenerSettings.LocalEndPoint">
            <summary>
            Gets the local <see cref="T:System.Net.IPEndPoint"/> from the values in <see cref="F:GSF.Snap.Services.Net.SnapSocketListenerSettings.m_localIpAddress"/> and <see cref="F:GSF.Snap.Services.Net.SnapSocketListenerSettings.m_localTcpPort"/>
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Net.SnapSocketListenerSettings.Users">
            <summary>
            A list of all windows users that are allowed to connnect to the historian.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Net.SnapSocketListenerSettings.ForceSsl">
            <summary>
            Force the use of Ssl for all clients connecting to this socket.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Net.SnapSocketListenerSettings.LocalTcpPort">
            <summary>
            The local TCP port to host on. 
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Net.SnapSocketListenerSettings.LocalIpAddress">
            <summary>
            The local IP address to host on. Leave empty to bind to all local interfaces.
            </summary>
        </member>
        <member name="T:GSF.Snap.Services.Net.SnapNetworkClientSettings">
            <summary>
            The options that are passed to a <see cref="T:GSF.Snap.Services.Net.SnapNetworkClient"/>.
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.SnapNetworkClientSettings.NetworkPort">
            <summary>
            The port number to connect to.
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.SnapNetworkClientSettings.ServerNameOrIp">
            <summary>
            The name of the server to connect to, or the IP address to use.
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.SnapNetworkClientSettings.UseIntegratedSecurity">
            <summary>
            Gets if integrated security will be used, or if the default user will be used.
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.SnapNetworkClientSettings.UseSsl">
            <summary>
            Gets/Sets if Ssl will be used in the authentication.
            </summary>
        </member>
        <member name="T:GSF.Snap.Services.Net.StreamingServerDatabase`2">
            <summary>
            This is a single server socket database that is owned by a remote client.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:GSF.Snap.Services.Net.StreamingServerDatabase`2.RunDatabaseLevel">
            <summary>
            This function will verify the connection, create all necessary streams, set timeouts, and catch any exceptions and terminate the connection
            </summary>
            <returns>True if successful, false if needing to exit the socket.</returns>
        </member>
        <member name="T:GSF.Snap.Services.Net.SnapNetworkClient">
            <summary>
            A client that communicates over a network socket.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Net.SnapNetworkClient.#ctor(GSF.Snap.Services.Net.SnapNetworkClientSettings,GSF.Security.SecureStreamClientBase,System.Boolean)">
            <summary>
            Creates a <see cref="T:GSF.Snap.Services.Net.SnapNetworkClient"/>
            </summary>
            <param name="settings">The config to use for the client</param>
            <param name="credentials">The network credentials to use. 
            If left null, the computers current credentials are use.</param>
            <param name="useSsl">Specifies if ssl encryption is desired for the connection.</param>
        </member>
        <member name="M:GSF.Snap.Services.Net.SnapNetworkClient.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:GSF.Snap.Services.Net.SnapNetworkClient"/> object and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="T:GSF.Snap.Services.Net.StreamingClientDatabase`2">
            <summary>
            A socket based client that extends connecting to a database.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:GSF.Snap.Services.Net.StreamingClientDatabase`2.#ctor(GSF.Net.RemoteBinaryStream,System.Action,GSF.Snap.Services.DatabaseInfo)">
            <summary>
            Creates a streaming wrapper around a database.
            </summary>
            <param name="stream"></param>
            <param name="onDispose"></param>
            <param name="info"></param>
        </member>
        <member name="M:GSF.Snap.Services.Net.StreamingClientDatabase`2.SetEncodingMode(GSF.Snap.EncodingDefinition)">
            <summary>
            Defines the encoding method to use for the server.
            </summary>
            <param name="encoding"></param>
        </member>
        <member name="M:GSF.Snap.Services.Net.StreamingClientDatabase`2.Read(GSF.Snap.Services.Reader.SortedTreeEngineReaderOptions,GSF.Snap.Filters.SeekFilterBase{`0},GSF.Snap.Filters.MatchFilterBase{`0,`1})">
            <summary>
            Reads data from the SortedTreeEngine with the provided read options and server side filters.
            </summary>
            <param name="readerOptions">read options supplied to the reader. Can be null.</param>
            <param name="keySeekFilter">a seek based filter to follow. Can be null.</param>
            <param name="keyMatchFilter">a match based filer to follow. Can be null.</param>
            <returns>A stream that will read the specified data.</returns>
        </member>
        <member name="M:GSF.Snap.Services.Net.StreamingClientDatabase`2.Write(GSF.Snap.TreeStream{`0,`1})">
            <summary>
            Writes the tree stream to the database. 
            </summary>
            <param name="stream">all of the key/value pairs to add to the database.</param>
        </member>
        <member name="M:GSF.Snap.Services.Net.StreamingClientDatabase`2.Write(`0,`1)">
            <summary>
            Writes an individual key/value to the sorted tree store.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:GSF.Snap.Services.Net.StreamingClientDatabase`2.StartBulkWriting">
            <summary>
            Due to the blocking nature of streams, this helper class can substantially 
            improve the performance of writing streaming points to the historian.
            </summary>
            <returns></returns>
        </member>
        <member name="P:GSF.Snap.Services.Net.StreamingClientDatabase`2.IsDisposed">
            <summary>
            Gets if has been disposed.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.Net.StreamingClientDatabase`2.Info">
            <summary>
            Gets basic information about the current Database.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Net.StreamingClientDatabase`2.SoftCommit">
            <summary>
            Forces a soft commit on the database. A soft commit 
            only commits data to memory. This allows other clients to read the data.
            While soft committed, this data could be lost during an unexpected shutdown.
            Soft commits usually occur within microseconds. 
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Net.StreamingClientDatabase`2.HardCommit">
            <summary>
            Forces a commit to the disk subsystem. Once this returns, the data will not
            be lost due to an application crash or unexpected shutdown.
            Hard commits can take 100ms or longer depending on how much data has to be committed. 
            This requires two consecutive hardware cache flushes.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Net.StreamingClientDatabase`2.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:GSF.Snap.Services.Net.StreamingClientDatabase`2.BulkWriting">
            <summary>
            Handles bulk writing to a streaming interface.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Net.StreamingClientDatabase`2.BulkWriting.Write(`0,`1)">
            <summary>
            Writes to the encoded stream.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:GSF.Snap.Services.Net.StreamingClientDatabase`2.BulkWriting.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:GSF.Snap.Services.Net.StreamingClientDatabase`2.PointReader.ReadNext(`0,`1)">
            <summary>
            Advances the stream to the next value. 
            If before the beginning of the stream, advances to the first value
            </summary>
            <returns>True if the advance was successful. False if the end of the stream was reached.</returns>
        </member>
        <member name="T:GSF.Snap.Services.Net.SnapNetworkServer">
            <summary>
            This is a single server socket that handles an individual client connection.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Net.SnapNetworkServer.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:GSF.Snap.Services.Net.SnapNetworkServer"/> object and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="T:GSF.Snap.Services.Net.SnapSocketListener">
            <summary>
            Hosts a <see cref="T:GSF.Snap.Services.SnapServer"/> on a network socket.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.Net.SnapSocketListener.#ctor(GSF.Snap.Services.Net.SnapSocketListenerSettings,GSF.Snap.Services.SnapServer)">
            <summary>
            Creates a <see cref="T:GSF.Snap.Services.Net.SnapSocketListener"/>
            </summary>
            <param name="settings"></param>
            <param name="server"></param>
            <param name="parent"></param>
        </member>
        <member name="M:GSF.Snap.Services.Net.SnapSocketListener.GetFullStatus(System.Text.StringBuilder)">
            <summary>
            Gets the status of the <see cref="T:GSF.Snap.Services.Net.SnapSocketListener"/>.
            </summary>
            <param name="status"></param>
        </member>
        <member name="M:GSF.Snap.Services.Net.SnapSocketListener.ProcessDataRequests(System.Object)">
            <summary>
            Processes the client
            </summary>
            <param name="state"></param>
        </member>
        <member name="M:GSF.Snap.Services.Net.SnapSocketListener.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:GSF.Snap.Services.Net.SnapSocketListener"/> object and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="T:GSF.Snap.Services.Net.ServerCommand">
            <summary>
            Server commands
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.ServerCommand.ConnectToDatabase">
            <summary>
            
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.ServerCommand.DisconnectDatabase">
            <summary>
            
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.ServerCommand.Disconnect">
            <summary>
            
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.ServerCommand.Read">
            <summary>
            
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.ServerCommand.CancelRead">
            <summary>
            
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.ServerCommand.Write">
            <summary>
            
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.ServerCommand.SetEncodingMethod">
            <summary>
            
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.ServerCommand.GetAllDatabases">
            <summary>
            
            </summary>
        </member>
        <member name="T:GSF.Snap.Services.Net.ServerResponse">
            <summary>
            Server response
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.ServerResponse.UnhandledException">
            <summary>
            
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.ServerResponse.UnknownProtocol">
            <summary>
            Occurs at first connection if the protocol version is not recgonized by the server.
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.ServerResponse.ConnectedToRoot">
            <summary>
            
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.ServerResponse.ListOfDatabases">
            <summary>
            
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.ServerResponse.DatabaseDoesNotExist">
            <summary>
            
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.ServerResponse.DatabaseKeyUnknown">
            <summary>
            
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.ServerResponse.DatabaseValueUnknown">
            <summary>
            
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.ServerResponse.SuccessfullyConnectedToDatabase">
            <summary>
            
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.ServerResponse.GoodBye">
            <summary>
            
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.ServerResponse.UnknownCommand">
            <summary>
            
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.ServerResponse.UnknownEncodingMethod">
            <summary>
            
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.ServerResponse.EncodingMethodAccepted">
            <summary>
            
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.ServerResponse.DatabaseDisconnected">
            <summary>
            
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.ServerResponse.UnknownDatabaseCommand">
            <summary>
            
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.ServerResponse.UnknownOrCorruptSeekFilter">
            <summary>
            
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.ServerResponse.UnknownOrCorruptMatchFilter">
            <summary>
            
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.ServerResponse.UnknownOrCorruptReaderOptions">
            <summary>
            
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.ServerResponse.SerializingPoints">
            <summary>
            
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.ServerResponse.ErrorWhileReading">
            <summary>
            
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.ServerResponse.CanceledRead">
            <summary>
            
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.ServerResponse.ReadComplete">
            <summary>
            
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.ServerResponse.ServerNameTooLong">
            <summary>
            Occurs during initial connection. 
            Indicates that the server name 
            string was longer than 100 characters.
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.Net.ServerResponse.ServerNameDoesNotMatch">
            <summary>
            Occurs when the server name 
            specificed in the initial connection
            does not match this server.
            </summary>
        </member>
        <member name="T:GSF.Snap.Services.SnapServerDatabase`2">
            <summary>
            Creates an engine for reading/writing data from a SortedTreeStore.
            </summary>
        </member>
        <member name="T:GSF.Snap.Services.SnapServerDatabase`2.ClientDatabase">
            <summary>
            A client database that is one part of a  <see cref="T:GSF.Snap.Services.SnapServer.Client"/> that wraps a <see cref="T:GSF.Snap.Services.SnapServerDatabase`2"/>.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.SnapServerDatabase`2.ClientDatabase.IsDisposed">
            <summary>
            Gets if has been disposed.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.SnapServerDatabase`2.ClientDatabase.Info">
            <summary>
            Gets basic information about the current Database.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.SnapServerDatabase`2.ClientDatabase.SoftCommit">
            <summary>
            Forces a soft commit on the database. A soft commit 
            only commits data to memory. This allows other clients to read the data.
            While soft committed, this data could be lost during an unexpected shutdown.
            Soft commits usually occur within microseconds. 
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.SnapServerDatabase`2.ClientDatabase.HardCommit">
            <summary>
            Forces a commit to the disk subsystem. Once this returns, the data will not
            be lost due to an application crash or unexpected shutdown.
            Hard commits can take 100ms or longer depending on how much data has to be committed. 
            This requires two consecutive hardware cache flushes.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.SnapServerDatabase`2.ClientDatabase.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:GSF.Snap.Services.SnapServerDatabase`2.ClientDatabase.Read(GSF.Snap.Services.Reader.SortedTreeEngineReaderOptions,GSF.Snap.Filters.SeekFilterBase{`0},GSF.Snap.Filters.MatchFilterBase{`0,`1})">
            <summary>
            Reads data from the SortedTreeEngine with the provided read options and server side filters.
            </summary>
            <param name="readerOptions">read options supplied to the reader. Can be null.</param>
            <param name="keySeekFilter">a seek based filter to follow. Can be null.</param>
            <param name="keyMatchFilter">a match based filer to follow. Can be null.</param>
            <returns>A stream that will read the specified data.</returns>
        </member>
        <member name="M:GSF.Snap.Services.SnapServerDatabase`2.ClientDatabase.Write(GSF.Snap.TreeStream{`0,`1})">
            <summary>
            Writes the tree stream to the database. 
            </summary>
            <param name="stream">all of the key/value pairs to add to the database.</param>
        </member>
        <member name="M:GSF.Snap.Services.SnapServerDatabase`2.ClientDatabase.Write(`0,`1)">
            <summary>
            Writes an individual key/value to the sorted tree store.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:GSF.Snap.Services.SnapServerDatabase`2.#ctor(GSF.Snap.Services.ServerDatabaseSettings)">
            <summary>
            
            </summary>
            <param name="settings"></param>
        </member>
        <member name="M:GSF.Snap.Services.SnapServerDatabase`2.AttachFilesOrPaths(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Loads the provided files from all of the specified paths.
            </summary>
            <param name="paths">all of the paths of archive files to attach. These can either be a path, or an individual file name.</param>
        </member>
        <member name="M:GSF.Snap.Services.SnapServerDatabase`2.GetFullStatus(System.Text.StringBuilder)">
            <summary>
            Gets status information for the SortedTreeEngine
            </summary>
            <param name="status">where to append the status log.</param>
        </member>
        <member name="P:GSF.Snap.Services.SnapServerDatabase`2.Info">
            <summary>
            Gets basic information about the current Database.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.SnapServerDatabase`2.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:GSF.Snap.Services.SnapServerDatabase`2"/> object and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="M:GSF.Snap.Services.SnapServerDatabase`2.SoftCommit">
            <summary>
            Forces a soft commit on the database. A soft commit 
            only commits data to memory. This allows other clients to read the data.
            While soft committed, this data could be lost during an unexpected shutdown.
            Soft commits usually occur within microseconds. 
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.SnapServerDatabase`2.HardCommit">
            <summary>
            Forces a commit to the disk subsystem. Once this returns, the data will not
            be lost due to an application crash or unexpected shutdown.
            Hard commits can take 100ms or longer depending on how much data has to be committed. 
            This requires two consecutive hardware cache flushes.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.SnapServerDatabase`2.CreateClientDatabase(GSF.Snap.Services.SnapClient,System.Action{GSF.Snap.Services.ClientDatabaseBase})">
            <summary>
            Creates a <see cref="T:GSF.Snap.Services.SnapServerDatabase`2.ClientDatabase"/>
            </summary>
            <returns></returns>
        </member>
        <member name="T:GSF.Snap.Services.DatabaseInfo">
            <summary>
            Contains a basic set of data for a <see cref="T:GSF.Snap.Services.ClientDatabaseBase`2"/>.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.DatabaseInfo.#ctor(System.String,GSF.Snap.SnapTypeBase,GSF.Snap.SnapTypeBase,System.Collections.Generic.IList{GSF.Snap.EncodingDefinition})">
            <summary>
            Creates a <see cref="T:GSF.Snap.Services.DatabaseInfo"/>
            </summary>
            <param name="databaseName">the name of the database</param>
            <param name="key">the key type</param>
            <param name="value">the value type</param>
            <param name="supportedStreamingModes"></param>
        </member>
        <member name="M:GSF.Snap.Services.DatabaseInfo.#ctor(GSF.IO.BinaryStreamBase)">
            <summary>
            Loads a <see cref="T:GSF.Snap.Services.DatabaseInfo"/> from stream.
            </summary>
            <param name="stream"></param>
        </member>
        <member name="P:GSF.Snap.Services.DatabaseInfo.DatabaseName">
            <summary>
            Gets the name of the database
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.DatabaseInfo.KeyTypeID">
            <summary>
            Gets the ID for the database key.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.DatabaseInfo.ValueTypeID">
            <summary>
            Gets the ID for the database value.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.DatabaseInfo.KeyType">
            <summary>
            Gets the type for the database key.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.DatabaseInfo.ValueType">
            <summary>
            Gets the type for the database value.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.DatabaseInfo.SupportedStreamingModes">
            <summary>
            Gets all of the supported streaming modes for the server.
            </summary>
        </member>
        <member name="T:GSF.Snap.Services.SnapServer">
            <summary>
            Hosts all of the components of a SortedTreeStore.
            </summary>
            <remarks>
            A centralized server hosting model for a SortedTreeStore.
            
            This class contains all of the databases, client connections,
            sockets, user authentication, and core settings for the SortedTreeStore.
            </remarks>
        </member>
        <member name="T:GSF.Snap.Services.SnapServer.Client">
            <summary>
            A client wrapper around a <see cref="T:GSF.Snap.Services.SnapServer"/>. This protects
            the server from a client being able to manipulate it. 
            (For example. Call the IDispose.Dispose method)
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.SnapServer.Client.#ctor(GSF.Snap.Services.SnapServer)">
            <summary>
            Creates a <see cref="T:GSF.Snap.Services.SnapServer.Client"/>
            </summary>
            <param name="server">the collection to wrap</param>
        </member>
        <member name="M:GSF.Snap.Services.SnapServer.Client.GetDatabase(System.String)">
            <summary>
            Gets the database that matches <see cref="!:databaseName"/>
            </summary>
            <param name="databaseName">the case insensitive name of the databse</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Services.SnapServer.Client.GetDatabase``2(System.String)">
            <summary>
            Accesses <see cref="T:GSF.Snap.Services.ClientDatabaseBase`2"/> for given <paramref name="databaseName"/>.
            </summary>
            <param name="databaseName">Name of database instance to access.</param>
            <returns><see cref="T:GSF.Snap.Services.ClientDatabaseBase`2"/> for given <paramref name="databaseName"/>.</returns>
        </member>
        <member name="M:GSF.Snap.Services.SnapServer.Client.Contains(System.String)">
            <summary>
            Determines if <see cref="!:databaseName"/> is contained in the database.
            </summary>
            <param name="databaseName">Name of database instance to access.</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Services.SnapServer.Client.GetDatabaseInfo">
            <summary>
            Gets basic information for every database connected to the server.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Services.SnapServer.Client.Unregister(GSF.Snap.Services.ClientDatabaseBase)">
            <summary>
            Unregisters a client database.
            </summary>
            <param name="client">the client database to unregister</param>
        </member>
        <member name="F:GSF.Snap.Services.SnapServer.m_databases">
            <summary>
            Contains a list of databases that are UPPER case names.
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.SnapServer.m_clients">
            <summary>
            Contains a list of all clients such that a strong reference will not be maintained.
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.SnapServer.m_sockets">
            <summary>
            All of the socket listener per IPEndPoint.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.SnapServer.#ctor">
            <summary>
            Creates an empty server instance
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.SnapServer.#ctor(GSF.Snap.Services.IToServerDatabaseSettings)">
            <summary>
            Creates a new instance of <see cref="T:GSF.Snap.Services.SnapServer"/> and adds the supplied database
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.SnapServer.#ctor(GSF.Snap.Services.IToServerSettings)">
            <summary>
            Creates a new instance of <see cref="T:GSF.Snap.Services.SnapServer"/>
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.SnapServer.AddDatabase(GSF.Snap.Services.ServerDatabaseSettings)">
            <summary>
            Adds a database to the server
            </summary>
            <param name="databaseConfig"></param>
        </member>
        <member name="M:GSF.Snap.Services.SnapServer.AddSocketListener(GSF.Snap.Services.Net.SnapSocketListenerSettings)">
            <summary>
            Adds the socket interface to the database
            </summary>
            <param name="socketSettings">the config data for the socket listener</param>
        </member>
        <member name="M:GSF.Snap.Services.SnapServer.RemoveDatabase(System.String)">
            <summary>
            Unloads the database name.
            </summary>
            <param name="database"></param>
        </member>
        <member name="M:GSF.Snap.Services.SnapServer.UnloadSocket(System.Net.IPEndPoint)">
            <summary>
            Unloads the specified socket interface.
            </summary>
            <param name="socketEndpoint"></param>
        </member>
        <member name="M:GSF.Snap.Services.SnapServer.GetDatabase(System.String)">
            <summary>
            Gets the database that matches <see cref="!:databaseName"/>
            </summary>
            <param name="databaseName">the case insensitive name of the database</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Services.SnapServer.Contains(System.String)">
            <summary>
            Determines if <see cref="!:databaseName"/> is contained in the database.
            </summary>
            <param name="databaseName">Name of database instance to access.</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Services.SnapServer.GetDatabaseInfo">
            <summary>
            Gets basic information for every database connected to the server.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Services.SnapServer.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:GSF.Snap.Services.SnapServer"/> object and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="M:GSF.Snap.Services.SnapServer.RegisterClient(GSF.Snap.Services.SnapServer.Client)">
            <summary>
            Registers a client with the server host.
            </summary>
            <param name="client"></param>
        </member>
        <member name="M:GSF.Snap.Services.SnapServer.UnRegisterClient(GSF.Snap.Services.SnapServer.Client)">
            <summary>
            UnRegisters a client with the server host. 
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.SnapServer.GetFullStatus(System.Text.StringBuilder)">
            <summary>
            Gets the status of the server.
            </summary>
            <param name="status"></param>
        </member>
        <member name="T:GSF.Snap.Services.ClientDatabaseBase">
            <summary>
            Represents a single historian database.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.ClientDatabaseBase.AttachFilesOrPaths(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Loads the provided files from all of the specified paths.
            </summary>
            <param name="paths">all of the paths of archive files to attach. These can either be a path, or an individual file name.</param>
        </member>
        <member name="M:GSF.Snap.Services.ClientDatabaseBase.GetAllAttachedFiles">
            <summary>
            Enumerates all of the files attached to the database.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Services.ClientDatabaseBase.DetatchFiles(System.Collections.Generic.List{System.Guid})">
            <summary>
            Detaches the list of files from the database.
            </summary>
            <param name="files">the file ids that need to be detatched.</param>
        </member>
        <member name="M:GSF.Snap.Services.ClientDatabaseBase.DeleteFiles(System.Collections.Generic.List{System.Guid})">
            <summary>
            Deletes the list of files from the database.
            </summary>
            <param name="files">the files that need to be deleted</param>
        </member>
        <member name="P:GSF.Snap.Services.ClientDatabaseBase.IsDisposed">
            <summary>
            Gets if has been disposed.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.ClientDatabaseBase.Info">
            <summary>
            Gets basic information about the current Database.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.ClientDatabaseBase.SoftCommit">
            <summary>
            Forces a soft commit on the database. A soft commit 
            only commits data to memory. This allows other clients to read the data.
            While soft committed, this data could be lost during an unexpected shutdown.
            Soft commits usually occur within microseconds. 
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.ClientDatabaseBase.HardCommit">
            <summary>
            Forces a commit to the disk subsystem. Once this returns, the data will not
            be lost due to an application crash or unexpected shutdown.
            Hard commits can take 100ms or longer depending on how much data has to be committed. 
            This requires two consecutive hardware cache flushes.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.ClientDatabaseBase.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:GSF.Snap.Services.ClientDatabaseBase`2">
            <summary>
            Represents a single historian database.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.ClientDatabaseBase`2.Read(GSF.Snap.Services.Reader.SortedTreeEngineReaderOptions,GSF.Snap.Filters.SeekFilterBase{`0},GSF.Snap.Filters.MatchFilterBase{`0,`1})">
            <summary>
            Reads data from the SortedTreeEngine with the provided read options and server side filters.
            </summary>
            <param name="readerOptions">read options supplied to the reader. Can be null.</param>
            <param name="keySeekFilter">a seek based filter to follow. Can be null.</param>
            <param name="keyMatchFilter">a match based filer to follow. Can be null.</param>
            <returns>A stream that will read the specified data.</returns>
        </member>
        <member name="M:GSF.Snap.Services.ClientDatabaseBase`2.Write(GSF.Snap.TreeStream{`0,`1})">
            <summary>
            Writes the tree stream to the database. 
            </summary>
            <param name="stream">all of the key/value pairs to add to the database.</param>
        </member>
        <member name="M:GSF.Snap.Services.ClientDatabaseBase`2.Write(`0,`1)">
            <summary>
            Writes an individual key/value to the sorted tree store.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="T:GSF.Snap.Services.ISortedTreeServer">
            <summary>
            An interface that describes a SortedTreeServer.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.ISortedTreeServer.CreateClientHost">
            <summary>
            Creates a client connection to the server.
            </summary>
            <returns></returns>
        </member>
        <member name="T:GSF.Snap.Services.SnapServerDatabaseBase">
            <summary>
            Represents the server side of a single database.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.SnapServerDatabaseBase.#ctor">
            <summary>
            Creates a <see cref="T:GSF.Snap.Services.SnapServerDatabaseBase"/>
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.SnapServerDatabaseBase.Info">
            <summary>
            Gets basic information about the current Database.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.SnapServerDatabaseBase.CreateClientDatabase(GSF.Snap.Services.SnapClient,System.Action{GSF.Snap.Services.ClientDatabaseBase})">
            <summary>
            Creates a <see cref="T:GSF.Snap.Services.SnapServerDatabase`2.ClientDatabase"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Services.SnapServerDatabaseBase.GetFullStatus(System.Text.StringBuilder)">
            <summary>
            Gets the full status text for the server.
            </summary>
            <param name="status"></param>
        </member>
        <member name="M:GSF.Snap.Services.SnapServerDatabaseBase.CreateDatabase(GSF.Snap.Services.ServerDatabaseSettings)">
            <summary>
            Creates a new server database from the provided config.
            </summary>
            <param name="databaseConfig"></param>
            <param name="parent">the parent LogSource</param>
            <returns></returns>
        </member>
        <member name="T:GSF.Snap.Services.ArchiveListLogFile">
            <summary>
            A individual archive list log file
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.ArchiveListLogFile.IsValid">
            <summary>
            Gets if the file is valid and not corrupt.
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.ArchiveListLogFile.FilesToDelete">
            <summary>
            Gets the list of all files that are pending deletion.
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.ArchiveListLogFile.FileName">
            <summary>
            Gets the filename of this log file. String.Empty if not currently associated with a file.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveListLogFile.RemoveDeletedFiles(System.Collections.Generic.HashSet{System.Guid})">
            <summary>
            Removes any files that have already been deleted from this log file.
            </summary>
            <remarks>
            Note, the log file should not be modified to prevent corrupting the log file.
            </remarks>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveListLogFile.Load(System.String)">
            <summary>
            Loads from the disk
            </summary>
            <param name="fileName">the name of the log file</param>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveListLogFile.Save(System.String)">
            <summary>
            Saves to the disk
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveListLogFile.Delete">
            <summary>
            Deletes the file associated with this ArchiveLog
            </summary>
        </member>
        <member name="T:GSF.Snap.Services.ArchiveTableSummary`2">
            <summary>
            Contains an immutable class of the current table
            along with its most recent snapshot.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveTableSummary`2.#ctor(GSF.Snap.Storage.SortedTreeTable{`0,`1})">
            <summary>
            Creates a snapshot summary of a table.
            </summary>
            <param name="table">the table to take the read snapshot of.</param>
        </member>
        <member name="P:GSF.Snap.Services.ArchiveTableSummary`2.FileId">
            <summary>
            Gets the ID for this file.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.ArchiveTableSummary`2.SortedTreeTable">
            <summary>
            Gets the <see cref="T:GSF.Snap.Storage.SortedTreeTable`2"/> that this class represents.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.ArchiveTableSummary`2.FirstKey">
            <summary>
            Gets the first key contained in this partition.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.ArchiveTableSummary`2.LastKey">
            <summary>
            Gets the last key contained in this partition.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.ArchiveTableSummary`2.IsEmpty">
            <summary>
            Gets if this table is empty.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.ArchiveTableSummary`2.ActiveSnapshotInfo">
            <summary>
            Gets the most recent <see cref="T:GSF.Snap.Storage.SortedTreeTableSnapshotInfo`2"/> of this class when it was created.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveTableSummary`2.Contains(`0,`0)">
            <summary>
            Determines if this table might contain data for the keys provided.
            </summary>
            <param name="startKey">the first key searching for</param>
            <param name="stopKey">the last key searching for</param>
            <returns></returns>
        </member>
        <member name="T:GSF.Snap.Services.ArchiveList`2">
            <summary>
            Manages the complete list of archive resources and the 
            associated reading and writing that goes along with it.
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.ArchiveList`2.m_fileSummaries">
            <summary>
            Contains the list of all archives.
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.ArchiveList`2.m_allSnapshots">
            <summary>
            Contains all of the active snapshots of the archive lists
            This is used for determining when resources are no longer in use.
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.ArchiveList`2.m_listLog">
            <summary>
            The log engine of the ArchiveList. This is where pending deletions or disposals are kept.
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.ArchiveList`2.m_processRemovals">
            <summary>
            The scheduled task for removing items.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveList`2.#ctor(GSF.Snap.Services.ArchiveListSettings)">
            <summary>
            Creates an ArchiveList
            </summary>
            <param name="settings">The settings for the archive list. Null will revert to a default setting.</param>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveList`2.AttachFileOrPath(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Attaches the supplied paths or files.
            </summary>
            <param name="paths">the path to file names or directories to enumerate.</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveList`2.LoadFiles(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Loads the specified files into the archive list.
            </summary>
            <param name="archiveFiles"></param>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveList`2.CreateNewClientResources">
            <summary>
            Creates an object that can be used to get updated snapshots from this <see cref="T:GSF.Snap.Services.ArchiveList`2"/>.
            Client must call <see cref="M:System.IDisposable.Dispose"/> method when finished with these resources as they will not 
            automatically be reclaimed by the garbage collector. Class will not be initiallized until calling <see cref="M:GSF.Snap.Services.ArchiveListSnapshot`2.UpdateSnapshot"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveList`2.ReleaseClientResources(GSF.Snap.Services.ArchiveListSnapshot{`0,`1})">
            <summary>
            Invoked by <see cref="M:GSF.Snap.Services.ArchiveListSnapshot`2.Dispose"/> method.
            </summary>
            <param name="archiveLists"></param>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveList`2.UpdateSnapshot(GSF.Snap.Services.ArchiveListSnapshot{`0,`1})">
            <summary>
            Invoked by <see cref="M:GSF.Snap.Services.ArchiveListSnapshot`2.UpdateSnapshot"/>.
            </summary>
            <param name="transaction"></param>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveList`2.GetFullStatus(System.Text.StringBuilder)">
            <summary>
            Appends the status of the files in the ArchiveList to the provided <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="status"></param>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveList`2.GetAllAttachedFiles">
            <summary>
            Gets a complete list of all archive files
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveList`2.AcquireEditLock">
            <summary>
            Returns an <see cref="T:System.IDisposable"/> class that can be used to edit the contents of this list.
            WARNING: Make changes quickly and dispose the returned class.  All calls to this class are blocked while
            editing this class.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveList`2.InternalAcquireEditLock">
            <summary>
            Necessary to provide shadow method of <see cref="M:GSF.Snap.Services.ArchiveList.AcquireEditLock"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveList`2.AddFileToDelete(GSF.Snap.Storage.SortedTreeTable{`0,`1})">
            <summary>
            Queues the supplied file as a file that needs to be deleted.
            MUST be called from a synchronized context.
            </summary>
            <param name="file"></param>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveList`2.AddFileToDispose(GSF.Snap.Storage.SortedTreeTable{`0,`1})">
            <summary>
            Queues the supplied file as one that needs to be disposed when no longer in use.
            MUST be called from a synchronized context.
            </summary>
            <param name="file"></param>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveList`2.IsFileBeingUsed(GSF.Snap.Storage.SortedTreeTable{`0,`1})">
            <summary>
            Determines if the provided file is currently in use
            by any resource. 
            </summary>
            <param name="sortedTree"> file to search for.</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveList`2.InternalIsFileBeingUsed(GSF.Snap.Storage.SortedTreeTable{`0,`1})">
            <summary>
            Gets if the specified file is being. 
            MUST be called from a synchronized context.
            </summary>
            <param name="sortedTree"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveList`2.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="!:LogSourceBase"/> object and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="T:GSF.Snap.Services.ArchiveList`2.Editor">
            <summary>
            Provides a way to edit an <see cref="T:GSF.Snap.Services.ArchiveList`2"/> since all edits must be atomic.
            WARNING: Instancing this class on an <see cref="T:GSF.Snap.Services.ArchiveList`2"/> will lock the class
            until <see cref="M:GSF.Snap.Services.ArchiveList`2.Editor.Dispose(System.Boolean)"/> is called. Therefore, keep locks to a minimum and always
            use a Using block.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveList`2.Editor.#ctor(GSF.Snap.Services.ArchiveList{`0,`1})">
            <summary>
            Creates an editor for the ArchiveList
            </summary>
            <param name="list">the list to create the edit lock on.</param>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveList`2.Editor.RenewArchiveSnapshot(System.Guid)">
            <summary>
            Renews the snapshot of the archive file. This will acquire the latest 
            read transaction so all new snapshots will use this later version.
            </summary>
            <param name="archiveId">the ID of the archive snapshot to renew</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveList`2.Editor.Add(GSF.Snap.Storage.SortedTreeTable{`0,`1})">
            <summary>
            Adds an archive file to the list with the given state information.
            </summary>
            <param name="sortedTree">archive table to add</param>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveList`2.Editor.Contains(System.Guid)">
            <summary>
            Returns true if the archive list contains the provided file.
            </summary>
            <param name="archiveId">the file</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveList`2.Editor.TryRemoveAndDispose(System.Guid)">
            <summary>
            Removes the <see cref="!:archiveId"/> from <see cref="T:GSF.Snap.Services.ArchiveList`2"/> and queues it for disposal.
            </summary>
            <param name="archiveId">the archive to remove</param>
            <returns>True if the item was removed, False otherwise.</returns>
            <remarks>
            Also unlocks the archive file.
            </remarks>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveList`2.Editor.TryRemoveAndDelete(System.Guid)">
            <summary>
            Removes the supplied file from the <see cref="T:GSF.Snap.Services.ArchiveList`2"/> and queues it for deletion.
            </summary>
            <param name="archiveId">file to remove and delete.</param>
            <returns>true if deleted, false otherwise</returns>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveList`2.Editor.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:GSF.Snap.Services.ArchiveList`2.Editor"/> object and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="T:GSF.Snap.Services.ArchiveListSnapshot`2">
            <summary>
            Provides a list of resources that each system transaction could be using.
            </summary>
        </member>
        <member name="E:GSF.Snap.Services.ArchiveListSnapshot`2.DisposeRequested">
            <summary>
            Signals that a disposal of this object has been requested. 
            </summary>
            <remarks>
            A race condition exists such that this class gets a dispose request before the client
            registers this event. Therefore, be sure to check <see cref="P:GSF.Snap.Services.ArchiveListSnapshot`2.IsDisposeRequested"/>
            after assigning the event handler.
            </remarks>
        </member>
        <member name="F:GSF.Snap.Services.ArchiveListSnapshot`2.m_onDisposed">
            <summary>
            A callback to tell <see cref="T:GSF.Snap.Services.ArchiveList`2"/> when resources are no longer being used.
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.ArchiveListSnapshot`2.m_acquireResources">
            <summary>
            A callback to get the latest list of resources from <see cref="T:GSF.Snap.Services.ArchiveList`2"/>.
            </summary>
        </member>
        <member name="F:GSF.Snap.Services.ArchiveListSnapshot`2.m_tables">
            <summary>
            Contains an array of all of the resources currently used by this transaction.
            This field can be null or any element of this array can also be null.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveListSnapshot`2.#ctor(System.Action{GSF.Snap.Services.ArchiveListSnapshot{`0,`1}},System.Action{GSF.Snap.Services.ArchiveListSnapshot{`0,`1}})">
            <summary>
            Creates an <see cref="T:GSF.Snap.Services.ArchiveListSnapshot`2"/>.
            </summary>
            <param name="onDisposed"></param>
            <param name="acquireResources"></param>
        </member>
        <member name="P:GSF.Snap.Services.ArchiveListSnapshot`2.Tables">
            <summary>
            Gets the list of all partitions that are currently in use.  Set partition to null to indicate
            that is is no longer needed.  Set the entire array to null to release all partitions.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveListSnapshot`2.TryGetFile(System.Guid)">
            <summary>
            Attempts to get the file for the provided fileId
            </summary>
            <param name="fileId"></param>
            <returns>Null if not found</returns>
        </member>
        <member name="P:GSF.Snap.Services.ArchiveListSnapshot`2.IsDisposeRequested">
            <summary>
            Gets if the engine is requesting that this snapshot gets disposed.
            if this is true this means the engine is waiting for the release
            of this object before it can continue its next task.
            </summary>
        </member>
        <member name="P:GSF.Snap.Services.ArchiveListSnapshot`2.IsDisposed">
            <summary>
            Gets if this class has been disposed.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveListSnapshot`2.Dispose">
            <summary>
            Disposes this class, releasing all resource locks.
            </summary>
        </member>
        <member name="M:GSF.Snap.Services.ArchiveListSnapshot`2.UpdateSnapshot">
            <summary>
            Requests from <see cref="T:GSF.Snap.Services.ArchiveList`2"/> that this snapshot get updated.
            </summary>
        </member>
        <member name="T:GSF.Snap.DistinctTreeStream`2">
            <summary>
            Ensures that a stream is distinct (Never repeats a value).
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:GSF.Snap.DistinctTreeStream`2.#ctor(GSF.Snap.TreeStream{`0,`1})">
            <summary>
            Creates a <see cref="T:GSF.Snap.DistinctTreeStream`2"/>
            </summary>
            <param name="baseStream">Must be sequential</param>
        </member>
        <member name="T:GSF.Snap.Collection.SortedPointBuffer`2">
            <summary>
            A temporary point buffer that is designed to write unsorted data to it, 
            then read the data back out sorted. 
            </summary>
            <typeparam name="TKey">The key type to use</typeparam>
            <typeparam name="TValue">The value type to use</typeparam>
            <remarks>
            This class is not thread safe. 
            </remarks>
        </member>
        <member name="F:GSF.Snap.Collection.SortedPointBuffer`2.m_sortingBlocks1">
            <summary>
            Contains indexes of sorted data.
            </summary>
        </member>
        <member name="F:GSF.Snap.Collection.SortedPointBuffer`2.m_sortingBlocks2">
            <summary>
            Contains indexes of sorted data.
            </summary>
            <remarks>
            Two blocks are needed to do a merge sort since 
            this class uses indexes instead of actually moving
            the raw values.
            </remarks>
        </member>
        <member name="F:GSF.Snap.Collection.SortedPointBuffer`2.m_keyData">
            <summary>
            A block of data for storing the keys.
            </summary>
        </member>
        <member name="F:GSF.Snap.Collection.SortedPointBuffer`2.m_valueData">
            <summary>
            A block of data for storing the values.
            </summary>
        </member>
        <member name="F:GSF.Snap.Collection.SortedPointBuffer`2.m_capacity">
            <summary>
            The maximum number of items that can be stored in this buffer.
            </summary>
        </member>
        <member name="F:GSF.Snap.Collection.SortedPointBuffer`2.m_dequeueIndex">
            <summary>
            The index of the next point to dequeue.
            </summary>
        </member>
        <member name="F:GSF.Snap.Collection.SortedPointBuffer`2.m_enqueueIndex">
            <summary>
            The index of the next point to write.
            </summary>
        </member>
        <member name="F:GSF.Snap.Collection.SortedPointBuffer`2.m_isReadingMode">
            <summary>
            Gets if the stream is currently reading. 
            The stream was not designed to be read from and written to at the same time. So the mode must be changed.
            </summary>
        </member>
        <member name="M:GSF.Snap.Collection.SortedPointBuffer`2.#ctor(System.Int32,System.Boolean)">
            <summary>
            Creates a <see cref="T:GSF.Snap.Collection.SortedPointBuffer`2"/> that can hold only exactly the specified <see cref="!:capacity"/>.
            </summary>
            <param name="capacity">The maximum number of items that can be stored in this class</param>
            <param name="removeDuplicates">specifies if the point buffer should remove duplicate key values upon reading.</param>
        </member>
        <member name="M:GSF.Snap.Collection.SortedPointBuffer`2.#ctor(System.Int32,System.Action{`0,`0})">
            <summary>
            Creates a <see cref="T:GSF.Snap.Collection.SortedPointBuffer`2"/> that can hold only exactly the specified <see cref="!:capacity"/>
            using the specified duplicate handler.
            </summary>
            <param name="capacity">The maximum number of items that can be stored in this class</param>
            <param name="duplicateHandler">Function that will handle encountered duplicates.</param>
        </member>
        <member name="P:GSF.Snap.Collection.SortedPointBuffer`2.NeverContainsDuplicates">
            <summary>
            Gets if the stream will never return duplicate keys. Do not return true unless it is Guaranteed that 
            the data read from this stream will never contain duplicates.
            </summary>
        </member>
        <member name="P:GSF.Snap.Collection.SortedPointBuffer`2.IsAlwaysSequential">
            <summary>
            Gets if the stream is always in sequential order. Do not return true unless it is Guaranteed that 
            the data read from this stream is sequential.
            </summary>
        </member>
        <member name="P:GSF.Snap.Collection.SortedPointBuffer`2.Count">
            <summary>
            Gets the current number of items in the buffer
            </summary>
        </member>
        <member name="P:GSF.Snap.Collection.SortedPointBuffer`2.IsEmpty">
            <summary>
            Gets if this buffer is empty
            </summary>
        </member>
        <member name="P:GSF.Snap.Collection.SortedPointBuffer`2.IsFull">
            <summary>
            Gets if no more items can be added to this list.
            List must be cleared before any more items can be added.
            </summary>
        </member>
        <member name="P:GSF.Snap.Collection.SortedPointBuffer`2.IsReadingMode">
            <summary>
            Gets/Sets the current mode of the point buffer.
            </summary>
            <remarks>
            This class is not designed to be read from and written to at the same time.
            This is because sorting must occur right before reading from this stream.
            </remarks>
        </member>
        <member name="M:GSF.Snap.Collection.SortedPointBuffer`2.Clear">
            <summary>
            Clears all of the items in this list.
            </summary>
        </member>
        <member name="M:GSF.Snap.Collection.SortedPointBuffer`2.TryEnqueue(`0,`1)">
            <summary>
            Attempts to enqueue the provided item to the list.
            </summary>
            <param name="key">the key to add</param>
            <param name="value">the value to add</param>
            <returns>true if the item was successfully enqueued. False if the queue is full.</returns>
            <exception cref="T:System.InvalidOperationException">Occurs if <see cref="P:GSF.Snap.Collection.SortedPointBuffer`2.IsReadingMode"/> is set to true</exception>
        </member>
        <member name="M:GSF.Snap.Collection.SortedPointBuffer`2.ReadNext(`0,`1)">
            <summary>
            Advances the stream to the next value. 
            If before the beginning of the stream, advances to the first value
            </summary>
            <returns>True if the advance was successful. False if the end of the stream was reached.</returns>
            <exception cref="T:System.InvalidOperationException">Occurs if <see cref="P:GSF.Snap.Collection.SortedPointBuffer`2.IsReadingMode"/> is set to false</exception>
        </member>
        <member name="M:GSF.Snap.Collection.SortedPointBuffer`2.EndOfStreamReached">
            <summary>
            Overrides the default behavior that disposes the stream when the end of the stream has been encountered.
            </summary>
        </member>
        <member name="M:GSF.Snap.Collection.SortedPointBuffer`2.ReadSorted(System.Int32,`0,`1)">
            <summary>
            Reads the specified item from the sorted list.
            </summary>
            <param name="index">the index of the item to read. Note: Bounds checking is not done.</param>
            <param name="key">the key to write to</param>
            <param name="value">the value to write to</param>
        </member>
        <member name="M:GSF.Snap.Collection.SortedPointBuffer`2.Sort">
            <summary>
            Does a sort of the data. using a merge sort like algorithm.
            </summary>
        </member>
        <member name="M:GSF.Snap.Collection.SortedPointBuffer`2.SortLevel(System.Int32*,System.Int32*,`0[],System.Int32,System.Int32)">
            <summary>
            Does a merge sort on the provided level.
            </summary>
            <param name="srcIndex">where the current indexes exist</param>
            <param name="dstIndex">where the final indexes should go</param>
            <param name="ptr">the data</param>
            <param name="count">the number of entries at this level</param>
            <param name="stride">the number of compares per level</param>
        </member>
        <member name="T:GSF.Snap.Encoding.IndividualEncodingDictionary">
            <summary>
            A helper class for all of the specific implementations that lookup encoding methods.
            </summary>
        </member>
        <member name="M:GSF.Snap.Encoding.IndividualEncodingDictionary.#ctor">
            <summary>
            Creates a new EncodingDictionary
            </summary>
        </member>
        <member name="M:GSF.Snap.Encoding.IndividualEncodingDictionary.Register(GSF.Snap.Definitions.IndividualEncodingDefinitionBase)">
            <summary>
            Registers this type
            </summary>
            <param name="encoding"></param>
        </member>
        <member name="M:GSF.Snap.Encoding.IndividualEncodingDictionary.TryGetEncodingMethod``1(System.Guid,GSF.Snap.Definitions.IndividualEncodingDefinitionBase@)">
            <summary>
            Attempts to get the specified encoding method from the dictionary. Will register the types if never registered before.
            </summary>
            <typeparam name="TTree">The value</typeparam>
            <param name="encodingMethod">the encoding method</param>
            <param name="encoding">an output if the encoding method exists.</param>
            <returns>True if the encoding value was found, false otherwise.</returns>
        </member>
        <member name="T:GSF.Snap.Encoding.PairEncodingGeneric`2">
            <summary>
            Creates a <see cref="T:GSF.Snap.Encoding.PairEncodingBase`2"/> from two <see cref="T:GSF.Snap.Encoding.IndividualEncodingBase`1"/>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:GSF.Snap.Encoding.PairEncodingGeneric`2.#ctor(GSF.Snap.EncodingDefinition)">
            <summary>
            Creates a new class
            </summary>
            <param name="encodingMethod">the encoding method to use this class</param>
        </member>
        <member name="P:GSF.Snap.Encoding.PairEncodingGeneric`2.UsesPreviousKey">
            <summary>
            Gets if the previous key will need to be presented to the encoding algorithms to
            property encode the next sample. Returning false will cause nulls to be passed
            in a parameters to the encoding.
            </summary>
        </member>
        <member name="P:GSF.Snap.Encoding.PairEncodingGeneric`2.UsesPreviousValue">
            <summary>
            Gets if the previous value will need to be presented to the encoding algorithms to
            property encode the next sample. Returning false will cause nulls to be passed
            in a parameters to the encoding.
            </summary>
        </member>
        <member name="P:GSF.Snap.Encoding.PairEncodingGeneric`2.MaxCompressionSize">
            <summary>
            Gets the maximum amount of space that is required for the compression algorithm. This
            prevents lower levels from having overflows on the underlying streams. It is critical
            that this value be correct. Error on the side of too large of a value as a value
            too small will corrupt data and be next to impossible to track down the point of corruption
            </summary>
        </member>
        <member name="P:GSF.Snap.Encoding.PairEncodingGeneric`2.ContainsEndOfStreamSymbol">
            <summary>
            Gets if the stream supports a symbol that 
            represents that the end of the stream has been encountered.
            </summary>
            <remarks>
            An example of a symbol would be the byte code 0xFF.
            In this case, if the first byte of the
            word is 0xFF, the encoding has specifically
            designated this as the end of the stream. Therefore, calls to
            Decompress will result in an end of stream exception.
            
            Failing to reserve a code as the end of stream will mean that
            streaming points will include its own symbol to represent the end of the
            stream, taking 1 extra byte per point encoded.
            </remarks>
        </member>
        <member name="P:GSF.Snap.Encoding.PairEncodingGeneric`2.EndOfStreamSymbol">
            <summary>
            The byte code to use as the end of stream symbol.
            May throw NotSupportedException if <see cref="P:GSF.Snap.Encoding.PairEncodingBase`2.ContainsEndOfStreamSymbol"/> is false.
            </summary>
        </member>
        <member name="M:GSF.Snap.Encoding.PairEncodingGeneric`2.Encode(GSF.IO.BinaryStreamBase,`0,`1,`0,`1)">
            <summary>
            Encodes <see cref="!:key"/> and <see cref="!:value"/> to the provided <see cref="!:stream"/>.
            </summary>
            <param name="stream">where to write the data</param>
            <param name="prevKey">the previous key if required by <see cref="P:GSF.Snap.Encoding.PairEncodingBase`2.UsesPreviousKey"/>. Otherwise null.</param>
            <param name="prevValue">the previous value if required by <see cref="P:GSF.Snap.Encoding.PairEncodingBase`2.UsesPreviousValue"/>. Otherwise null.</param>
            <param name="key">the key to encode</param>
            <param name="value">the value to encode</param>
            <returns>the number of bytes necessary to encode this key/value.</returns>
        </member>
        <member name="M:GSF.Snap.Encoding.PairEncodingGeneric`2.Decode(GSF.IO.BinaryStreamBase,`0,`1,`0,`1,System.Boolean@)">
            <summary>
            Decodes <see cref="!:key"/> and <see cref="!:value"/> from the provided <see cref="!:stream"/>.
            </summary>
            <param name="stream">where to read the data</param>
            <param name="prevKey">the previous key if required by <see cref="P:GSF.Snap.Encoding.PairEncodingBase`2.UsesPreviousKey"/>. Otherwise null.</param>
            <param name="prevValue">the previous value if required by <see cref="P:GSF.Snap.Encoding.PairEncodingBase`2.UsesPreviousValue"/>. Otherwise null.</param>
            <param name="key">the place to store the decoded key</param>
            <param name="value">the place to store the decoded value</param>
            <param name="isEndOfStream">outputs true if the end of the stream symbol is detected. Not all encoding methods have an end of stream symbol and therefore will always return false.</param>
            <returns>the number of bytes necessary to decode the next key/value.</returns>
        </member>
        <member name="M:GSF.Snap.Encoding.PairEncodingGeneric`2.Decode(System.Byte*,`0,`1,`0,`1,System.Boolean@)">
            <summary>
            Decodes <see cref="!:key"/> and <see cref="!:value"/> from the provided <see cref="!:stream"/>.
            </summary>
            <param name="stream">where to read the data</param>
            <param name="prevKey">the previous key if required by <see cref="P:GSF.Snap.Encoding.PairEncodingBase`2.UsesPreviousKey"/>. Otherwise null.</param>
            <param name="prevValue">the previous value if required by <see cref="P:GSF.Snap.Encoding.PairEncodingBase`2.UsesPreviousValue"/>. Otherwise null.</param>
            <param name="key">the place to store the decoded key</param>
            <param name="value">the place to store the decoded value</param>
            <param name="isEndOfStream">outputs true if the end of the stream symbol is detected. Not all encoding methods have an end of stream symbol and therefore will always return false.</param>
            <returns>the number of bytes necessary to decode the next key/value.</returns>
        </member>
        <member name="M:GSF.Snap.Encoding.PairEncodingGeneric`2.Encode(System.Byte*,`0,`1,`0,`1)">
            <summary>
            Encodes <see cref="!:key"/> and <see cref="!:value"/> to the provided <see cref="!:stream"/>.
            </summary>
            <param name="stream">where to write the data</param>
            <param name="prevKey">the previous key if required by <see cref="P:GSF.Snap.Encoding.PairEncodingBase`2.UsesPreviousKey"/>. Otherwise null.</param>
            <param name="prevValue">the previous value if required by <see cref="P:GSF.Snap.Encoding.PairEncodingBase`2.UsesPreviousValue"/>. Otherwise null.</param>
            <param name="key">the key to encode</param>
            <param name="value">the value to encode</param>
            <returns>the number of bytes necessary to encode this key/value.</returns>
        </member>
        <member name="M:GSF.Snap.Encoding.PairEncodingGeneric`2.Clone">
            <summary>
            Clones this encoding method.
            </summary>
            <returns>A clone</returns>
        </member>
        <member name="T:GSF.Snap.Encoding.PairEncodingDictionary">
            <summary>
            A helper class for all of the specific implementations that lookup encoding methods.
            </summary>
        </member>
        <member name="M:GSF.Snap.Encoding.PairEncodingDictionary.#ctor">
            <summary>
            Creates a new EncodingDictionary
            </summary>
        </member>
        <member name="M:GSF.Snap.Encoding.PairEncodingDictionary.Register(GSF.Snap.Definitions.PairEncodingDefinitionBase)">
            <summary>
            Registers this type
            </summary>
            <param name="encoding"></param>
        </member>
        <member name="M:GSF.Snap.Encoding.PairEncodingDictionary.TryGetEncodingMethod``2(GSF.Snap.EncodingDefinition,GSF.Snap.Definitions.PairEncodingDefinitionBase@)">
            <summary>
            Attempts to get the specified encoding method from the dictionary. Will register the types if never registered before.
            </summary>
            <typeparam name="TKey">The key</typeparam>
            <typeparam name="TValue">The value</typeparam>
            <param name="encodingMethod">the encoding method</param>
            <param name="encoding">an output if the encoding method exists.</param>
            <returns>True if the encoding value was found, false otherwise.</returns>
        </member>
        <member name="T:GSF.Snap.Encoding.PairEncodingFixedSize`2">
            <summary>
            An encoding method that is fixed in size and calls the native read/write functions of the specified type.
            </summary>
            <typeparam name="TKey">The type to use as the key</typeparam>
            <typeparam name="TValue">The type to use as the value</typeparam>
        </member>
        <member name="M:GSF.Snap.Encoding.PairEncodingFixedSize`2.#ctor">
            <summary>
            Creates a new class
            </summary>
        </member>
        <member name="P:GSF.Snap.Encoding.PairEncodingFixedSize`2.EncodingMethod">
            <summary>
            Gets the encoding method that this class implements.
            </summary>
        </member>
        <member name="P:GSF.Snap.Encoding.PairEncodingFixedSize`2.UsesPreviousKey">
            <summary>
            Gets if the previous key will need to be presented to the encoding algorithms to
            property encode the next sample. Returning false will cause nulls to be passed
            in a parameters to the encoding.
            </summary>
        </member>
        <member name="P:GSF.Snap.Encoding.PairEncodingFixedSize`2.UsesPreviousValue">
            <summary>
            Gets if the previous value will need to be presented to the encoding algorithms to
            property encode the next sample. Returning false will cause nulls to be passed
            in a parameters to the encoding.
            </summary>
        </member>
        <member name="P:GSF.Snap.Encoding.PairEncodingFixedSize`2.MaxCompressionSize">
            <summary>
            Gets the maximum amount of space that is required for the compression algorithm. This
            prevents lower levels from having overflows on the underlying streams. It is critical
            that this value be correct. Error on the side of too large of a value as a value
            too small will corrupt data and be next to impossible to track down the point of corruption
            </summary>
        </member>
        <member name="P:GSF.Snap.Encoding.PairEncodingFixedSize`2.ContainsEndOfStreamSymbol">
            <summary>
            Gets if the stream supports a symbol that 
            represents that the end of the stream has been encountered.
            </summary>
            <remarks>
            An example of a symbol would be the byte code 0xFF.
            In this case, if the first byte of the
            word is 0xFF, the encoding has specifically
            designated this as the end of the stream. Therefore, calls to
            Decompress will result in an end of stream exception.
            
            Failing to reserve a code as the end of stream will mean that
            streaming points will include its own symbol to represent the end of the
            stream, taking 1 extra byte per point encoded.
            </remarks>
        </member>
        <member name="P:GSF.Snap.Encoding.PairEncodingFixedSize`2.EndOfStreamSymbol">
            <summary>
            The byte code to use as the end of stream symbol.
            May throw NotSupportedException if <see cref="P:GSF.Snap.Encoding.PairEncodingBase`2.ContainsEndOfStreamSymbol"/> is false.
            </summary>
        </member>
        <member name="M:GSF.Snap.Encoding.PairEncodingFixedSize`2.Encode(GSF.IO.BinaryStreamBase,`0,`1,`0,`1)">
            <summary>
            Encodes <see cref="!:key"/> and <see cref="!:value"/> to the provided <see cref="!:stream"/>.
            </summary>
            <param name="stream">where to write the data</param>
            <param name="prevKey">the previous key if required by <see cref="P:GSF.Snap.Encoding.PairEncodingBase`2.UsesPreviousKey"/>. Otherwise null.</param>
            <param name="prevValue">the previous value if required by <see cref="P:GSF.Snap.Encoding.PairEncodingBase`2.UsesPreviousValue"/>. Otherwise null.</param>
            <param name="key">the key to encode</param>
            <param name="value">the value to encode</param>
            <returns>the number of bytes necessary to encode this key/value.</returns>
        </member>
        <member name="M:GSF.Snap.Encoding.PairEncodingFixedSize`2.Decode(GSF.IO.BinaryStreamBase,`0,`1,`0,`1,System.Boolean@)">
            <summary>
            Decodes <see cref="!:key"/> and <see cref="!:value"/> from the provided <see cref="!:stream"/>.
            </summary>
            <param name="stream">where to read the data</param>
            <param name="prevKey">the previous key if required by <see cref="P:GSF.Snap.Encoding.PairEncodingBase`2.UsesPreviousKey"/>. Otherwise null.</param>
            <param name="prevValue">the previous value if required by <see cref="P:GSF.Snap.Encoding.PairEncodingBase`2.UsesPreviousValue"/>. Otherwise null.</param>
            <param name="key">the place to store the decoded key</param>
            <param name="value">the place to store the decoded value</param>
            <param name="isEndOfStream">outputs true if the end of the stream symbol is detected. Not all encoding methods have an end of stream symbol and therefore will always return false.</param>
            <returns>the number of bytes necessary to decode the next key/value.</returns>
        </member>
        <member name="M:GSF.Snap.Encoding.PairEncodingFixedSize`2.Decode(System.Byte*,`0,`1,`0,`1,System.Boolean@)">
            <summary>
            Decodes <see cref="!:key"/> and <see cref="!:value"/> from the provided <see cref="!:stream"/>.
            </summary>
            <param name="stream">where to read the data</param>
            <param name="prevKey">the previous key if required by <see cref="P:GSF.Snap.Encoding.PairEncodingBase`2.UsesPreviousKey"/>. Otherwise null.</param>
            <param name="prevValue">the previous value if required by <see cref="P:GSF.Snap.Encoding.PairEncodingBase`2.UsesPreviousValue"/>. Otherwise null.</param>
            <param name="key">the place to store the decoded key</param>
            <param name="value">the place to store the decoded value</param>
            <param name="isEndOfStream">outputs true if the end of the stream symbol is detected. Not all encoding methods have an end of stream symbol and therefore will always return false.</param>
            <returns>the number of bytes necessary to decode the next key/value.</returns>
        </member>
        <member name="M:GSF.Snap.Encoding.PairEncodingFixedSize`2.Encode(System.Byte*,`0,`1,`0,`1)">
            <summary>
            Encodes <see cref="!:key"/> and <see cref="!:value"/> to the provided <see cref="!:stream"/>.
            </summary>
            <param name="stream">where to write the data</param>
            <param name="prevKey">the previous key if required by <see cref="P:GSF.Snap.Encoding.PairEncodingBase`2.UsesPreviousKey"/>. Otherwise null.</param>
            <param name="prevValue">the previous value if required by <see cref="P:GSF.Snap.Encoding.PairEncodingBase`2.UsesPreviousValue"/>. Otherwise null.</param>
            <param name="key">the key to encode</param>
            <param name="value">the value to encode</param>
            <returns>the number of bytes necessary to encode this key/value.</returns>
        </member>
        <member name="M:GSF.Snap.Encoding.PairEncodingFixedSize`2.Clone">
            <summary>
            Clones this encoding method.
            </summary>
            <returns>A clone</returns>
        </member>
        <member name="T:GSF.Snap.Encoding.PairEncodingBase`2">
            <summary>
            Represents an encoding method that takes both a key and a value to encode.
            </summary>
            <typeparam name="TKey">The key type</typeparam>
            <typeparam name="TValue">The value type</typeparam>
        </member>
        <member name="P:GSF.Snap.Encoding.PairEncodingBase`2.EncodingMethod">
            <summary>
            Gets the encoding method that this class implements.
            </summary>
        </member>
        <member name="P:GSF.Snap.Encoding.PairEncodingBase`2.UsesPreviousKey">
            <summary>
            Gets if the previous key will need to be presented to the encoding algorithms to
            property encode the next sample. Returning false will cause nulls to be passed
            in a parameters to the encoding.
            </summary>
        </member>
        <member name="P:GSF.Snap.Encoding.PairEncodingBase`2.UsesPreviousValue">
            <summary>
            Gets if the previous value will need to be presented to the encoding algorithms to
            property encode the next sample. Returning false will cause nulls to be passed
            in a parameters to the encoding.
            </summary>
        </member>
        <member name="P:GSF.Snap.Encoding.PairEncodingBase`2.MaxCompressionSize">
            <summary>
            Gets the maximum amount of space that is required for the compression algorithm. This
            prevents lower levels from having overflows on the underlying streams. It is critical
            that this value be correct. Error on the side of too large of a value as a value
            too small will corrupt data and be next to impossible to track down the point of corruption
            </summary>
        </member>
        <member name="P:GSF.Snap.Encoding.PairEncodingBase`2.ContainsEndOfStreamSymbol">
            <summary>
            Gets if the stream supports a symbol that 
            represents that the end of the stream has been encountered.
            </summary>
            <remarks>
            An example of a symbol would be the byte code 0xFF.
            In this case, if the first byte of the
            word is 0xFF, the encoding has specifically
            designated this as the end of the stream. Therefore, calls to
            Decompress will result in an end of stream exception.
            
            Failing to reserve a code as the end of stream will mean that
            streaming points will include its own symbol to represent the end of the
            stream, taking 1 extra byte per point encoded.
            </remarks>
        </member>
        <member name="P:GSF.Snap.Encoding.PairEncodingBase`2.EndOfStreamSymbol">
            <summary>
            The byte code to use as the end of stream symbol.
            May throw NotSupportedException if <see cref="P:GSF.Snap.Encoding.PairEncodingBase`2.ContainsEndOfStreamSymbol"/> is false.
            </summary>
        </member>
        <member name="M:GSF.Snap.Encoding.PairEncodingBase`2.Encode(System.Byte*,`0,`1,`0,`1)">
            <summary>
            Encodes <see cref="!:key"/> and <see cref="!:value"/> to the provided <see cref="!:stream"/>.
            </summary>
            <param name="stream">where to write the data</param>
            <param name="prevKey">the previous key if required by <see cref="P:GSF.Snap.Encoding.PairEncodingBase`2.UsesPreviousKey"/>. Otherwise null.</param>
            <param name="prevValue">the previous value if required by <see cref="P:GSF.Snap.Encoding.PairEncodingBase`2.UsesPreviousValue"/>. Otherwise null.</param>
            <param name="key">the key to encode</param>
            <param name="value">the value to encode</param>
            <returns>the number of bytes necessary to encode this key/value.</returns>
        </member>
        <member name="M:GSF.Snap.Encoding.PairEncodingBase`2.Decode(System.Byte*,`0,`1,`0,`1,System.Boolean@)">
            <summary>
            Decodes <see cref="!:key"/> and <see cref="!:value"/> from the provided <see cref="!:stream"/>.
            </summary>
            <param name="stream">where to read the data</param>
            <param name="prevKey">the previous key if required by <see cref="P:GSF.Snap.Encoding.PairEncodingBase`2.UsesPreviousKey"/>. Otherwise null.</param>
            <param name="prevValue">the previous value if required by <see cref="P:GSF.Snap.Encoding.PairEncodingBase`2.UsesPreviousValue"/>. Otherwise null.</param>
            <param name="key">the place to store the decoded key</param>
            <param name="value">the place to store the decoded value</param>
            <param name="isEndOfStream">outputs true if the end of the stream symbol is detected. Not all encoding methods have an end of stream symbol and therefore will always return false.</param>
            <returns>the number of bytes necessary to decode the next key/value.</returns>
        </member>
        <member name="M:GSF.Snap.Encoding.PairEncodingBase`2.Encode(GSF.IO.BinaryStreamBase,`0,`1,`0,`1)">
            <summary>
            Encodes <see cref="!:key"/> and <see cref="!:value"/> to the provided <see cref="!:stream"/>.
            </summary>
            <param name="stream">where to write the data</param>
            <param name="prevKey">the previous key if required by <see cref="P:GSF.Snap.Encoding.PairEncodingBase`2.UsesPreviousKey"/>. Otherwise null.</param>
            <param name="prevValue">the previous value if required by <see cref="P:GSF.Snap.Encoding.PairEncodingBase`2.UsesPreviousValue"/>. Otherwise null.</param>
            <param name="key">the key to encode</param>
            <param name="value">the value to encode</param>
            <returns>the number of bytes necessary to encode this key/value.</returns>
        </member>
        <member name="M:GSF.Snap.Encoding.PairEncodingBase`2.Decode(GSF.IO.BinaryStreamBase,`0,`1,`0,`1,System.Boolean@)">
            <summary>
            Decodes <see cref="!:key"/> and <see cref="!:value"/> from the provided <see cref="!:stream"/>.
            </summary>
            <param name="stream">where to read the data</param>
            <param name="prevKey">the previous key if required by <see cref="P:GSF.Snap.Encoding.PairEncodingBase`2.UsesPreviousKey"/>. Otherwise null.</param>
            <param name="prevValue">the previous value if required by <see cref="P:GSF.Snap.Encoding.PairEncodingBase`2.UsesPreviousValue"/>. Otherwise null.</param>
            <param name="key">the place to store the decoded key</param>
            <param name="value">the place to store the decoded value</param>
            <param name="isEndOfStream">outputs true if the end of the stream symbol is detected. Not all encoding methods have an end of stream symbol and therefore will always return false.</param>
            <returns>the number of bytes necessary to decode the next key/value.</returns>
        </member>
        <member name="M:GSF.Snap.Encoding.PairEncodingBase`2.Clone">
            <summary>
            Clones this encoding method.
            </summary>
            <returns>A clone</returns>
        </member>
        <member name="T:GSF.Snap.Encoding.IndividualEncodingFixedSize`1">
            <summary>
            A single encoding method for a fixed size encoding
            </summary>
        </member>
        <member name="M:GSF.Snap.Encoding.IndividualEncodingFixedSize`1.#ctor">
            <summary>
            Creates a fixed size encoding class for a single key.
            </summary>
        </member>
        <member name="P:GSF.Snap.Encoding.IndividualEncodingFixedSize`1.ContainsEndOfStreamSymbol">
            <summary>
            Gets if the stream supports a symbol that 
            represents that the end of the stream has been encountered.
            </summary>
            <remarks>
            An example of a symbol would be the byte code 0xFF.
            In this case, if the first byte of the
            word is 0xFF, the encoding has specifically
            designated this as the end of the stream. Therefore, calls to
            Decompress will result in an end of stream exception.
            
            Failing to reserve a code as the end of stream will mean that
            streaming points will include its own symbol to represent the end of the
            stream, taking 1 extra byte per point encoded.
            </remarks>
        </member>
        <member name="P:GSF.Snap.Encoding.IndividualEncodingFixedSize`1.EndOfStreamSymbol">
            <summary>
            The byte code to use as the end of stream symbol.
            May throw NotSupportedException if <see cref="P:GSF.Snap.Encoding.IndividualEncodingBase`1.ContainsEndOfStreamSymbol"/> is false.
            </summary>
        </member>
        <member name="P:GSF.Snap.Encoding.IndividualEncodingFixedSize`1.UsesPreviousValue">
            <summary>
            Gets if the previous value will need to be presented to the encoding algorithms to
            property encode the next sample. Returning false will cause nulls to be passed
            in a parameters to the encoding.
            </summary>
        </member>
        <member name="P:GSF.Snap.Encoding.IndividualEncodingFixedSize`1.MaxCompressionSize">
            <summary>
            Gets the maximum amount of space that is required for the compression algorithm. This
            prevents lower levels from having overflows on the underlying streams. It is critical
            that this value be correct. Error on the side of too large of a value as a value
            too small will corrupt data and be next to impossible to track down the point of corruption
            </summary>
        </member>
        <member name="M:GSF.Snap.Encoding.IndividualEncodingFixedSize`1.Encode(GSF.IO.BinaryStreamBase,`0,`0)">
            <summary>
            Encodes <see cref="!:value"/> to the provided <see cref="!:stream"/>.
            </summary>
            <param name="stream">where to write the data</param>
            <param name="prevValue">the previous value if required by <see cref="P:GSF.Snap.Encoding.IndividualEncodingBase`1.UsesPreviousValue"/>. Otherwise null.</param>
            <param name="value">the value to encode</param>
            <returns>the number of bytes necessary to encode this key/value.</returns>
        </member>
        <member name="M:GSF.Snap.Encoding.IndividualEncodingFixedSize`1.Decode(GSF.IO.BinaryStreamBase,`0,`0,System.Boolean@)">
            <summary>
            Decodes <see cref="!:value"/> from the provided <see cref="!:stream"/>.
            </summary>
            <param name="stream">where to read the data</param>
            <param name="prevValue">the previous value if required by <see cref="P:GSF.Snap.Encoding.IndividualEncodingBase`1.UsesPreviousValue"/>. Otherwise null.</param>
            <param name="value">the place to store the decoded value</param>
            <param name="isEndOfStream">outputs true if the end of the stream symbol is detected. Not all encoding methods have an end of stream symbol and therefore will always return false.</param>
            <returns>the number of bytes necessary to decode the next key/value.</returns>
        </member>
        <member name="M:GSF.Snap.Encoding.IndividualEncodingFixedSize`1.Decode(System.Byte*,`0,`0,System.Boolean@)">
            <summary>
            Decodes <see cref="!:value"/> from the provided <see cref="!:stream"/>.
            </summary>
            <param name="stream">where to read the data</param>
            <param name="prevValue">the previous value if required by <see cref="P:GSF.Snap.Encoding.IndividualEncodingBase`1.UsesPreviousValue"/>. Otherwise null.</param>
            <param name="value">the place to store the decoded value</param>
            <param name="isEndOfStream">outputs true if the end of the stream symbol is detected. Not all encoding methods have an end of stream symbol and therefore will always return false.</param>
            <returns>the number of bytes necessary to decode the next key/value.</returns>
        </member>
        <member name="M:GSF.Snap.Encoding.IndividualEncodingFixedSize`1.Encode(System.Byte*,`0,`0)">
            <summary>
            Encodes <see cref="!:value"/> to the provided <see cref="!:stream"/>.
            </summary>
            <param name="stream">where to write the data</param>
            <param name="prevValue">the previous value if required by <see cref="P:GSF.Snap.Encoding.IndividualEncodingBase`1.UsesPreviousValue"/>. Otherwise null.</param>
            <param name="value">the value to encode</param>
            <returns>the number of bytes necessary to encode this key/value.</returns>
        </member>
        <member name="M:GSF.Snap.Encoding.IndividualEncodingFixedSize`1.Clone">
            <summary>
            Clones this encoding method.
            </summary>
            <returns>A clone</returns>
        </member>
        <member name="T:GSF.Snap.Encoding.IndividualEncodingBase`1">
            <summary>
            Base Class that allows compressing of a single value
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:GSF.Snap.Encoding.IndividualEncodingBase`1.ContainsEndOfStreamSymbol">
            <summary>
            Gets if the stream supports a symbol that 
            represents that the end of the stream has been encountered.
            </summary>
            <remarks>
            An example of a symbol would be the byte code 0xFF.
            In this case, if the first byte of the
            word is 0xFF, the encoding has specifically
            designated this as the end of the stream. Therefore, calls to
            Decompress will result in an end of stream exception.
            
            Failing to reserve a code as the end of stream will mean that
            streaming points will include its own symbol to represent the end of the
            stream, taking 1 extra byte per point encoded.
            </remarks>
        </member>
        <member name="P:GSF.Snap.Encoding.IndividualEncodingBase`1.EndOfStreamSymbol">
            <summary>
            The byte code to use as the end of stream symbol.
            May throw NotSupportedException if <see cref="P:GSF.Snap.Encoding.IndividualEncodingBase`1.ContainsEndOfStreamSymbol"/> is false.
            </summary>
        </member>
        <member name="P:GSF.Snap.Encoding.IndividualEncodingBase`1.UsesPreviousValue">
            <summary>
            Gets if the previous value will need to be presented to the encoding algorithms to
            property encode the next sample. Returning false will cause nulls to be passed
            in a parameters to the encoding.
            </summary>
        </member>
        <member name="P:GSF.Snap.Encoding.IndividualEncodingBase`1.MaxCompressionSize">
            <summary>
            Gets the maximum amount of space that is required for the compression algorithm. This
            prevents lower levels from having overflows on the underlying streams. It is critical
            that this value be correct. Error on the side of too large of a value as a value
            too small will corrupt data and be next to impossible to track down the point of corruption
            </summary>
        </member>
        <member name="M:GSF.Snap.Encoding.IndividualEncodingBase`1.Encode(GSF.IO.BinaryStreamBase,`0,`0)">
            <summary>
            Encodes <see cref="!:value"/> to the provided <see cref="!:stream"/>.
            </summary>
            <param name="stream">where to write the data</param>
            <param name="prevValue">the previous value if required by <see cref="P:GSF.Snap.Encoding.IndividualEncodingBase`1.UsesPreviousValue"/>. Otherwise null.</param>
            <param name="value">the value to encode</param>
            <returns>the number of bytes necessary to encode this key/value.</returns>
        </member>
        <member name="M:GSF.Snap.Encoding.IndividualEncodingBase`1.Decode(GSF.IO.BinaryStreamBase,`0,`0,System.Boolean@)">
            <summary>
            Decodes <see cref="!:value"/> from the provided <see cref="!:stream"/>.
            </summary>
            <param name="stream">where to read the data</param>
            <param name="prevValue">the previous value if required by <see cref="P:GSF.Snap.Encoding.IndividualEncodingBase`1.UsesPreviousValue"/>. Otherwise null.</param>
            <param name="value">the place to store the decoded value</param>
            <param name="isEndOfStream">outputs true if the end of the stream symbol is detected. Not all encoding methods have an end of stream symbol and therefore will always return false.</param>
            <returns>the number of bytes necessary to decode the next key/value.</returns>
        </member>
        <member name="M:GSF.Snap.Encoding.IndividualEncodingBase`1.Encode(System.Byte*,`0,`0)">
            <summary>
            Encodes <see cref="!:value"/> to the provided <see cref="!:stream"/>.
            </summary>
            <param name="stream">where to write the data</param>
            <param name="prevValue">the previous value if required by <see cref="P:GSF.Snap.Encoding.IndividualEncodingBase`1.UsesPreviousValue"/>. Otherwise null.</param>
            <param name="value">the value to encode</param>
            <returns>the number of bytes necessary to encode this key/value.</returns>
        </member>
        <member name="M:GSF.Snap.Encoding.IndividualEncodingBase`1.Decode(System.Byte*,`0,`0,System.Boolean@)">
            <summary>
            Decodes <see cref="!:value"/> from the provided <see cref="!:stream"/>.
            </summary>
            <param name="stream">where to read the data</param>
            <param name="prevValue">the previous value if required by <see cref="P:GSF.Snap.Encoding.IndividualEncodingBase`1.UsesPreviousValue"/>. Otherwise null.</param>
            <param name="value">the place to store the decoded value</param>
            <param name="isEndOfStream">outputs true if the end of the stream symbol is detected. Not all encoding methods have an end of stream symbol and therefore will always return false.</param>
            <returns>the number of bytes necessary to decode the next key/value.</returns>
        </member>
        <member name="M:GSF.Snap.Encoding.IndividualEncodingBase`1.Clone">
            <summary>
            Clones this encoding method.
            </summary>
            <returns>A clone</returns>
        </member>
        <member name="T:GSF.Snap.Encoding.EncodingLibrary">
            <summary>
            Contains all of the fundamental encoding methods. Types implementing <see cref="T:GSF.Snap.SnapTypeBase`1"/>
            will automatically register when passed to one of the child methods. 
            </summary>
        </member>
        <member name="M:GSF.Snap.Encoding.EncodingLibrary.Register(GSF.Snap.Definitions.IndividualEncodingDefinitionBase)">
            <summary>
            Registers the provided type in the encoding library.
            </summary>
            <param name="encoding">the encoding to register</param>
        </member>
        <member name="M:GSF.Snap.Encoding.EncodingLibrary.Register(GSF.Snap.Definitions.PairEncodingDefinitionBase)">
            <summary>
            Registers the provided type in the encoding library.
            </summary>
            <param name="encoding">the encoding to register</param>
        </member>
        <member name="M:GSF.Snap.Encoding.EncodingLibrary.GetEncodingMethod``1(System.Guid)">
            <summary>
            Gets the single encoding method if it exists in the database.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="encodingMethod"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Encoding.EncodingLibrary.GetEncodingMethod``2(GSF.Snap.EncodingDefinition)">
            <summary>
            Gets the Double encoding method
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="encodingMethod"></param>
            <returns></returns>
        </member>
        <member name="T:GSF.Snap.Definitions.PairEncodingDefinitionBase">
            <summary>
            The class that is used to construct an encoding method.
            </summary>
        </member>
        <member name="P:GSF.Snap.Definitions.PairEncodingDefinitionBase.KeyTypeIfNotGeneric">
            <summary>
            The key type supported by the encoded method. Can be null if the encoding is not type specific.
            </summary>
        </member>
        <member name="P:GSF.Snap.Definitions.PairEncodingDefinitionBase.ValueTypeIfNotGeneric">
            <summary>
            The value type supported by the encoded method. Can be null if the encoding is not type specific.
            </summary>
        </member>
        <member name="P:GSF.Snap.Definitions.PairEncodingDefinitionBase.Method">
            <summary>
            The encoding method that defines this class.
            </summary>
        </member>
        <member name="M:GSF.Snap.Definitions.PairEncodingDefinitionBase.Create``2">
            <summary>
            Constructs a new class based on this encoding method. 
            </summary>
            <typeparam name="TKey">The key for this encoding method</typeparam>
            <typeparam name="TValue">The value for this encoding method</typeparam>
            <returns>The encoding method</returns>
        </member>
        <member name="T:GSF.Snap.Definitions.SeekFilterDefinitionBase">
            <summary>
            Has the ability to create a filter based on the key and the value.
            </summary>
        </member>
        <member name="P:GSF.Snap.Definitions.SeekFilterDefinitionBase.FilterType">
            <summary>
            The filter guid 
            </summary>
        </member>
        <member name="M:GSF.Snap.Definitions.SeekFilterDefinitionBase.Create``1(GSF.IO.BinaryStreamBase)">
            <summary>
            Determines if a Key/Value is contained in the filter
            </summary>
            <param name="stream">the value to check</param>
            <returns></returns>
        </member>
        <member name="T:GSF.Snap.Definitions.MatchFilterDefinitionBase">
            <summary>
            Has the ability to create a filter based on the key and the value.
            </summary>
        </member>
        <member name="P:GSF.Snap.Definitions.MatchFilterDefinitionBase.FilterType">
            <summary>
            The filter guid 
            </summary>
        </member>
        <member name="M:GSF.Snap.Definitions.MatchFilterDefinitionBase.Create``2(GSF.IO.BinaryStreamBase)">
            <summary>
            Determines if a Key/Value is contained in the filter
            </summary>
            <param name="stream">the value to check</param>
            <returns></returns>
        </member>
        <member name="T:GSF.Snap.Definitions.IndividualEncodingDefinitionBase">
            <summary>
            The class that is used to construct an encoding method.
            </summary>
        </member>
        <member name="P:GSF.Snap.Definitions.IndividualEncodingDefinitionBase.TypeIfNotGeneric">
            <summary>
            The type supported by the encoded method. Can be null if the encoding is not type specific.
            </summary>
        </member>
        <member name="P:GSF.Snap.Definitions.IndividualEncodingDefinitionBase.Method">
            <summary>
            The encoding method as specified by a <see cref="T:System.Guid"/>.
            </summary>
        </member>
        <member name="M:GSF.Snap.Definitions.IndividualEncodingDefinitionBase.Create``1">
            <summary>
            Constructs a new class based on this encoding method. 
            </summary>
            <typeparam name="T">The type of this base class</typeparam>
            <returns>
            The encoding method
            </returns>
        </member>
        <member name="T:GSF.Snap.Streaming.StreamEncodingGeneric`2">
            <summary>
            Allows any generic encoding definition to be wrapped to support stream encoding.
            </summary>
            <typeparam name="TKey">the type of the key</typeparam>
            <typeparam name="TValue">the type of the value</typeparam>
        </member>
        <member name="M:GSF.Snap.Streaming.StreamEncodingGeneric`2.#ctor(GSF.Snap.EncodingDefinition)">
            <summary>
            Creates a new <see cref="T:GSF.Snap.Streaming.StreamEncodingGeneric`2"/> based on the supplied <see cref="!:encodingMethod"/>
            </summary>
            <param name="encodingMethod">the encoding method to use for the streaming</param>
        </member>
        <member name="P:GSF.Snap.Streaming.StreamEncodingGeneric`2.EncodingMethod">
            <summary>
            Gets the definition of the encoding used.
            </summary>
        </member>
        <member name="M:GSF.Snap.Streaming.StreamEncodingGeneric`2.WriteEndOfStream(GSF.IO.BinaryStreamBase)">
            <summary>
            Writes the end of the stream symbol to the <see cref="!:stream"/>.
            </summary>
            <param name="stream">the stream to write to</param>
        </member>
        <member name="M:GSF.Snap.Streaming.StreamEncodingGeneric`2.Encode(GSF.IO.BinaryStreamBase,`0,`1)">
            <summary>
            Encodes the current key/value to the stream.
            </summary>
            <param name="stream">the stream to write to</param>
            <param name="currentKey">the key to write</param>
            <param name="currentValue">the value to write</param>
        </member>
        <member name="M:GSF.Snap.Streaming.StreamEncodingGeneric`2.TryDecode(GSF.IO.BinaryStreamBase,`0,`1)">
            <summary>
            Attempts to read the next point from the stream. 
            </summary>
            <param name="stream">The stream to read from</param>
            <param name="key">the key to store the value to</param>
            <param name="value">the value to store to</param>
            <returns>True if successful. False if end of the stream has been reached.</returns>
        </member>
        <member name="M:GSF.Snap.Streaming.StreamEncodingGeneric`2.ResetEncoder">
            <summary>
            Resets the encoder. Some encoders maintain streaming state data that should
            be reset when reading from a new stream.
            </summary>
        </member>
        <member name="T:GSF.Snap.Streaming.StreamEncodingBase`2">
            <summary>
            Encoding that is stream based. This encoding is similar to <see cref="T:GSF.Snap.Encoding.PairEncodingBase`2"/>
            except it contains end of stream data.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="P:GSF.Snap.Streaming.StreamEncodingBase`2.EncodingMethod">
            <summary>
            Gets the definition of the encoding used.
            </summary>
        </member>
        <member name="M:GSF.Snap.Streaming.StreamEncodingBase`2.WriteEndOfStream(GSF.IO.BinaryStreamBase)">
            <summary>
            Writes the end of the stream symbol to the <see cref="!:stream"/>.
            </summary>
            <param name="stream">the stream to write to</param>
        </member>
        <member name="M:GSF.Snap.Streaming.StreamEncodingBase`2.Encode(GSF.IO.BinaryStreamBase,`0,`1)">
            <summary>
            Encodes the current key/value to the stream.
            </summary>
            <param name="stream">the stream to write to</param>
            <param name="currentKey">the key to write</param>
            <param name="currentValue">the value to write</param>
        </member>
        <member name="M:GSF.Snap.Streaming.StreamEncodingBase`2.TryDecode(GSF.IO.BinaryStreamBase,`0,`1)">
            <summary>
            Attempts to read the next point from the stream. 
            </summary>
            <param name="stream">The stream to read from</param>
            <param name="key">the key to store the value to</param>
            <param name="value">the value to store to</param>
            <returns>True if successful. False if end of the stream has been reached.</returns>
        </member>
        <member name="M:GSF.Snap.Streaming.StreamEncodingBase`2.ResetEncoder">
            <summary>
            Resets the encoder. Some encoders maintain streaming state data that should
            be reset when reading from a new stream.
            </summary>
        </member>
        <member name="T:GSF.Snap.IDatabaseReader`2">
            <summary>
            An interface that is necessary for many of the transformations inside the SortedTreeStore to function.
            </summary>
            <typeparam name="TKey">A key type supported by the SortedTreeStore</typeparam>
            <typeparam name="TValue">A value type supported by the SortedTreeStore</typeparam>
        </member>
        <member name="M:GSF.Snap.IDatabaseReader`2.Read(GSF.Snap.Services.Reader.SortedTreeEngineReaderOptions,GSF.Snap.Filters.SeekFilterBase{`0},GSF.Snap.Filters.MatchFilterBase{`0,`1})">
            <summary>
            Reads data from the SortedTreeEngine with the provided read options and server side filters.
            </summary>
            <param name="readerOptions">read options supplied to the reader. Can be null.</param>
            <param name="keySeekFilter">a seek based filter to follow. Can be null.</param>
            <param name="keyMatchFilter">a match based filer to follow. Can be null.</param>
            <returns>A stream that will read the specified data.</returns>
        </member>
        <member name="T:GSF.Snap.Storage.SortedTreeFileSimpleWriter`2">
            <summary>
            Will write a file.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeFileSimpleWriter`2.Create(System.String,System.String,System.Int32,System.Action{System.Guid},GSF.Snap.EncodingDefinition,GSF.Snap.TreeStream{`0,`1},System.Guid[])">
            <summary>
            Creates a new arhive file with the supplied data.
            </summary>
            <param name="pendingFileName"></param>
            <param name="completeFileName"></param>
            <param name="blockSize"></param>
            <param name="treeNodeType"></param>
            <param name="treeStream"></param>
            <param name="flags"></param>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeFileSimpleWriter`2.GetFileName">
            <summary>
            Helper method. Creates the <see cref="T:GSF.IO.FileStructure.SubFileName"/> for the default table.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <returns></returns>
        </member>
        <member name="T:GSF.Snap.Storage.SortedTreeTableEditor`2">
            <summary>
            A single instance editor that is used
            to modifiy an archive file.
            </summary>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeTableEditor`2.Dispose">
            <summary>
            Releases all the resources used by the <see cref="T:GSF.Snap.Storage.SortedTreeTableEditor`2"/> object.
            </summary>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeTableEditor`2.Commit">
            <summary>
            Commits the edits to the current archive file and disposes of this class.
            </summary>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeTableEditor`2.Rollback">
            <summary>
            Rolls back all edits that are made to the archive file and disposes of this class.
            </summary>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeTableEditor`2.GetKeyRange(`0,`0)">
            <summary>
            Gets the lower and upper bounds of this tree.
            </summary>
            <param name="firstKey">The first key in the tree</param>
            <param name="lastKey">The final key in the tree</param>
            <remarks>
            If the tree contains no data. <see cref="!:firstKey"/> is set to it's maximum value
            and <see cref="!:lastKey"/> is set to it's minimum value.
            </remarks>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeTableEditor`2.AddPoint(`0,`1)">
            <summary>
            Adds a single point to the archive file.
            </summary>
            <param name="key">The key</param>
            <param name="value">the value</param>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeTableEditor`2.AddPoints(GSF.Snap.TreeStream{`0,`1})">
            <summary>
            Adds all of the points to this archive file.
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeTableEditor`2.GetRange">
            <summary>
            Opens a tree scanner for this archive file
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeTableEditor`2.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:GSF.Snap.Storage.SortedTreeTableEditor`2"/> object and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="T:GSF.Snap.Storage.FileFlags">
            <summary>
            A set of flags that are in the archive files.
            </summary>
        </member>
        <member name="M:GSF.Snap.Storage.FileFlags.GetStage(System.Int32)">
            <summary>
            Gets the flag associated with the supplied stage
            </summary>
            <param name="stageNumber">The stage number, must be between 0 and 9 inclusive.</param>
            <returns></returns>
        </member>
        <member name="F:GSF.Snap.Storage.FileFlags.Stage0">
            <summary>
            Indicates that the file is in Stage 0. These files are in memory only and not compressed.
            These files may be created multiple times per second, but typically are incrementally added to 10-100 times per second.
            </summary>
        </member>
        <member name="F:GSF.Snap.Storage.FileFlags.Stage1">
            <summary>
            Indicates that the file is in Stage 1. These files usually have been written to the disk, and they are compressed.
            </summary>
        </member>
        <member name="F:GSF.Snap.Storage.FileFlags.Stage2">
            <summary>
            Indicates that the file is in Stage 2. 
            </summary>
        </member>
        <member name="F:GSF.Snap.Storage.FileFlags.Stage3">
            <summary>
            Indicates that the file is in Stage 3. 
            </summary>
        </member>
        <member name="F:GSF.Snap.Storage.FileFlags.Stage4">
            <summary>
            Indicates that the file is in Stage 4. 
            </summary>
        </member>
        <member name="F:GSF.Snap.Storage.FileFlags.Stage5">
            <summary>
            Indicates that the file is in Stage 5. 
            </summary>
        </member>
        <member name="F:GSF.Snap.Storage.FileFlags.Stage6">
            <summary>
            Indicates that the file is in Stage 6. 
            </summary>
        </member>
        <member name="F:GSF.Snap.Storage.FileFlags.Stage7">
            <summary>
            Indicates that the file is in Stage 7. 
            </summary>
        </member>
        <member name="F:GSF.Snap.Storage.FileFlags.Stage8">
            <summary>
            Indicates that the file is in Stage 8. 
            </summary>
        </member>
        <member name="F:GSF.Snap.Storage.FileFlags.Stage9">
            <summary>
            Indicates that the file is in Stage 9.
            </summary>
        </member>
        <member name="F:GSF.Snap.Storage.FileFlags.ManualRollover">
            <summary>
            Indicates that the user requested this file to be rolled over, and therefore it should not be automatically recombined.
            </summary>
        </member>
        <member name="F:GSF.Snap.Storage.FileFlags.IntermediateFile">
            <summary>
            Indicates that this is an intermediate file that can still be automatically rolled over.
            </summary>
        </member>
        <member name="T:GSF.Snap.Storage.SortedTreeTable`2">
            <summary>
            Represents an individual table contained within the file. 
            </summary>
        </member>
        <member name="P:GSF.Snap.Storage.SortedTreeTable`2.BaseFile">
            <summary>
            Gets the archive file where this table exists.
            </summary>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeTable`2.#ctor(GSF.IO.FileStructure.TransactionalFileStructure,GSF.IO.FileStructure.SubFileName,GSF.Snap.Storage.SortedTreeFile)">
            <summary>
            Creates a SortedTreeTable
            </summary>
            <param name="fileStructure"></param>
            <param name="fileName"></param>
            <param name="baseFile"></param>
        </member>
        <member name="P:GSF.Snap.Storage.SortedTreeTable`2.IsDisposed">
            <summary>
            Determines if the archive file has been disposed. 
            </summary>
        </member>
        <member name="P:GSF.Snap.Storage.SortedTreeTable`2.FirstKey">
            <summary>
            The first key.  Note: Values only update on commit.
            </summary>
        </member>
        <member name="P:GSF.Snap.Storage.SortedTreeTable`2.LastKey">
            <summary>
            The last key.  Note: Values only update on commit.
            </summary>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeTable`2.AcquireReadSnapshot">
            <summary>
            Acquires a read snapshot of the current archive file.
            </summary>
            <returns></returns>
            <remarks>
            Once the snapshot has been acquired, any future commits
            will not effect this snapshot. The snapshot has a tiny footprint
            and allows an unlimited number of reads that can be created.
            </remarks>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeTable`2.BeginRead">
            <summary>
            Allows the user to get a read snapshot on the table.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeTable`2.BeginEdit">
            <summary>
            Begins an edit of the current archive table.
            </summary>
            <remarks>
            Concurrent editing of a file is not supported. Subsequent calls will
            throw an exception rather than blocking. This is to encourage
            proper synchronization at a higher layer. 
            Wrap the return value of this function in a Using block so the dispose
            method is always called. 
            </remarks>
            <example>
            using (ArchiveFile.ArchiveFileEditor editor = archiveFile.BeginEdit())
            {
                editor.AddPoint(key, value);
                editor.AddPoint(key, value);
                editor.Commit();
            }
            </example>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeTable`2.Dispose">
            <summary>
            Closes the archive file. If there is a current transaction, 
            that transaction is immediately rolled back and disposed.
            </summary>
        </member>
        <member name="T:GSF.Snap.Storage.SortedTreeTable`2.Editor">
            <summary>
            A single instance editor that is used
            to modifiy an archive file.
            </summary>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeTable`2.Editor.Commit">
            <summary>
            Commits the edits to the current archive file and disposes of this class.
            </summary>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeTable`2.Editor.Rollback">
            <summary>
            Rolls back all edits that are made to the archive file and disposes of this class.
            </summary>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeTable`2.Editor.GetKeyRange(`0,`0)">
            <summary>
            Gets the lower and upper bounds of this tree.
            </summary>
            <param name="firstKey">The first key in the tree</param>
            <param name="lastKey">The final key in the tree</param>
            <remarks>
            If the tree contains no data. <see cref="!:firstKey"/> is set to it's maximum value
            and <see cref="!:lastKey"/> is set to it's minimum value.
            </remarks>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeTable`2.Editor.AddPoint(`0,`1)">
            <summary>
            Adds a single point to the archive file.
            </summary>
            <param name="key">The key</param>
            <param name="value">the value</param>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeTable`2.Editor.AddPoints(GSF.Snap.TreeStream{`0,`1})">
            <summary>
            Adds all of the points to this archive file.
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeTable`2.Editor.GetRange">
            <summary>
            Opens a tree scanner for this archive file
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeTable`2.Editor.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:GSF.Snap.Storage.SortedTreeTable`2.Editor"/> object and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="T:GSF.Snap.Storage.SortedTreeTableReadSnapshot`2">
            <summary>
            Provides a user with a read-only instance of an archive.
            This class is not thread safe.
            </summary>
        </member>
        <member name="P:GSF.Snap.Storage.SortedTreeTableReadSnapshot`2.IsDisposed">
            <summary>
            Determines if this read snapshot has been disposed.
            </summary>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeTableReadSnapshot`2.GetTreeScanner">
            <summary>
            Gets a reader that can be used to parse an archive file.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeTableReadSnapshot`2.GetKeyRange(`0,`0)">
            <summary>
            Returns the lower and upper bounds of the tree
            </summary>
            <param name="lowerBounds">the first key in the tree</param>
            <param name="upperBounds">the last key in the tree</param>
            <remarks>
            If the tree is empty, lowerBounds will be greater than upperBounds</remarks>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeTableReadSnapshot`2.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:GSF.Snap.Storage.SortedTreeTableSnapshotInfo`2">
            <summary>
            Aquires a read transaction on the current archive partition. This will allow all user created
            transactions to have snapshot isolation of the entire data set.
            </summary>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeTableSnapshotInfo`2.CreateReadSnapshot">
            <summary>
            Opens an instance of the archive file to allow for concurrent reading of a snapshot.
            </summary>
            <returns></returns>
        </member>
        <member name="T:GSF.Snap.Storage.SortedTreeFile">
            <summary>
            Represents a individual self-contained archive file. 
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="F:GSF.Snap.Storage.SortedTreeFile.FileType">
            <summary>
            The main type of the archive file.
            </summary>
        </member>
        <member name="F:GSF.Snap.Storage.SortedTreeFile.PrimaryArchiveType">
            <summary>
            The guid where the primary archive component exists
            </summary>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeFile.CreateInMemory(System.Int32,System.Guid[])">
            <summary>
            Creates a new in memory archive file.
            </summary>
            <param name="blockSize">The number of bytes per block in the file.</param>
            <param name="flags">Flags to write to the file</param>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeFile.CreateFile(System.String,System.Int32,System.Guid[])">
            <summary>
            Creates an archive file.
            </summary>
            <param name="file">the path for the file.</param>
            <param name="blockSize">The number of bytes per block in the file.</param>
            <param name="flags">Flags to write to the file</param>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeFile.OpenFile(System.String,System.Boolean)">
            <summary>
            Opens an archive file.
            </summary>
            <param name="file"></param>
            <param name="isReadOnly"></param>
            <returns></returns>
        </member>
        <member name="P:GSF.Snap.Storage.SortedTreeFile.IsDisposed">
            <summary>
            Determines if the archive file has been disposed. 
            </summary>
        </member>
        <member name="P:GSF.Snap.Storage.SortedTreeFile.FilePath">
            <summary>
            Returns the name of the file.  Returns <see cref="F:System.String.Empty"/> if this is a memory archive.
            This is the name of the entire path.
            </summary>
        </member>
        <member name="P:GSF.Snap.Storage.SortedTreeFile.IsMemoryFile">
            <summary>
            Gets if the file is a memory file.
            </summary>
        </member>
        <member name="P:GSF.Snap.Storage.SortedTreeFile.FileName">
            <summary>
            Gets the name of the file, but only the file, not the entire path.
            </summary>
        </member>
        <member name="P:GSF.Snap.Storage.SortedTreeFile.Snapshot">
            <summary>
            Gets the last committed read snapshot on the file system.
            </summary>
            <returns></returns>
        </member>
        <member name="P:GSF.Snap.Storage.SortedTreeFile.ArchiveSize">
            <summary>
            Gets the size of the file.
            </summary>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeFile.ChangeExtension(System.String,System.Boolean,System.Boolean)">
            <summary>
            Changes the extension of the current file.
            </summary>
            <param name="extension">the new extension</param>
            <param name="isReadOnly">If the file should be reopened as readonly</param>
            <param name="isSharingEnabled">If the file should share read privileges.</param>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeFile.ChangeShareMode(System.Boolean,System.Boolean)">
            <summary>
            Reopens the file with different permissions.
            </summary>
            <param name="isReadOnly">If the file should be reopened as readonly</param>
            <param name="isSharingEnabled">If the file should share read privileges.</param>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeFile.OpenTable``2">
            <summary>
            Opens the default table for this TKey and TValue. 
            </summary>
            <typeparam name="TKey">The key</typeparam>
            <typeparam name="TValue">The value</typeparam>
            <remarks>
            Every Key and Value have their uniquely mapped file, therefore a different file is opened if TKey and TValue are different.
            </remarks>
            <returns>null if table does not exist</returns>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeFile.OpenTable``2(System.String)">
            <summary>
            Opens the default table for this TKey and TValue. 
            </summary>
            <typeparam name="TKey">The key</typeparam>
            <typeparam name="TValue">The value</typeparam>
            <param name="tableName">the name of an internal table</param>
            <remarks>
            Every Key and Value have their uniquely mapped file, therefore a different file is opened if TKey and TValue are different.
            </remarks>
            <returns>null if table does not exist</returns>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeFile.OpenTable``2(GSF.IO.FileStructure.SubFileName)">
            <summary>
            Opens the table for the provided file name.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="fileName">the filename to open</param>
            <returns>null if table does not exist</returns>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeFile.OpenOrCreateTable``2(GSF.Snap.EncodingDefinition,System.String,System.Int32)">
            <summary>
            Opens the default table for this TKey and TValue. If it does not exists, 
            it will be created with the provided compression method.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="storageMethod">The method of compression to utilize in this table.</param>
            <param name="maxSortedTreeBlockSize">the maximum desired block size for a SortedTree. Must be at least 1024.</param>
            <param name="tableName">the name of an internal table</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeFile.OpenOrCreateTable``2(GSF.Snap.EncodingDefinition,System.Int32)">
            <summary>
            Opens the default table for this TKey and TValue. If it does not exists, 
            it will be created with the provided compression method.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="storageMethod">The method of compression to utilize in this table.</param>
            <param name="maxSortedTreeBlockSize">the maximum desired block size for a SortedTree. Must be at least 1024.</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeFile.GetFileName``2">
            <summary>
            Helper method. Creates the <see cref="T:GSF.IO.FileStructure.SubFileName"/> for the default table.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeFile.Dispose">
            <summary>
            Closes the archive file. If there is a current transaction, 
            that transaction is immediately rolled back and disposed.
            </summary>
        </member>
        <member name="M:GSF.Snap.Storage.SortedTreeFile.Delete">
            <summary>
            Closes and deletes the Archive File. Also calls dispose.
            If this is a memory archive, it will release the memory space to the buffer pool.
            </summary>
        </member>
        <member name="T:GSF.Snap.Tree.KeyValueMethods">
            <summary>
            Allows combined operations on key/value methods. If a substantial amount of copying is occuring,
            overriding this method to support the specific copy can make things faster.
            </summary>
        </member>
        <member name="P:GSF.Snap.Tree.KeyValueMethods.KeyType">
            <summary>
            The type of the key
            </summary>
        </member>
        <member name="P:GSF.Snap.Tree.KeyValueMethods.ValueType">
            <summary>
            The type of the value
            </summary>
        </member>
        <member name="T:GSF.Snap.Tree.KeyValueMethods`2">
            <summary>
            Allows combined operations on key/value methods. If a substantial amount of copying is occuring,
            overriding this method to support the specific copy can make things faster.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:GSF.Snap.Tree.KeyValueMethods`2.Copy(`0,`1,`0,`1)">
            <summary>
            Copies the source values to the destination.
            </summary>
            <param name="srcKey"></param>
            <param name="srcValue"></param>
            <param name="destKey"></param>
            <param name="dstValue"></param>
        </member>
        <member name="P:GSF.Snap.Tree.KeyValueMethods`2.KeyType">
            <summary>
            The type of the key
            </summary>
        </member>
        <member name="P:GSF.Snap.Tree.KeyValueMethods`2.ValueType">
            <summary>
            The type of the value
            </summary>
        </member>
        <member name="T:GSF.Snap.Tree.Specialized.NodeHeader`1">
            <summary>
            Contains basic data about a node in the SortedTree.
            </summary>
            <typeparam name="TKey">The key that the SortedTree contains.</typeparam>
        </member>
        <member name="F:GSF.Snap.Tree.Specialized.NodeHeader`1.Version">
            <summary>
            Header data
            </summary>
        </member>
        <member name="M:GSF.Snap.Tree.Specialized.NodeHeader`1.#ctor(System.Byte,System.Int32)">
            <summary>
            The constructor that is used for inheriting. Must call Initialize before using it.
            </summary>
            <param name="level"></param>
            <param name="blockSize"></param>
        </member>
        <member name="P:GSF.Snap.Tree.Specialized.NodeHeader`1.OffsetOfUpperBounds">
            <summary>
            Gets the byte offset of the upper bounds key
            </summary>
        </member>
        <member name="P:GSF.Snap.Tree.Specialized.NodeHeader`1.HeaderSize">
            <summary>
            Gets the byte offset of the header size.
            </summary>
        </member>
        <member name="P:GSF.Snap.Tree.Specialized.NodeHeader`1.RemainingBytes">
            <summary>
            Gets/Sets the number of unused bytes in the node.
            </summary>
        </member>
        <member name="T:GSF.Snap.Tree.Specialized.NodeWriter`2">
            <summary>
            A class to write data to a node in sequential order only.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:GSF.Snap.Tree.Specialized.NodeWriter`2.NewNodeThenInsert(GSF.Snap.Tree.Specialized.NodeHeader{`0},GSF.Snap.Tree.Specialized.SparseIndexWriter{`0},System.UInt32,System.Byte*,`0)">
            <summary>
            Closes the current node and prepares a new node with the supplied key.
            </summary>
            <param name="sparseIndex"></param>
            <param name="newNodeIndex">the index for the next node.</param>
            <param name="writePointer">the pointer to the start of the block</param>
            <param name="key">the key to use.</param>
            <param name="header"></param>
        </member>
        <member name="T:GSF.Snap.Tree.Specialized.SequentialSortedTreeWriter`2">
            <summary>
            A specialized serialization method for writing data to a disk in the SortedTreeStore method.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:GSF.Snap.Tree.Specialized.SequentialSortedTreeWriter`2.Create(GSF.IO.BinaryStreamPointerBase,System.Int32,GSF.Snap.EncodingDefinition,GSF.Snap.TreeStream{`0,`1})">
            <summary>
            Writes the supplied stream to the binary stream.
            </summary>
            <param name="stream"></param>
            <param name="blockSize"></param>
            <param name="treeNodeType"></param>
            <param name="treeStream"></param>
        </member>
        <member name="T:GSF.Snap.Tree.Specialized.SparseIndexWriter`1">
            <summary>
            Contains information on how to parse the index nodes of the SortedTree
            </summary>
        </member>
        <member name="M:GSF.Snap.Tree.Specialized.SparseIndexWriter`1.#ctor">
            <summary>
            Creates a new sparse index. 
            </summary>
        </member>
        <member name="P:GSF.Snap.Tree.Specialized.SparseIndexWriter`1.Count">
            <summary>
            Gets the number of nodes in the sparse index.
            </summary>
        </member>
        <member name="M:GSF.Snap.Tree.Specialized.SparseIndexWriter`1.Add(System.UInt32,`0,System.UInt32)">
            <summary>
            Adds the following node pointer to the sparse index.
            </summary>
            <param name="leftPointer">The pointer to the left element, Only used to prime the list.</param>
            <param name="nodeKey">the first key in the <see cref="!:pointer"/>. Only uses the key portion of the TKeyValue</param>
            <param name="pointer">the index of the later node</param>
            <remarks>This class will add the new node data to the parent node, 
            or create a new root if the current root is split.</remarks>
        </member>
        <member name="F:GSF.Snap.Tree.InsertStreamHelper`2.IsKVP1">
            <summary>
            Determines if Key1 and Value1 are the current keys.
            Otherwise Key1 and Value2 are.
            </summary>
        </member>
        <member name="P:GSF.Snap.Tree.SortedTreeHeader.IsDirty">
            <summary>
            Gets if the sorted tree needs to be flushed to the disk. 
            </summary>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeHeader.LoadHeader(GSF.IO.BinaryStreamBase)">
            <summary>
            Loads the header.
            </summary>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeHeader.SaveHeader(GSF.IO.BinaryStreamBase)">
            <summary>
            Writes the first page of the SortedTree as long as the <see cref="P:GSF.Snap.Tree.SortedTreeHeader.IsDirty"/> flag is set.
            After returning, the IsDirty flag is cleared.
            </summary>
        </member>
        <member name="T:GSF.Snap.Tree.SortedTree">
            <summary>
            A static class for some basic functions of the sortedtree.
            </summary>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTree.ReadHeader(GSF.IO.BinaryStreamBase,GSF.Snap.EncodingDefinition@,System.Int32@)">
            <summary>
            Reads the header data.
            </summary>
            <param name="stream"></param>
            <param name="treeNodeType"></param>
            <param name="blockSize"></param>
        </member>
        <member name="T:GSF.Snap.Tree.FixedSizeNode`2">
            <summary>
            A node for a <see cref="T:GSF.Snap.Tree.SortedTree"/> that is encoded in a fixed width. 
            This allows binary searches and faster writing.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:GSF.Snap.Tree.FixedSizeNode`2.#ctor(System.Byte)">
            <summary>
            Creates a new class
            </summary>
            <param name="level">the level of this node.</param>
        </member>
        <member name="M:GSF.Snap.Tree.FixedSizeNode`2.CreateTreeScanner">
            <summary>
            Returns a <see cref="T:GSF.Snap.Tree.SortedTreeScannerBase`2"/>
            </summary>
            <returns></returns>
        </member>
        <member name="T:GSF.Snap.Tree.FixedSizeNodeScanner`2">
            <summary>
            The treescanner for a fixed size node.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:GSF.Snap.Tree.FixedSizeNodeScanner`2.#ctor(System.Byte,System.Int32,GSF.IO.BinaryStreamPointerBase,System.Func{`0,System.Byte,System.UInt32})">
            <summary>
            creates a new class
            </summary>
            <param name="level"></param>
            <param name="blockSize"></param>
            <param name="stream"></param>
            <param name="lookupKey"></param>
        </member>
        <member name="M:GSF.Snap.Tree.FixedSizeNodeScanner`2.InternalReadWhile(`0,`1,`0)">
            <summary>
            Using <see cref="P:GSF.Snap.Tree.SortedTreeScannerBase`2.Pointer"/> advance to the next KeyValue
            </summary>
        </member>
        <member name="M:GSF.Snap.Tree.FixedSizeNodeScanner`2.InternalReadWhile(`0,`1,`0,GSF.Snap.Filters.MatchFilterBase{`0,`1})">
            <summary>
            Using <see cref="P:GSF.Snap.Tree.SortedTreeScannerBase`2.Pointer"/> advance to the next KeyValue
            </summary>
        </member>
        <member name="M:GSF.Snap.Tree.FixedSizeNodeScanner`2.FindKey(`0)">
            <summary>
            Using <see cref="P:GSF.Snap.Tree.SortedTreeScannerBase`2.Pointer"/> advance to the search location of the provided <see cref="!:key"/>
            </summary>
            <param name="key">the key to advance to</param>
        </member>
        <member name="T:GSF.Snap.Tree.GenericEncodedNode`2">
            <summary>
            A TreeNode abstract class that is used for linearly encoding a class.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:GSF.Snap.Tree.GenericEncodedNode`2.AppendSequentialStream(GSF.Snap.Tree.InsertStreamHelper{`0,`1},System.Boolean@)">
            <summary>
            Requests that the current stream is inserted into the tree. Sequential insertion can only occur while the stream
            is in order and is entirely past the end of the tree. 
            </summary>
            <param name="stream">the stream data to insert</param>
            <param name="isFull">if returning from this function while the node is not yet full, this means the stream 
            can no longer be inserted sequentially and we must break out to the root and insert one at a time.</param>
        </member>
        <member name="M:GSF.Snap.Tree.GenericEncodedNode`2.InsertUnlessFull(System.Int32,`0,`1)">
            <summary>
            Inserts a point before the current position.
            </summary>
            <param name="index"></param>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Tree.GenericEncodedNode`2.SeekTo(`0,System.Byte*)">
            <summary>
            Continue to seek until the end of the list is found or 
            until the <see cref="F:GSF.Snap.Tree.GenericEncodedNode`2.m_currentKey"/> >= <see cref="!:key"/>
            </summary>
            <param name="key"></param>
            <param name="buffer"></param>
        </member>
        <member name="M:GSF.Snap.Tree.GenericEncodedNode`2.SeekTo(System.Int32)">
            <summary>
            Continue to seek until the end of the list is found or 
            until the <see cref="F:GSF.Snap.Tree.GenericEncodedNode`2.m_currentKey"/> >= <see cref="!:key"/>
            </summary>
            <param name="index"></param>
        </member>
        <member name="T:GSF.Snap.Tree.GenericEncodedNodeScanner`2">
            <summary>
            Base class for reading from a node that is encoded and must be read sequentially through the node.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:GSF.Snap.Tree.GenericEncodedNodeScanner`2.#ctor(GSF.Snap.Encoding.PairEncodingBase{`0,`1},System.Byte,System.Int32,GSF.IO.BinaryStreamPointerBase,System.Func{`0,System.Byte,System.UInt32})">
            <summary>
            Creates a new class
            </summary>
            <param name="level"></param>
            <param name="blockSize"></param>
            <param name="stream"></param>
            <param name="lookupKey"></param>
        </member>
        <member name="M:GSF.Snap.Tree.GenericEncodedNodeScanner`2.FindKey(`0)">
            <summary>
            Using <see cref="P:GSF.Snap.Tree.SortedTreeScannerBase`2.Pointer"/> advance to the search location of the provided <see cref="!:key"/>
            </summary>
            <param name="key">the key to advance to</param>
        </member>
        <member name="M:GSF.Snap.Tree.GenericEncodedNodeScanner`2.OnNoadReload">
            <summary>
            Occurs when a node's data is reset.
            Derived classes can override this 
            method if fields need to be reset when a node is loaded.
            </summary>
        </member>
        <member name="T:GSF.Snap.Tree.Node`1">
            <summary>
            Contains basic data about a node in the SortedTree.
            </summary>
            <typeparam name="TKey">The key that the SortedTree contains.</typeparam>
        </member>
        <member name="E:GSF.Snap.Tree.Node`1.NodeIndexChanged">
            <summary>
            Occurs when the node index is changed or cleared.
            </summary>
        </member>
        <member name="M:GSF.Snap.Tree.Node`1.#ctor(System.Byte)">
            <summary>
            The constructor that is used for inheriting. Must call Initialize before using it.
            </summary>
            <param name="level"></param>
        </member>
        <member name="M:GSF.Snap.Tree.Node`1.#ctor(GSF.IO.BinaryStreamPointerBase,System.Int32,System.Byte)">
            <summary>
            The constructor that is to be used to if not inheriting this object. 
            Automatically initializes the node.
            </summary>
            <param name="stream"></param>
            <param name="blockSize"></param>
            <param name="level"></param>
        </member>
        <member name="M:GSF.Snap.Tree.Node`1.InitializeNode(GSF.IO.BinaryStreamPointerBase,System.Int32)">
            <summary>
            Initializes the node. To be called once
            </summary>
            <param name="stream"></param>
            <param name="blockSize"></param>
        </member>
        <member name="P:GSF.Snap.Tree.Node`1.OffsetOfUpperBounds">
            <summary>
            Gets the byte offset of the upper bouds key
            </summary>
        </member>
        <member name="P:GSF.Snap.Tree.Node`1.HeaderSize">
            <summary>
            Gets the byte offset of the header size.
            </summary>
        </member>
        <member name="P:GSF.Snap.Tree.Node`1.NodeIndex">
            <summary>
            Gets the node index of this current node.
            </summary>
        </member>
        <member name="P:GSF.Snap.Tree.Node`1.RecordCount">
            <summary>
            Gets/Sets the number of records in this node.
            </summary>
        </member>
        <member name="P:GSF.Snap.Tree.Node`1.RemainingBytes">
            <summary>
            Gets/Sets the number of unused bytes in the node.
            </summary>
        </member>
        <member name="P:GSF.Snap.Tree.Node`1.ValidBytes">
            <summary>
            The number of bytes that are used in this node.
            </summary>
        </member>
        <member name="M:GSF.Snap.Tree.Node`1.IncrementOneRecord(System.Int32)">
            <summary>
            Modifies both the <see cref="P:GSF.Snap.Tree.Node`1.RecordCount"/> and <see cref="P:GSF.Snap.Tree.Node`1.ValidBytes"/> in one function call.
            </summary>
            <param name="additionalValidBytes">the number of bytes to increase <see cref="P:GSF.Snap.Tree.Node`1.ValidBytes"/> by</param>
        </member>
        <member name="P:GSF.Snap.Tree.Node`1.LeftSiblingNodeIndex">
            <summary>
            The index of the left sibling. <see cref="F:System.UInt32.MaxValue"/> is the null case.
            </summary>
        </member>
        <member name="P:GSF.Snap.Tree.Node`1.RightSiblingNodeIndex">
            <summary>
            The index of the right sibling. <see cref="F:System.UInt32.MaxValue"/> is the null case.
            </summary>
        </member>
        <member name="P:GSF.Snap.Tree.Node`1.IsRightSiblingIndexNull">
            <summary>
            Is the index of the right sibling null. i.e. equal to <see cref="F:System.UInt32.MaxValue"/>
            </summary>
        </member>
        <member name="P:GSF.Snap.Tree.Node`1.IsLeftSiblingIndexNull">
            <summary>
            Is the index of the left sibling null. i.e. equal to <see cref="F:System.UInt32.MaxValue"/>
            </summary>
        </member>
        <member name="P:GSF.Snap.Tree.Node`1.LowerKey">
            <summary>
            The lower bounds of the node. This is an inclusive bounds and always valid.
            </summary>
        </member>
        <member name="P:GSF.Snap.Tree.Node`1.UpperKey">
            <summary>
            The upper bounds of the node. This is an exclusive bounds and is valid 
            when there is a sibling to the right. If there is no sibling to the right,
            it should still be valid except for the maximum key value condition.
            </summary>
        </member>
        <member name="P:GSF.Snap.Tree.Node`1.StartOfDataPosition">
            <summary>
            The position that points to the location right after the header which is the 
            start of the data within the node.
            </summary>
        </member>
        <member name="P:GSF.Snap.Tree.Node`1.NodePosition">
            <summary>
            Gets the first position for the current node.
            </summary>
        </member>
        <member name="M:GSF.Snap.Tree.Node`1.Clear">
            <summary>
            Invalidates the current node.
            </summary>
        </member>
        <member name="M:GSF.Snap.Tree.Node`1.SetNodeIndex(System.UInt32)">
            <summary>
            Sets the node data to the following node index. 
            The node must be initialized before calling this method.
            </summary>
            <param name="nodeIndex"></param>
        </member>
        <member name="M:GSF.Snap.Tree.Node`1.CreateEmptyNode(System.UInt32)">
            <summary>
            Creates an empty node on the provided key. Only use this to create the initial node of the tree. Not necessary for any other calls.
            </summary>
            <param name="newNodeIndex"></param>
        </member>
        <member name="M:GSF.Snap.Tree.Node`1.CreateNewNode(System.UInt32,System.UInt16,System.UInt16,System.UInt32,System.UInt32,`0,`0)">
            <summary>
            Creates a new node with the provided data.
            </summary>
            <param name="nodeIndex"></param>
            <param name="recordCount"></param>
            <param name="validBytes"></param>
            <param name="leftSibling"></param>
            <param name="rightSibling"></param>
            <param name="lowerKey"></param>
            <param name="upperKey"></param>
        </member>
        <member name="M:GSF.Snap.Tree.Node`1.IsKeyInsideBounds(`0)">
            <summary>
            Determines if the <see cref="!:key"/> resides within the bounds of the current node.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Tree.Node`1.SeekToRightSibling">
            <summary>
            Seeks the current node to the right sibling node. Throws an exception if the navigation fails.
            </summary>
        </member>
        <member name="M:GSF.Snap.Tree.Node`1.SeekToLeftSibling">
            <summary>
            Seeks the current node to the left sibling node. Throws an exception if the navigation fails.
            </summary>
        </member>
        <member name="M:GSF.Snap.Tree.Node`1.SetLeftSiblingProperty(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            This function is a special purpose function to set the right sibling of an internal node.
            It is used by Split
            </summary>
            <param name="oldValue"></param>
            <param name="newValue"></param>
            <param name="nodeIndex"></param>
        </member>
        <member name="M:GSF.Snap.Tree.Node`1.GetValidBytes(System.UInt32)">
            <summary>
            Gets the number of valid bytes of the foreign <see cref="!:nodeIndex"/> without seeking this current node to it.
            </summary>
            <param name="nodeIndex">the node to use</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Tree.Node`1.GetReadPointer">
            <summary>
            Gets a read compatible pointer of the current node.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Tree.Node`1.GetReadPointerAfterHeader">
            <summary>
            Gets the pointer after the header.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Tree.Node`1.GetWritePointer">
            <summary>
            Gets a write compatible pointer for the current node.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Tree.Node`1.GetWritePointerAfterHeader">
            <summary>
            Gets the pointer after the header.
            </summary>
            <returns></returns>
        </member>
        <member name="T:GSF.Snap.Tree.SortedTree`2">
            <summary>
            Provides the basic user methods with any derived B+Tree.  
            This base class translates all of the core methods into simple methods
            that must be implemented by classes derived from this base class.
            </summary>
            <remarks>
            This class does not support concurrent read operations.  This is due to the caching method of each tree.
            If concurrent read operations are desired, clone the tree.  
            Trees cannot be cloned if the user plans to write to the tree.
            </remarks>
        </member>
        <member name="P:GSF.Snap.Tree.SortedTree`2.IsDirty">
            <summary>
            Gets if the sorted tree needs to be flushed to the disk. 
            </summary>
        </member>
        <member name="P:GSF.Snap.Tree.SortedTree`2.AutoFlush">
            <summary>
            The sorted tree will not continuely call the <see cref="M:GSF.Snap.Tree.SortedTree`2.Flush"/> method every time the header is changed.
            When setting this to false, flushes must be manually invoked. Failing to do this can corrupt the SortedTree. 
            Only set if you can gaurentee that <see cref="M:GSF.Snap.Tree.SortedTree`2.Flush"/> will be called before disposing this class.
            </summary>
        </member>
        <member name="P:GSF.Snap.Tree.SortedTree`2.BlockSize">
            <summary>
            Contains the block size that the tree nodes will be alligned on.
            </summary>
        </member>
        <member name="P:GSF.Snap.Tree.SortedTree`2.Stream">
            <summary>
            Contains the stream for reading and writing.
            </summary>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTree`2.Flush">
            <summary>
            Flushes any header data that may have changed to the main stream.
            </summary>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTree`2.SetDirtyFlag">
            <summary>
            Sets a flag that requires that the header data is no longer valid.
            </summary>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTree`2.Add(`0,`1)">
            <summary>
            Adds the provided key/value to the Tree.
            </summary>
            <param name="key">the key to add</param>
            <param name="value">the value to add</param>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTree`2.TryAdd(`0,`1)">
            <summary>
            Attempts to add the provided key/value to the Tree.
            </summary>
            <param name="key">the key to add</param>
            <param name="value">the value to add</param>
            <returns>returns true if successful, false if a duplicate key was found</returns>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTree`2.AddRange(GSF.Snap.TreeStream{`0,`1})">
            <summary>
            Adds all of the points in the stream to the Tree
            </summary>
            <param name="stream">stream to add</param>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTree`2.TryAddRange(GSF.Snap.TreeStream{`0,`1})">
            <summary>
            Adds all of the items in the stream to this tree. Skips any dulpicate entries.
            </summary>
            <param name="stream">the stream to add.</param>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTree`2.TryRemove(`0)">
            <summary>
            Tries to remove the following key from the tree.
            </summary>
            <param name="key">the key to remove</param>
            <returns>true if successful, false otherwise.</returns>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTree`2.Get(`0,`1)">
            <summary>
            Gets the following key from the Tree. Assignes to the value.
            </summary>
            <param name="key">the key to look for</param>
            <param name="value">the place to store the value</param>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTree`2.TryGet(`0,`1)">
            <summary>
            Attempts to get the following key from the Tree. Assigns to the value.
            </summary>
            <param name="key">the key to look for</param>
            <param name="value">the place to store the value</param>
            <returns>True if successful, False otherwise.</returns>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTree`2.GetKeyRange(`0,`0)">
            <summary>
            Gets the lower and upper bounds of this tree.
            </summary>
            <param name="lowerBounds">The first key in the tree</param>
            <param name="upperBounds">The final key in the tree</param>
            <remarks>
            If the tree contains no data. <see cref="!:lowerBounds"/> is set to it's maximum value
            and <see cref="!:upperBounds"/> is set to it's minimum value.
            </remarks>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTree`2.CreateTreeScanner">
            <summary>
            Creates a tree scanner that can be used to seek this tree.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTree`2.GetNextNewNodeIndex">
            <summary>
            Returns the node index address for a freshly allocated block.
            </summary>
            <returns></returns>
            <remarks>Also saves the header data</remarks>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTree`2.Open(GSF.IO.BinaryStreamPointerBase)">
            <summary>
            Opens a sorted tree using the provided stream.
            </summary>
            <param name="stream">the stream to use to open.</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTree`2.Create(GSF.IO.BinaryStreamPointerBase,System.Int32)">
            <summary>
            Creates a new FixedSize SortedTree using the provided stream.
            </summary>
            <param name="stream"></param>
            <param name="blockSize"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTree`2.Create(GSF.IO.BinaryStreamPointerBase,System.Int32,GSF.Snap.EncodingDefinition)">
            <summary>
            Creates a new SortedTree writing to the provided streams and using the specified compression method for the tree node.
            </summary>
            <param name="stream"></param>
            <param name="blockSize"></param>
            <param name="treeNodeType"></param>
            <returns></returns>
        </member>
        <member name="T:GSF.Snap.Tree.SparseIndex`1">
            <summary>
            Contains information on how to parse the index nodes of the SortedTree
            </summary>
        </member>
        <member name="P:GSF.Snap.Tree.SparseIndex`1.RootNodeIndexAddress">
            <summary>
            Gets the indexed address for the root node
            </summary>
        </member>
        <member name="P:GSF.Snap.Tree.SparseIndex`1.RootNodeLevel">
            <summary>
            Gets the level of the root node. If this is zero, there is only 1 leaf node.
            </summary>
        </member>
        <member name="E:GSF.Snap.Tree.SparseIndex`1.RootHasChanged">
            <summary>
            Event raised when the root of the tree changes, 
            thus <see cref="P:GSF.Snap.Tree.SparseIndex`1.RootNodeIndexAddress"/> and <see cref="P:GSF.Snap.Tree.SparseIndex`1.RootNodeLevel"/> 
            need to be saved to the header.
            </summary>
        </member>
        <member name="M:GSF.Snap.Tree.SparseIndex`1.OnRootHasChanged">
            <summary>
            Raises the event
            </summary>
        </member>
        <member name="M:GSF.Snap.Tree.SparseIndex`1.#ctor">
            <summary>
            Creates a new sparse index. Be sure to initialize this class by calling <see cref="M:GSF.Snap.Tree.SparseIndex`1.Initialize(GSF.IO.BinaryStreamPointerBase,System.Int32,System.Func{System.UInt32},System.Byte,System.UInt32)"/> before using this.
            </summary>
        </member>
        <member name="M:GSF.Snap.Tree.SparseIndex`1.Initialize(GSF.IO.BinaryStreamPointerBase,System.Int32,System.Func{System.UInt32},System.Byte,System.UInt32)">
            <summary>
            Creates a sparse index on the tree. 
            </summary>
            <param name="stream">The stream to use to write the index</param>
            <param name="blockSize">The size of each node that will be used by this index.</param>
            <param name="getNextNewNodeIndex">A method to use when additional nodes must be allocated.</param>
            <param name="rootNodeLevel">the level of the root node.</param>
            <param name="rootNodeIndexAddress">the address location for the root node.</param>
            <exception cref="T:System.Exception">Throw of duplicate calls are made to this function</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the block size is not large enough to store at least 4 elements.</exception>
        </member>
        <member name="M:GSF.Snap.Tree.SparseIndex`1.GetFirstIndex(System.Byte)">
            <summary>
            Gets the node index of the first leaf node in the tree.
            </summary>
            <param name="level">the level of the node requesting the lookup</param>
            <returns>the index of the first leaf node</returns>
        </member>
        <member name="M:GSF.Snap.Tree.SparseIndex`1.GetLastIndex(System.Byte)">
            <summary>
            Gets the node index of the last leaf node in the tree.
            </summary>
            <param name="level">the level of the node requesting the lookup</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Tree.SparseIndex`1.Get(`0,System.Byte)">
            <summary>
            Gets the data for the following key. 
            </summary>
            <param name="key">The key to look up. Only uses the key portion of the TKeyValue</param>
            <param name="level"></param>
        </member>
        <member name="M:GSF.Snap.Tree.SparseIndex`1.FindNode(`0,System.Int32)">
            <summary>
            Gets the node at the provided <see cref="!:level"/> where the provided <see cref="!:key"/> fits.
            </summary>
            <param name="key">the key to search for.</param>
            <param name="level">the level of the tree </param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Tree.SparseIndex`1.GetNode(System.Int32)">
            <summary>
            Gets the node associated with the current level.
            </summary>
            <param name="nodeLevel"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Tree.SparseIndex`1.UpdateKey(`0,`0,System.Byte)">
            <summary>
            Updates the specified leaf node to the provided key.
            </summary>
        </member>
        <member name="M:GSF.Snap.Tree.SparseIndex`1.UpdateValue(`0,GSF.Snap.Types.SnapUInt32,System.Byte)">
            <summary>
            Updates the value for the provided key.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="level"></param>
        </member>
        <member name="M:GSF.Snap.Tree.SparseIndex`1.Remove(`0,System.Byte)">
            <summary>
            Removes the specified leaf node from the sparse index
            </summary>
            <param name="key">The leaf node to remove</param>
            <param name="level"></param>
        </member>
        <member name="M:GSF.Snap.Tree.SparseIndex`1.CanCombineWithSiblings(`0,System.Byte,System.Boolean@,System.Boolean@)">
            <summary>
            When attempting to remove or combine a node, we must check the parent to find which one will be supported to remove.
            </summary>
            <param name="key">the lower key of the node that is being combined or removed.</param>
            <param name="level">the level</param>
            <param name="canCombineLeft">outputs true if this node may be combined with the left node.</param>
            <param name="canCombineRight">outputs false if this node may be combined with the right node.</param>
        </member>
        <member name="M:GSF.Snap.Tree.SparseIndex`1.Add(`0,System.UInt32,System.Byte)">
            <summary>
            Adds the following node pointer to the sparse index.
            </summary>
            <param name="nodeKey">the first key in the <see cref="!:pointer"/>. Only uses the key portion of the TKeyValue</param>
            <param name="pointer">the index of the later node</param>
            <param name="level">the level of the node being added</param>
            <remarks>This class will add the new node data to the parent node, 
            or create a new root if the current root is split.</remarks>
        </member>
        <member name="M:GSF.Snap.Tree.SparseIndex`1.CreateNewRootNode(`0,System.UInt32)">
            <summary>
            Creates a new root node by combining the current root node with the provided node data.
            </summary>
            <param name="leafKey"></param>
            <param name="leafNodeIndex"></param>
        </member>
        <member name="M:GSF.Snap.Tree.SparseIndex`1.SetCapacity(System.Int32)">
            <summary>
            Sets the capacity to the following number of levels.
            </summary>
            <param name="count">the number of levels to include.</param>
        </member>
        <member name="T:GSF.Snap.Tree.SortedTreeNodeBase`2">
            <summary>
            A tree node in the SortedTree
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeNodeBase`2.Initialize(GSF.IO.BinaryStreamPointerBase,System.Int32,System.Func{System.UInt32},GSF.Snap.Tree.SparseIndex{`0})">
            <summary>
            Initializes the required parameters for this tree to function. Must be called once.
            </summary>
            <param name="stream">the stream to use.</param>
            <param name="blockSize">the size of each block</param>
            <param name="getNextNewNodeIndex"></param>
            <param name="sparseIndex"></param>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeNodeBase`2.CanCombineWithSiblings(`0,System.Boolean@,System.Boolean@)">
            <summary>
            Determines which sibling node that this node can be combined with.
            </summary>
            <param name="key">the key of the child node that needs to be checked.</param>
            <param name="canCombineLeft">outputs true if combining with left child is supported.</param>
            <param name="canCombineRight">outputs true if combining with right child is supported.</param>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeNodeBase`2.NavigateToNode(`0)">
            <summary>
            Navigates to the node that contains this key.
            </summary>
            <param name="key">They key of concern</param>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeNodeBase`2.CreateTreeScanner">
            <summary>
            Returns a tree scanner class.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeNodeBase`2.InsertUnlessFull(System.Int32,`0,`1)">
            <summary>
            Inserts the provided key into the current node. 
            Note: A duplicate key has already been detected and will never be passed to this function.
            </summary>
            <param name="index"></param>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeNodeBase`2.AppendSequentialStream(GSF.Snap.Tree.InsertStreamHelper{`0,`1},System.Boolean@)">
            <summary>
            Requests that the current stream is inserted into the tree. Sequentail insertion can only occur while the stream
            is in order and is entirely past the end of the tree. 
            </summary>
            <param name="stream">the stream data to insert</param>
            <param name="isFull">if returning from this function while the node is not yet full, this means the stream 
            can no longer be inserted sequentially and we must break out to the root and insert one at a time.</param>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeNodeBase`2.SeekToFirstNode">
            <summary>
            Seeks to the first node at this level of the tree
            </summary>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeNodeBase`2.SeekToLastNode">
            <summary>
            Seeks to the last node at this level of the tree
            </summary>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeNodeBase`2.TryGetFirstRecord(`0,`1)">
            <summary>
            Gets the first record contained in the current node of the tree.
            </summary>
            <param name="key">where to write the key</param>
            <param name="value">where to write the value</param>
            <returns>True if a value was found. False if the tree is empty</returns>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeNodeBase`2.TryGetFirstRecord(`1)">
            <summary>
            Gets the first record contained in the current node of the tree.
            </summary>
            <param name="value">where to write the value</param>
            <returns>True if a value was found. False if the tree is empty</returns>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeNodeBase`2.TryGetLastRecord(`0,`1)">
            <summary>
            Gets the last record contained in the current node of the tree.
            </summary>
            <param name="key">where to write the key</param>
            <param name="value">where to write the value</param>
            <returns>True if a value was found. False if the tree is empty</returns>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeNodeBase`2.TryGetLastRecord(`1)">
            <summary>
            Gets the last record contained in the current node of the tree.
            </summary>
            <param name="value">where to write the value</param>
            <returns>True if a value was found. False if the tree is empty</returns>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeNodeBase`2.GetOrGetNext(`0,`1)">
            <summary>
            Gets the provided key or the key that is directly to the right of this key.
            </summary>
            <param name="key">the key to find. This value is not modifed</param>
            <param name="value">where to write the value.</param>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeNodeBase`2.TryGet(`0,`1)">
            <summary>
            Gets the value for the provided key if it exists.
            </summary>
            <param name="key">The key to search for.</param>
            <param name="value">where to write the value if found.</param>
            <returns>True if the value exists, False if not found.</returns>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeNodeBase`2.TryGet2(`0,`1)">
            <summary>
            Gets the value for the provided key if it exists.
            </summary>
            <param name="key">The key to search for.</param>
            <param name="value">where to write the value if found.</param>
            <returns>True if the value exists, False if not found.</returns>
            <remarks>
            This is a slower but more complete implementation of <see cref="M:GSF.Snap.Tree.SortedTreeNodeBase`2.TryGet(`0,`1)"/>.
            Overriding classes can call this method after implementing their own high speed TryGet method.
            </remarks>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeNodeBase`2.TryInsert(`0,`1)">
            <summary>
            Inserts the following value to the tree if it does not exist.
            </summary>
            <param name="key">The key to add</param>
            <param name="value">The value to add</param>
            <returns>True if added, False on a duplicate key error</returns>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeNodeBase`2.TryInsert2(`0,`1)">
            <summary>
            Inserts the following value to the tree if it does not exist.
            </summary>
            <param name="key">The key to add</param>
            <param name="value">The value to add</param>
            <returns>True if added, False on a duplicate key error</returns>
            <remarks>
            This is a slower but more complete implementation of <see cref="M:GSF.Snap.Tree.SortedTreeNodeBase`2.TryInsert(`0,`1)"/>.
            Overriding classes can call this method after implementing their own high speed TryGet method.
            </remarks>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeNodeBase`2.NewNodeThenInsert(`0,`1)">
            <summary>
            Creates an empty right sibling node and inserts the provided key in this node.
            Note: This should only be called if there is no right sibling and the key should go in
            that node.
            </summary>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeNodeBase`2.SplitNodeThenInsert(`0,`1)">
            <summary>
            Splits the current node and then inserts the provided key/value into the correct node.
            </summary>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeNodeBase`2.TryRemove(`0)">
            <summary>
            Tries to remove the key from the Node.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeNodeBase`2.UpdateKey(`0,`0)">
            <summary>
            Updates the provided key.
            </summary>
            <param name="oldKey"></param>
            <param name="newKey"></param>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeNodeBase`2.UpdateValue(`0,`1)">
            <summary>
            Updates the provided value
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeNodeBase`2.InternalUpdateKey(`0,`0)">
            <summary>
            Inserts the provided key into the current node.
            </summary>
            <param name="oldKey"></param>
            <param name="newKey"></param>
        </member>
        <member name="T:GSF.Snap.Tree.SortedTreeScannerBase`2">
            <summary>
            Base class for reading from any implementation of a sorted trees.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="P:GSF.Snap.Tree.SortedTreeScannerBase`2.NodeIndex">
            <summary>
            The index of the current node.
            </summary>
        </member>
        <member name="P:GSF.Snap.Tree.SortedTreeScannerBase`2.RecordCount">
            <summary>
            The number of records in the current node.
            </summary>
        </member>
        <member name="P:GSF.Snap.Tree.SortedTreeScannerBase`2.LeftSiblingNodeIndex">
            <summary>
            The node index of the previous sibling.
            uint.MaxValue means there is no sibling to the right.
            </summary>
        </member>
        <member name="P:GSF.Snap.Tree.SortedTreeScannerBase`2.RightSiblingNodeIndex">
            <summary>
            The node index of the next sibling. 
            uint.MaxValue means there is no sibling to the right.
            </summary>
        </member>
        <member name="P:GSF.Snap.Tree.SortedTreeScannerBase`2.OffsetOfUpperBounds">
            <summary>
            Gets the byte offset of the upper bounds key
            </summary>
        </member>
        <member name="P:GSF.Snap.Tree.SortedTreeScannerBase`2.Pointer">
            <summary>
            The pointer that is right after the header of the node.
            </summary>
        </member>
        <member name="P:GSF.Snap.Tree.SortedTreeScannerBase`2.PointerVersion">
            <summary>
            The pointer version of the <see cref="P:GSF.Snap.Tree.SortedTreeScannerBase`2.Pointer"/>. 
            Compare to Stream.PointerVersion to find out if 
            this pointer is current.
            </summary>
        </member>
        <member name="F:GSF.Snap.Tree.SortedTreeScannerBase`2.IndexOfNextKeyValue">
            <summary>
            The index number of the next key/value that needs to be read.
            The valid range of this field is [0, RecordCount - 1]
            </summary>
        </member>
        <member name="P:GSF.Snap.Tree.SortedTreeScannerBase`2.HeaderSize">
            <summary>
            The number of bytes in the header of any given node.
            </summary>
        </member>
        <member name="P:GSF.Snap.Tree.SortedTreeScannerBase`2.IsAlwaysSequential">
            <summary>
            Gets if the stream is always in sequential order. Do not return true unless it is Guaranteed that 
            the data read from this stream is sequential.
            </summary>
        </member>
        <member name="P:GSF.Snap.Tree.SortedTreeScannerBase`2.NeverContainsDuplicates">
            <summary>
            Gets if the stream will never return duplicate keys. Do not return true unless it is Guaranteed that 
            the data read from this stream will never contain duplicates.
            </summary>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeScannerBase`2.FindKey(`0)">
            <summary>
            Using <see cref="P:GSF.Snap.Tree.SortedTreeScannerBase`2.Pointer"/> advance to the search location of the provided <see cref="!:key"/>
            </summary>
            <param name="key">the key to advance to</param>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeScannerBase`2.Peek(`0,`1)">
            <summary>
            Reads the next point, but doees not advance the position of the stream.
            </summary>
            <param name="key">the key to write the results to</param>
            <param name="value">the value to write the results to</param>
            <returns>
            True if a point is found. 
            False if the end of the stream has been encountered.
            </returns>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeScannerBase`2.ReadWhile(`0,`1,`0)">
            <summary>
            Continues to advance the stream 
            but stops short of returning the point that is equal to
            the provided key.
            </summary>
            <param name="key">Where to store the key</param>
            <param name="value">Where to store the value</param>
            <param name="upperBounds">the test condition. Will return false if the returned point would have 
            exceeded this value</param>
            <returns>
            Returns true if the point returned is valid. 
            Returns false if:
                The point read is greater than or equal to <see cref="!:upperBounds"/>.
                The end of the stream is reached.
                The end of the current node has been reached.
            </returns>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeScannerBase`2.ReadWhile(`0,`1,`0,GSF.Snap.Filters.MatchFilterBase{`0,`1})">
            <summary>
            Using the provided filter, continues to advance the stream 
            but stops short of returning the point that is equal to
            the provided key.
            </summary>
            <param name="key">Where to store the key</param>
            <param name="value">Where to store the value</param>
            <param name="upperBounds">the test condition. Will return false if the returned point would have 
            exceeded this value</param>
            <param name="filter">the filter to apply to the reading.</param>
            <returns>
            Returns true if the point returned is valid. 
            Returns false if:
                The point read is greater than or equal to <see cref="!:upperBounds"/>.
                The end of the stream is reached.
                The end of the current node has been reached.
            </returns>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeScannerBase`2.ReadNext(`0,`1)">
            <summary>
            Advances the stream to the next value. 
            If before the beginning of the stream, advances to the first value
            </summary>
            <returns>True if the advance was successful. False if the end of the stream was reached.</returns>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeScannerBase`2.ReadBackwardish(`0,`1)">
            <summary>
            Note: This method will read each leaf node in reverse order. However, each leaf itself will be sorted
            ascending, only when moving from leaf node to leave node will this occur in reverse order.
            
            Note: This functionality should be used only to inspect the contests of a file, and not be
            used to attempt supporting reverse readings of files.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeScannerBase`2.ReadCatchAll(`0,`1)">
            <summary>
            A catch all read function. That can be called if overriding <see cref="!:Read"/> in a derived class.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeScannerBase`2.SeekToStart">
            <summary>
            Seeks to the start of SortedTree.
            </summary>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeScannerBase`2.SeekToKey(`0)">
            <summary>
            Seeks the stream to the first value greater than or equal to <see cref="!:key"/>
            </summary>
            <param name="key">the key to seek to.</param>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeScannerBase`2.LoadNode(System.UInt32)">
            <summary>
            Loads the header data for the provided node.
            </summary>
            <param name="index">the node index</param>
            <exception cref="T:System.ArgumentNullException">occurs when <see cref="!:index"/>
            is equal to uint.MaxValue</exception>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeScannerBase`2.RefreshPointer">
            <summary>
            Gets the pointer for the provided block.
            </summary>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeScannerBase`2.FindLeafNodeAddress(`0)">
            <summary>
            Gets the block index when seeking for the provided key.
            </summary>
            <param name="key">the key to start the search from.</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Tree.SortedTreeScannerBase`2.OnNoadReload">
            <summary>
            Occurs when a node's data is reset.
            Derived classes can override this 
            method if fields need to be reset when a node is loaded.
            </summary>
        </member>
        <member name="T:GSF.Snap.TreeStreamExtensions">
            <summary>
            
            </summary>
        </member>
        <member name="M:GSF.Snap.TreeStreamExtensions.Count``2(GSF.Snap.TreeStream{``0,``1})">
            <summary>
            Parses an entire stream to count the number of points. Notice, this will
            enumerate the list and the list will have to be reset to be enumerated again.
            </summary>
            <typeparam name="TKey">The key type</typeparam>
            <typeparam name="TValue">The value type</typeparam>
            <param name="stream">The stream to enumerate</param>
            <returns>the number of items in the stream.</returns>
        </member>
        <member name="T:GSF.Snap.SnapTypeBase">
            <summary>
            The interface that is required to use as a value in <see cref="!:SortedTree"/> 
            </summary>
        </member>
        <member name="M:GSF.Snap.SnapTypeBase.#ctor">
            <summary>
            Ensures that only <see cref="T:GSF.Snap.SnapTypeBase`1"/> inherits from this class.
            </summary>
        </member>
        <member name="P:GSF.Snap.SnapTypeBase.GenericTypeGuid">
            <summary>
            The Guid uniquely defining this type. 
            It is important to uniquely tie 1 type to 1 guid.
            </summary>
        </member>
        <member name="P:GSF.Snap.SnapTypeBase.Size">
            <summary>
            Gets the size of this class when serialized
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.SnapTypeBase.SetMin">
            <summary>
            Sets the provided key to it's minimum value
            </summary>
        </member>
        <member name="M:GSF.Snap.SnapTypeBase.SetMax">
            <summary>
            Sets the privided key to it's maximum value
            </summary>
        </member>
        <member name="M:GSF.Snap.SnapTypeBase.Clear">
            <summary>
            Clears the key
            </summary>
        </member>
        <member name="M:GSF.Snap.SnapTypeBase.Read(GSF.IO.BinaryStreamBase)">
            <summary>
            Reads the provided key from the stream.
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:GSF.Snap.SnapTypeBase.Write(GSF.IO.BinaryStreamBase)">
            <summary>
            Writes the provided data to the BinaryWriter
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:GSF.Snap.SnapTypeBase.Read(System.Byte*)">
            <summary>
            Reads the key from the stream
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:GSF.Snap.SnapTypeBase.Write(System.Byte*)">
            <summary>
            Writes the key to the stream
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:GSF.Snap.SnapTypeBase.MethodCopy(System.Byte*,System.Byte*)">
            <summary>
            Executes a copy command without modifying the current class.
            </summary>
            <param name="source"></param>
            <param name="destination"></param>
        </member>
        <member name="T:GSF.Snap.SnapTypeBase`1">
            <summary>
            The interface that is required to use as a value in <see cref="!:SortedTree"/> 
            </summary>
            <typeparam name="T">A class that has a default constructor</typeparam>
            <remarks>
            It is highly recommended to override many of the base class methods as many of these methods are slow.
            
            The following methods should be overriden if possible:
            Read(byte*)
            Write(byte*)
            IsLessThan(T)
            IsEqualTo(T)
            IsGreaterThan(T)
            IsLessThanOrEqualTo(T)
            IsBetween(T,T)
            CompareTo(byte*)
            IsLessThanOrEqualTo(byte*, byte*)
            
            For better random I/O inserts, it is also a good idea to implement a custom
            <see cref="T:GSF.Snap.SnapTypeCustomMethods`1"/> that overrides 
            the <see cref="M:GSF.Snap.SnapTypeCustomMethods`1.BinarySearch(System.Byte*,`0,System.Int32,System.Int32)"/> method.
            </remarks>
        </member>
        <member name="M:GSF.Snap.SnapTypeBase`1.CopyTo(`0)">
            <summary>
            Copies the source to the destination
            </summary>
            <param name="destination"></param>
        </member>
        <member name="M:GSF.Snap.SnapTypeBase`1.CompareTo(`0)">
            <summary>
            Compares the current instance to <see cref="!:other"/>.
            </summary>
            <param name="other">the key to compare to</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.SnapTypeBase`1.Compare(`0,`0)">
            <summary>
            Compares two objects and returns a value indicating whether one is less than, equal to, or greater than the other.
            </summary>
            <returns>
            A signed integer that indicates the relative values of <paramref name="x"/> and <paramref name="y"/>, as shown in the following table.Value Meaning Less than zero<paramref name="x"/> is less than <paramref name="y"/>.Zero<paramref name="x"/> equals <paramref name="y"/>.Greater than zero<paramref name="x"/> is greater than <paramref name="y"/>.
            </returns>
            <param name="x">The first object to compare.</param><param name="y">The second object to compare.</param>
        </member>
        <member name="M:GSF.Snap.SnapTypeBase`1.CompareTo(System.Byte*)">
            <summary>
            Compares the current item to one written at the provided stream.
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.SnapTypeBase`1.CreateValueMethods">
            <summary>
            Creates a class that contains the necessary methods for the SortedTree.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.SnapTypeBase`1.IsEqualTo(`0)">
            <summary>
            Is the current instance equal to <see cref="!:right"/>
            </summary>
            <param name="right">the key to compare to</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.SnapTypeBase`1.Equals(`0)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:GSF.Snap.SnapTypeBase`1.IsNotEqualTo(`0)">
            <summary>
            Gets if left != right.
            </summary>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.SnapTypeBase`1.IsBetween(`0,`0)">
            <summary>
            Gets if lowerBounds &lt;= key &lt; upperBounds
            </summary>
            <param name="lowerBounds"></param>
            <param name="upperBounds"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.SnapTypeBase`1.IsLessThanOrEqualTo(`0)">
            <summary>
            Gets if left &lt;= right.
            </summary>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.SnapTypeBase`1.IsLessThan(`0)">
            <summary>
            Gets if left &lt; right.
            </summary>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.SnapTypeBase`1.IsGreaterThan(`0)">
            <summary>
            Gets if left &gt; right.
            </summary>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.SnapTypeBase`1.IsGreaterThanOrEqualTo(`0)">
            <summary>
            Gets if left &gt;= right.
            </summary>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.SnapTypeBase`1.Clone">
            <summary>
            Creates a clone of this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="T:GSF.Snap.EncodingDefinition">
            <summary>
            An immutable class that represents the compression method used 
            by the SortedTreeStore.
            </summary>
            <remarks>
            
            Serializes as:
            If Combined KeyValue encoding
            byte type = 1
            Guid KeyValueEncodingMethod
            
            If Individual Compression
            byte type = 2
            Guid KeyEncodingMethod
            Guid ValueEncodingMethod
            </remarks>
        </member>
        <member name="P:GSF.Snap.EncodingDefinition.IsKeyValueEncoded">
            <summary>
            Gets if the compression method compresses the key and value as a unit.
            </summary>
        </member>
        <member name="M:GSF.Snap.EncodingDefinition.#ctor(GSF.IO.BinaryStreamBase)">
            <summary>
            Loads a <see cref="T:GSF.Snap.EncodingDefinition"/> from a stream
            </summary>
            <param name="stream">the stream to load from.</param>
        </member>
        <member name="M:GSF.Snap.EncodingDefinition.#ctor(System.IO.Stream)">
            <summary>
            Loads a <see cref="T:GSF.Snap.EncodingDefinition"/> from a stream
            </summary>
            <param name="stream">the stream to load from.</param>
        </member>
        <member name="M:GSF.Snap.EncodingDefinition.#ctor(System.Guid)">
            <summary>
            Specifies a combined key/value encoding method with the provided <see cref="T:System.Guid"/>.
            </summary>
            <param name="keyValueEncoding">A <see cref="T:System.Guid"/> that is the encoding method that is registered with the system.</param>
        </member>
        <member name="M:GSF.Snap.EncodingDefinition.#ctor(System.Guid,System.Guid)">
            <summary>
            Specifies an encoding method that independently compresses the key and the value.
            </summary>
            <param name="keyEncoding">the encoding of the key</param>
            <param name="valueEncoding">the encoding of the value</param>
        </member>
        <member name="P:GSF.Snap.EncodingDefinition.IsFixedSizeEncoding">
            <summary>
            Gets if the encoding method is the special fixed size encoding method.
            </summary>
        </member>
        <member name="P:GSF.Snap.EncodingDefinition.KeyEncodingMethod">
            <summary>
            Gets the compression method if <see cref="P:GSF.Snap.EncodingDefinition.IsKeyValueEncoded"/> is false.
            Throw an exception otherwise.
            </summary>
        </member>
        <member name="P:GSF.Snap.EncodingDefinition.ValueEncodingMethod">
            <summary>
            Gets the compression method if <see cref="P:GSF.Snap.EncodingDefinition.IsKeyValueEncoded"/> is false.
            Throw an exception otherwise.
            </summary>
        </member>
        <member name="P:GSF.Snap.EncodingDefinition.KeyValueEncodingMethod">
            <summary>
            Gets the compression method if <see cref="P:GSF.Snap.EncodingDefinition.IsKeyValueEncoded"/> is true.
            Throw an exception otherwise.
            </summary>
        </member>
        <member name="M:GSF.Snap.EncodingDefinition.Save(GSF.IO.BinaryStreamBase)">
            <summary>
            Serializes the <see cref="T:GSF.Snap.EncodingDefinition"/> to the provided <see cref="!:stream"/>
            </summary>
            <param name="stream">the stream to write to</param>
        </member>
        <member name="M:GSF.Snap.EncodingDefinition.Save(System.IO.Stream)">
            <summary>
            Serializes the <see cref="T:GSF.Snap.EncodingDefinition"/> to the provided <see cref="!:stream"/>
            </summary>
            <param name="stream">the stream to write to</param>
        </member>
        <member name="M:GSF.Snap.EncodingDefinition.CompareTo(GSF.Snap.EncodingDefinition)">
            <summary>
            Compares the current object with another object of the same type.
            </summary>
            <returns>
            A value that indicates the relative order of the objects being compared. The return value has the following meanings: Value Meaning Less than zero This object is less than the <paramref name="other"/> parameter.Zero This object is equal to <paramref name="other"/>. Greater than zero This object is greater than <paramref name="other"/>. 
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:GSF.Snap.EncodingDefinition.Equals(GSF.Snap.EncodingDefinition)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:GSF.Snap.EncodingDefinition.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:GSF.Snap.EncodingDefinition.CompareTo(System.Object)">
            <summary>
            Compares the current instance with another object of the same type and returns an integer that indicates whether the current instance precedes, follows, or occurs in the same position in the sort order as the other object.
            </summary>
            <returns>
            A value that indicates the relative order of the objects being compared. The return value has these meanings: Value Meaning Less than zero This instance precedes <paramref name="obj"/> in the sort order. Zero This instance occurs in the same position in the sort order as <paramref name="obj"/>. Greater than zero This instance follows <paramref name="obj"/> in the sort order. 
            </returns>
            <param name="obj">An object to compare with this instance. </param><exception cref="T:System.ArgumentException"><paramref name="obj"/> is not the same type as this instance. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:GSF.Snap.EncodingDefinition.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:GSF.Snap.EncodingDefinition.op_Inequality(GSF.Snap.EncodingDefinition,GSF.Snap.EncodingDefinition)">
            <summary>
            Checks for inequality
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.EncodingDefinition.op_Equality(GSF.Snap.EncodingDefinition,GSF.Snap.EncodingDefinition)">
            <summary>
            Checks for equality
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="F:GSF.Snap.EncodingDefinition.FixedSizeCombinedEncoding">
            <summary>
            Represents a FixedSize combined encoding method.
            </summary>
        </member>
        <member name="F:GSF.Snap.EncodingDefinition.FixedSizeIndividualEncoding">
            <summary>
            Represents a FixedSize combined encoding method made up of two individual fixed size IDs. 
            Functionally implemented the same as <see cref="F:GSF.Snap.EncodingDefinition.FixedSizeCombinedEncoding"/> 
            </summary>
        </member>
        <member name="F:GSF.Snap.EncodingDefinition.FixedSizeIndividualGuid">
            <summary>
            The Guid associated with the individual encoding method of a FixedSize
            </summary>
        </member>
        <member name="T:GSF.Snap.TreeStream`2">
            <summary>
            Represents a stream of KeyValues
            </summary>
            <typeparam name="TKey">The key associated with the point</typeparam>
            <typeparam name="TValue">The value associated with the point</typeparam>
        </member>
        <member name="P:GSF.Snap.TreeStream`2.EOS">
            <summary>
            Boolean indicating that the end of the stream has been read or class has been disposed.
            </summary>
        </member>
        <member name="P:GSF.Snap.TreeStream`2.IsAlwaysSequential">
            <summary>
            Gets if the stream is always in sequential order. Do not return true unless it is Guaranteed that 
            the data read from this stream is sequential.
            </summary>
        </member>
        <member name="P:GSF.Snap.TreeStream`2.NeverContainsDuplicates">
            <summary>
            Gets if the stream will never return duplicate keys. Do not return true unless it is Guaranteed that 
            the data read from this stream will never contain duplicates.
            </summary>
        </member>
        <member name="M:GSF.Snap.TreeStream`2.Read(`0,`1)">
            <summary>
            Advances the stream to the next value. 
            If before the beginning of the stream, advances to the first value
            </summary>
            <returns>True if the advance was successful. False if the end of the stream was reached.</returns>
        </member>
        <member name="M:GSF.Snap.TreeStream`2.EndOfStreamReached">
            <summary>
            Occurs when the end of the stream has been reached. The default behavior is to call <see cref="M:GSF.Snap.TreeStream`2.Dispose"/>
            </summary>
        </member>
        <member name="M:GSF.Snap.TreeStream`2.SetEos(System.Boolean)">
            <summary>
            Allow rolling back the EOS
            </summary>
            <exception cref="T:System.ObjectDisposedException">Thrown if <see cref="!:value"/> is <see cref="!:Boolean.False"/> and this class
            has already been disposed</exception>
        </member>
        <member name="M:GSF.Snap.TreeStream`2.ReadNext(`0,`1)">
            <summary>
            Advances the stream to the next value. 
            If before the beginning of the stream, advances to the first value
            </summary>
            <returns>True if the advance was successful. False if the end of the stream was reached.</returns>
        </member>
        <member name="M:GSF.Snap.TreeStream`2.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:GSF.Snap.TreeStream`2.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:GSF.Snap.TreeStream`2"/> object and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="T:GSF.Snap.SeekableTreeStream`2">
            <summary>
            Provides ability to seek and stream KeyValues.
            </summary>
            <typeparam name="TKey">The key of the pair</typeparam>
            <typeparam name="TValue">The value of the pair</typeparam>
        </member>
        <member name="M:GSF.Snap.SeekableTreeStream`2.SeekToKey(`0)">
            <summary>
            Seeks the stream to the first value greater than or equal to <see cref="!:key"/>
            </summary>
            <param name="key">the key to seek to.</param>
        </member>
        <member name="T:GSF.Snap.SnapTypeCustomMethods`1">
            <summary>
            Specifies all of the core methods that need to be implemented for a <see cref="!:SortedTree"/> to be able
            to utilize this type of key.
            </summary>
            <remarks>
            There are many functions that are generically implemented in this class that can be overridden
            for vastly superiour performance.
            </remarks>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:GSF.Snap.SnapTypeCustomMethods`1.BinarySearch(System.Byte*,`0,System.Int32,System.Int32)">
            <summary>
            Does a binary search on the data to find the best location for the <see cref="!:key"/>
            </summary>
            <param name="pointer"></param>
            <param name="key"></param>
            <param name="recordCount"></param>
            <param name="keyValueSize"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.SnapTypeCustomMethods`1.BinarySearch2(System.Byte*,`0,System.Int32,System.Int32)">
            <summary>
            A catch all BinarySearch.
            </summary>
            <param name="pointer"></param>
            <param name="key"></param>
            <param name="recordCount"></param>
            <param name="keyPointerSize"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.SnapTypeCustomMethods`1.IsGreaterThan(`0,System.Byte*)">
            <summary>
            Gets if left &gt;= right.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.SnapTypeCustomMethods`1.IsGreaterThan(System.Byte*,`0)">
            <summary>
            Gets if left &gt; right.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.SnapTypeCustomMethods`1.CompareTo(`0,System.Byte*)">
            <summary>
            Compares Left to Right
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.SnapTypeCustomMethods`1.CompareTo(System.Byte*,`0)">
            <summary>
            Compares Left to Right
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="T:GSF.Snap.NullTreeScanner`2">
            <summary>
            Represents an empty tree scanner. 
            </summary>
            <remarks>
            This can be useful to return instead of null at times. Seeks will not throw exceptions and 
            scans will yield no results.
            To use this class. Call the static property <see cref="P:GSF.Snap.NullTreeScanner`2.Instance"/>.
            </remarks>
        </member>
        <member name="P:GSF.Snap.NullTreeScanner`2.Instance">
            <summary>
            Returns a static instance of this class
            </summary>
        </member>
        <member name="T:GSF.Snap.Types.IHasTimestampField">
            <summary>
            A point that has a timestamp field that may be extracted.
            </summary>
        </member>
        <member name="M:GSF.Snap.Types.IHasTimestampField.TryGetDateTime(System.DateTime@)">
            <summary>
            Attempts to get the timestamp field of a point. This function might fail if the datetime field
            is not able to be converted.
            </summary>
            <param name="timestamp">an output field of the timestamp</param>
            <returns>True if a timestamp could be parsed. False otherwise.</returns>
        </member>
        <member name="T:GSF.Snap.Types.TimestampBase`1">
            <summary>
            Base implementation of a historian key. 
            These are the required functions that are 
            necessary for the historian engine to operate
            </summary>
            <typeparam name="TKey"></typeparam>
        </member>
        <member name="F:GSF.Snap.Types.TimestampBase`1.Timestamp">
            <summary>
            The timestamp stored as native ticks. 
            </summary>
        </member>
        <member name="M:GSF.Snap.Types.TimestampBase`1.GSF#Snap#Types#IHasTimestampField#TryGetDateTime(System.DateTime@)">
            <summary>
            Attempts to get the timestamp field of a point. This function might fail if the datetime field
            is not able to be converted.
            </summary>
            <param name="timestamp">an output field of the timestamp</param>
            <returns>True if a timestamp could be parsed. False otherwise.</returns>
        </member>
        <member name="T:GSF.Snap.Types.TimestampPointIDBase`1">
            <summary>
            Base implementation of a historian key. 
            These are the required functions that are 
            necessary for the historian engine to operate
            </summary>
            <typeparam name="TKey"></typeparam>
        </member>
        <member name="F:GSF.Snap.Types.TimestampPointIDBase`1.PointID">
            <summary>
            The id number of the point.
            </summary>
        </member>
        <member name="T:GSF.Snap.Library">
            <summary>
            A library of <see cref="T:GSF.Snap.SnapTypeBase"/> types. This
            library will dynamically register types via reflection if possible.
            </summary>
        </member>
        <member name="F:GSF.Snap.Library.Encodings">
            <summary>
            Gets all of the encoding data.
            </summary>
        </member>
        <member name="F:GSF.Snap.Library.Filters">
            <summary>
            Gets all of the filters.
            </summary>
        </member>
        <member name="F:GSF.Snap.Library.FilterAssemblyNames">
            <summary>
            The assembly must reference one of these assembly names in order to be scanned for matching types.
            </summary>
        </member>
        <member name="M:GSF.Snap.Library.ReloadNewAssemblies">
            <summary>
            Will attempt to reload any type that 
            inherits from <see cref="T:GSF.Snap.SnapTypeBase"/> in
            any new assemblies.
            </summary>
        </member>
        <member name="M:GSF.Snap.Library.GetSortedTreeType(System.Guid)">
            <summary>
            Gets the <see cref="T:GSF.Snap.SnapTypeBase"/> associated with the provided <see cref="!:id"/>.
            </summary>
            <param name="id">the ID to lookup</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Library.GetKeyValueMethods``2">
            <summary>
            Gets a set of KeyValueMethods.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Library.CreateStreamEncoding``2(GSF.Snap.EncodingDefinition)">
            <summary>
            Creates a stream encoding from the provided <see cref="!:encodingMethod"/>.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="encodingMethod">the encoding method</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.Library.Register(GSF.Snap.SnapTypeBase)">
            <summary>
            Registers the generic type with the SortedTreeStore.
            </summary>
        </member>
        <member name="T:GSF.Snap.CustomSortHelper`1">
            <summary>
            Provides basic sorting methods that assist in UnionKeyValueStream's speed.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:GSF.Snap.CustomSortHelper`1.Items">
            <summary>
            All of the items in this list.
            </summary>
        </member>
        <member name="M:GSF.Snap.CustomSortHelper`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Func{`0,`0,System.Boolean})">
            <summary>
            Creates a new custom sort helper and presorts the list.
            </summary>
            <param name="items"></param>
            <param name="isLessThan"></param>
        </member>
        <member name="P:GSF.Snap.CustomSortHelper`1.Item(System.Int32)">
            <summary>
            Indexer to get the specified item out of the list
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Snap.CustomSortHelper`1.Sort">
            <summary>
            Resorts the entire list. Uses an insertion sort routine
            </summary>
        </member>
        <member name="M:GSF.Snap.CustomSortHelper`1.SortAssumingIncreased(System.Int32)">
            <summary>
            Resorts only the item at the specified index assuming:
            1) all other items are properly sorted
            2) this items's value increased.
            </summary>
            <param name="index">the index of the item to resort.</param>
        </member>
        <member name="F:GSF.Snap.Stats.ChecksumCount">
            <summary>
            Checks how many times the checksum was computed.  This is used to see IO amplification.
            It is currently a debug term that will soon disappear.
            </summary>
        </member>
        <member name="T:GSF.Globals">
            <summary>
            Maintains the static global classes for the historian.
            </summary>
        </member>
        <member name="F:GSF.Globals.MemoryPool">
            <summary>
            A global Memory Pool that uses 64KB pages.
            </summary>
        </member>
        <member name="T:GSF.Text.NaturalComparer">
            <summary>
            Does a sort on a string that is natual to how humans look at it. 
            Such as sorting numbers.
            </summary>
        </member>
        <member name="M:GSF.Text.NaturalComparer.#ctor">
            <summary>
            Creates a new <see cref="T:GSF.Text.NaturalComparer"/>
            </summary>
        </member>
        <member name="M:GSF.Text.NaturalComparer.Compare(System.String,System.String)">
            <summary>
            When overridden in a derived class, performs a comparison of two objects of the same type and returns a value indicating whether one object is less than, equal to, or greater than the other.
            </summary>
            <returns>
            A signed integer that indicates the relative values of <paramref name="x"/> and <paramref name="y"/>, as shown in the following table.Value Meaning Less than zero <paramref name="x"/> is less than <paramref name="y"/>.Zero <paramref name="x"/> equals <paramref name="y"/>.Greater than zero <paramref name="x"/> is greater than <paramref name="y"/>.
            </returns>
            <param name="x">The first object to compare.</param><param name="y">The second object to compare.</param>
        </member>
        <member name="T:GSF.Threading.AtomicInt64">
            <summary>
            Since 64 bit reads/asignments are not atomic on a 32-bit process, this class
            wrapps the <see cref="T:System.Threading.Interlocked"/> class to if using a 32-bit process to ensure
            atomic reads/writes.
            </summary>
        </member>
        <member name="M:GSF.Threading.AtomicInt64.#ctor(System.Int64)">
            <summary>
            Creates a new AtomicInt64
            </summary>
            <param name="value"></param>
        </member>
        <member name="P:GSF.Threading.AtomicInt64.Value">
            <summary>
            Gets/Sets the value
            </summary>
        </member>
        <member name="M:GSF.Threading.AtomicInt64.op_Implicit(GSF.Threading.AtomicInt64)~System.Int64">
            <summary>
            Converts to a long
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:GSF.Threading.EventTimer">
            <summary>
            A timer event that occurs on a specific interval at a specific offset.
            
            This class is thread safe.
            </summary>
        </member>
        <member name="E:GSF.Threading.EventTimer.Elapsed">
            <summary>
            Occurs when the timer elapses.
            Event occurs on the ThreadPool
            </summary>
        </member>
        <member name="M:GSF.Threading.EventTimer.#ctor(System.TimeSpan,System.TimeSpan)">
            <summary>
            Creates a <see cref="T:GSF.Threading.EventTimer"/>
            </summary>
            <param name="period"></param>
            <param name="dayOffset"></param>
        </member>
        <member name="M:GSF.Threading.EventTimer.m_timer_Running(System.Object,GSF.EventArgs{GSF.Threading.ScheduledTaskRunningReason})">
            <summary>
            This timer will reliably fire the directory polling every interval.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="P:GSF.Threading.EventTimer.Enabled">
            <summary>
            Gets/sets if the timer is enabled.
            </summary>
        </member>
        <member name="P:GSF.Threading.EventTimer.TimeUntilNextExecution">
            <summary>
            The remaining time until the next execution. This is a calculated value and may not exactly represent 
            the next time <see cref="E:GSF.Threading.EventTimer.Elapsed"/> will run.
            </summary>
        </member>
        <member name="M:GSF.Threading.EventTimer.Start">
            <summary>
            Starts the watching
            </summary>
        </member>
        <member name="M:GSF.Threading.EventTimer.Stop">
            <summary>
            Stops the timer. The call that stops the timer
            will pause until the event is stopped. Any subsequent
            calls will return immediately.
            </summary>
        </member>
        <member name="M:GSF.Threading.EventTimer.Create(System.TimeSpan,System.TimeSpan)">
            <summary>
            Creates an <see cref="T:GSF.Threading.EventTimer"/> with the supplied inputs.
            </summary>
            <param name="period">the period of the timer</param>
            <param name="dayOffset">the day offset when the timer will run.</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Threading.EventTimer.CreateSeconds(System.Double,System.Double)">
            <summary>
            Creates an <see cref="T:GSF.Threading.EventTimer"/> with the supplied inputs.
            </summary>
            <param name="periodInSecond">the period of the timer in seconds</param>
            <param name="dayOffsetInSecond">the offset from the top of the day in seconds. </param>
            <returns></returns>
        </member>
        <member name="M:GSF.Threading.EventTimer.CreateMinutes(System.Double,System.Double)">
            <summary>
            Creates an <see cref="T:GSF.Threading.EventTimer"/> with the supplied inputs.
            </summary>
            <param name="periodInMinutes">he period of the timer in minutes</param>
            <param name="dayOffsetInMinutes"></param>
            <returns></returns>
        </member>
        <member name="T:GSF.Threading.HalfLock">
            <summary>
            Provides a light weight exclusive lock that is approximately 2.5 times faster than <see cref="T:System.Threading.Monitor"/>.
            WARNING: This lock should be used in a Using block, and duplicate calls to Lock without releasing will cause a deadlock.
            </summary>
            <remarks>
            After writing this class I did some review of the methodology. 
            Reviewing this article: http://www.adammil.net/blog/v111_Creating_High-Performance_Locks_and_Lock-free_Code_for_NET_.html
            Brings up stability issues with the lock. Namely what happens when unhandled exceptions occurs when acquiring and releasing the lock.
            I have intentionally left out any kind of protection against this as it severly reduces the speed of this code. Therefore
            do not use this locking method where a Thread.Abort() might be used as a control method. 
            </remarks>
        </member>
        <member name="M:GSF.Threading.HalfLock.#ctor">
            <summary>
            Creates a <see cref="T:GSF.Threading.TinyLock"/>
            </summary>
        </member>
        <member name="M:GSF.Threading.HalfLock.Lock">
            <summary>
            Acquires an exclusive lock on this class. Place call in a using block.
            Duplicate calls to this within the same thread will cause a deadlock.
            </summary>
            <returns>A structure that will release the lock. 
            This struct will always be the exact same value. Therefore it can be 
            stored once if desired, however, be careful when using it this way as inproper synchronization
            will be easier to occur.</returns>
        </member>
        <member name="M:GSF.Threading.HalfLock.LockSlower">
            <summary>
            A nested call since 99% of the time, there will not be contention. This prevents stack space being
            used for the SpinLock when its not needed.
            </summary>
            <returns></returns>
        </member>
        <member name="T:GSF.Threading.HalfLock.HalfLockRelease">
            <summary>
            A structure that will allow releasing of a lock. This is returned by <see cref="M:GSF.Threading.HalfLock.Lock"/>.
            </summary>
        </member>
        <member name="M:GSF.Threading.HalfLock.HalfLockRelease.Dispose">
            <summary>
            Releases an acquired lock.
            </summary>
        </member>
        <member name="T:GSF.Threading.DisposableReadLock">
            <summary>
            A read lock object
            </summary>
        </member>
        <member name="M:GSF.Threading.DisposableReadLock.#ctor(System.Threading.ReaderWriterLock)">
            <summary>
            Creates a read lock
            </summary>
            <param name="l"></param>
        </member>
        <member name="T:GSF.Threading.DisposableWriteLock">
            <summary>
            A read lock object
            </summary>
        </member>
        <member name="M:GSF.Threading.DisposableWriteLock.#ctor(System.Threading.ReaderWriterLock)">
            <summary>
            Creates a read lock
            </summary>
            <param name="l"></param>
        </member>
        <member name="T:GSF.Threading.ReaderWriterLockEasy">
            <summary>
            A simplified implementation of a <see cref="T:System.Threading.ReaderWriterLockSlim"/>. This allows for more 
            user friendly code to be written.
            </summary>
        </member>
        <member name="M:GSF.Threading.ReaderWriterLockEasy.EnterReadLock">
            <summary>
            Enters a read lock. Be sure to call within a using block.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GSF.Threading.ReaderWriterLockEasy.EnterWriteLock">
            <summary>
            Enters a write lock. Be sure to call within a using block.
            </summary>
            <returns></returns>
        </member>
        <member name="T:GSF.Threading.SafeManualResetEvent">
            <summary>
            Provides a thread safe implementation of the <see cref="T:System.Threading.ManualResetEvent"/> class
            </summary>
            <remarks>
            While <see cref="T:System.Threading.ManualResetEvent"/> is mostly thread safe, calls to Dispose
            can cause other waiting threads to throw <see cref="T:System.ObjectDisposedException"/>.
            This class makes disposing of the class thread safe as well.
            
            Note: Not properly disposing of this class can cause all threads waiting on this
            class to wait indefinately. 
            </remarks>
        </member>
        <member name="F:GSF.Threading.SafeManualResetEvent.Log">
            <summary>
            A place to report exception logs associated with this class.
            </summary>
        </member>
        <member name="F:GSF.Threading.SafeManualResetEvent.m_waitingThreadCount">
            <summary>
            The number of threads waiting
            </summary>
        </member>
        <member name="M:GSF.Threading.SafeManualResetEvent.#ctor(System.Boolean)">
            <summary>
            Creates a new <see cref="T:GSF.Threading.SafeManualResetEvent"/>
            </summary>
            <param name="signaledState">true to set the initial state signaled; false to set the initial state to nonsignaled.</param>
        </member>
        <member name="M:GSF.Threading.SafeManualResetEvent.Reset">
            <summary>
            Sets the state of the event to signaled, allowing one or more waiting threads to proceed.
            </summary>
        </member>
        <member name="M:GSF.Threading.SafeManualResetEvent.Set">
            <summary>
            Sets the state of the event to signaled, allowing one or more waiting threads to proceed.
            </summary>
        </member>
        <member name="M:GSF.Threading.SafeManualResetEvent.WaitOne">
            <summary>
            Blocks the current thread until <see cref="M:GSF.Threading.SafeManualResetEvent.Set"/> or <see cref="M:GSF.Threading.SafeManualResetEvent.Dispose"/> is called..
            </summary>
        </member>
        <member name="M:GSF.Threading.SafeManualResetEvent.Dispose">
            <summary>
            Releases all the resources used by the <see cref="T:GSF.Threading.SafeManualResetEvent"/> object.
            Also signals all waiting threads and ignores all calls to <see cref="M:GSF.Threading.SafeManualResetEvent.Reset"/>.
            </summary>
        </member>
        <member name="T:GSF.Threading.WorkerThreadSynchronization">
            <summary>
            Creates a synchronization helper that will assist object synchronizing in a tight inner loop.
            </summary>
            <remarks>
            For streaming protocols, it is cost prohibited to tightly coordinate the inner loop. This class
            will help coordinate these efforts by signaling when a good time to perform synchronized work would be.
            For Example, when writing to a socket, calling <see cref="M:GSF.Threading.WorkerThreadSynchronization.BeginSafeToCallbackRegion"/> would be good to do
            when the socket makes any kind of blocking call, such as flusing to an underlying socket. Upon returning
            from this command, calling <see cref="M:GSF.Threading.WorkerThreadSynchronization.EndSafeToCallbackRegion"/> will return this class to a state where callback
            will not be executed.
            
            It is critical that <see cref="M:GSF.Threading.WorkerThreadSynchronization.BeginSafeToCallbackRegion"/>, <see cref="M:GSF.Threading.WorkerThreadSynchronization.EndSafeToCallbackRegion"/>, and 
            <see cref="M:GSF.Threading.WorkerThreadSynchronization.PulseSafeToCallback"/> only be called by the worker thread, as these methods are not thread safe and
            control the state of the <see cref="T:GSF.Threading.WorkerThreadSynchronization"/>.
            
            In easy terms. When you (the worker) get a convenient time, I need to do something that might modify your 
            current working state. Let me know when I can do that.
            </remarks>
        </member>
        <member name="T:GSF.Threading.WorkerThreadSynchronization.CallbackRequest">
            <summary>
            A callback request. Cancel this request when the callback is no longer needed.
            </summary>
        </member>
        <member name="M:GSF.Threading.WorkerThreadSynchronization.CallbackRequest.#ctor(System.Action)">
            <summary>
            Creates a callback request.
            </summary>
            <param name="callback">the action to perform.</param>
        </member>
        <member name="M:GSF.Threading.WorkerThreadSynchronization.CallbackRequest.Cancel">
            <summary>
            Cancels the callback.
            </summary>
        </member>
        <member name="M:GSF.Threading.WorkerThreadSynchronization.CallbackRequest.Dispose">
            <summary>
            Disposes of the callback
            </summary>
        </member>
        <member name="M:GSF.Threading.WorkerThreadSynchronization.CallbackRequest.Run">
            <summary>
            Executes the callback item
            </summary>
        </member>
        <member name="F:GSF.Threading.WorkerThreadSynchronization.m_isSafeToCallback">
            <summary>
            Only to be set by the worker thread.
            </summary>
        </member>
        <member name="F:GSF.Threading.WorkerThreadSynchronization.m_isCallbackWaiting">
            <summary>
            Only to be set within lock(m_syncRoot)
            </summary>
        </member>
        <member name="F:GSF.Threading.WorkerThreadSynchronization.m_isRequestCallbackMethodProcessing">
            <summary>
            Gets if this method is currently executing, which means tighter coordination is required.
            </summary>
        </member>
        <member name="M:GSF.Threading.WorkerThreadSynchronization.#ctor">
            <summary>
            Creates a <see cref="T:GSF.Threading.WorkerThreadSynchronization"/>.
            </summary>
        </member>
        <member name="M:GSF.Threading.WorkerThreadSynchronization.RequestCallback(System.Action)">
            <summary>
            Requests that the following action be completed as soon as reasonably possible. 
            This will either be done immediately, or be queued for the next approriate time.
            </summary>
            <param name="callback">action to perform</param>
            <returns>
            A cancelation object. Use in a using block.
            </returns>
        </member>
        <member name="M:GSF.Threading.WorkerThreadSynchronization.PulseSafeToCallback">
            <summary>
            Signals that if any callbacks are pending, 
            go ahead and run them now. Otherwise, wait.
            </summary>
            <remarks>
            This method will be inlined and has virtually no 
            overhead so long as a callback is not waiting.
            </remarks>
        </member>
        <member name="M:GSF.Threading.WorkerThreadSynchronization.BeginSafeToCallbackRegion">
            <summary>
            Enters a region where a callback can occur.
            </summary>
            <remarks>
            A good place to put this is before a long 
            action where it is possible that the thread
            might be blocked.
            </remarks>
        </member>
        <member name="M:GSF.Threading.WorkerThreadSynchronization.EndSafeToCallbackRegion">
            <summary>
            Exits a region where future callbacks cannot occur.
            </summary>
        </member>
        <member name="T:GSF.Threading.WeakActionFast">
            <summary>
            Provides a high speed weak referenced action delegate.
            This one does not use reflection, so calls will be faster.
            
            HOWEVER: a strong reference MUST be maintained for 
            the <see cref="T:System.Action"/> delegate passed to this class. 
            This reference is outputted in the constructor.
            
            Careful consideration must be made when deciding 
            where to store this strong reference, as this strong reference
            will need to also lose reference. A good place would be 
            as a member variable of the object of the target method.
            </summary>
        </member>
        <member name="M:GSF.Threading.WeakActionFast.#ctor(System.Action,System.Object@)">
            <summary>
            Creates a high speed weak action 
            </summary>
            <param name="target">the callback</param>
            <param name="localStrongReference">a strong reference that must be 
            maintained in the class that is the target of the action</param>
        </member>
        <member name="M:GSF.Threading.WeakActionFast.TryInvoke">
            <summary>
            Attempts to invoke the delegate to a weak reference object.
            </summary>
            <returns>True if successful, false if not</returns>
        </member>
        <member name="T:GSF.Threading.WeakActionFast`1">
            <summary>
            Provides a high speed weak referenced action delegate.
            This one does not use reflection, so calls will be faster.
            
            HOWEVER: a strong reference MUST be maintained for 
            the <see cref="T:System.Action"/> delegate passed to this class. 
            This reference is outputted in the constructor.
            
            Careful consideration must be made when deciding 
            where to store this strong reference, as this strong reference
            will need to also lose reference. A good place would be 
            as a member variable of the object of the target method.
            </summary>
        </member>
        <member name="M:GSF.Threading.WeakActionFast`1.#ctor(System.Action{`0},System.Object@)">
            <summary>
            Creates a high speed weak action 
            </summary>
            <param name="target">the callback</param>
            <param name="localStrongReference">a strong reference that must be 
            maintained in the class that is the target of the action</param>
        </member>
        <member name="M:GSF.Threading.WeakActionFast`1.TryInvoke(`0)">
            <summary>
            Attempts to invoke the delegate to a weak reference object.
            </summary>
            <returns>True if successful, false if not</returns>
        </member>
        <member name="T:GSF.Threading.SynchronousEvent`1">
            <summary>
            Provides a way to raise events on another thread. The events
            will be raised on the thread that constructed this class.
            </summary>
            <typeparam name="T"></typeparam>
            <remarks>
            This is useful when needing to process data on a certain thread. On instance is 
            when preparing data that needs to then be processed on the UI thread. Just construct
            this class on the UI thread, then when any thread raises an event, this event will be
            queued on the UI thread.
            </remarks>
        </member>
        <member name="M:GSF.Threading.SynchronousEvent`1.RaiseEvent(`0)">
            <summary>
            Posts an event on the constructing thread.
            This call blocks until the custom event 
            Not thread safe.
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:GSF.Threading.SynchronousEvent`1.Dispose">
            <summary>
            Prevents any future events from processing and
            attempts to cancel a pending operation. 
            Function returns before any attempts to cancel are successful.
            </summary>
        </member>
        <member name="T:GSF.Threading.ThreadSafeList`1">
            <summary>
            This list allows for iterating through the list 
            while object can be removed from the list. Once an object has been
            removed, is garenteed not to be called again by a seperate thread. 
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:GSF.Threading.ThreadSafeList`1.#ctor">
            <summary>
            Creates a new <see cref="T:GSF.Threading.ThreadSafeList`1"/>
            </summary>
        </member>
        <member name="M:GSF.Threading.ThreadSafeList`1.Add(`0)">
            <summary>
            Adds the supplied item to the list
            </summary>
            <param name="item">The item to add</param>
        </member>
        <member name="M:GSF.Threading.ThreadSafeList`1.RemoveAndWait(`0)">
            <summary>
            Removes an item from the list. 
            This method will block until the item has successfully been removed 
            and will no longer show up in the Iterator.
            DO NOT call this function from within a ForEach loop as it will block indefinately
            since the for each loop reads all items.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Threading.ThreadSafeList`1.Remove(`0)">
            <summary>
            Removes an item from the list. 
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:GSF.Threading.ThreadSafeList`1.RemoveIf(System.Func{`0,System.Boolean})">
            <summary>
            Removes the specified item if the lamda expression is true.
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:GSF.Threading.ThreadSafeList`1.ForEach(System.Action{`0})">
            <summary>
            Calls a foreach iterator on the supplied action.
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:GSF.Threading.ThreadSafeList`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:GSF.Threading.ThreadSafeList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:GSF.Threading.ThreadSafeList`1.Enumerator">
            <summary>
            The Enumerator for a <see cref="T:GSF.Threading.ThreadSafeList`1"/>
            </summary>
        </member>
        <member name="P:GSF.Threading.ThreadSafeList`1.Enumerator.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
            </returns>
        </member>
        <member name="P:GSF.Threading.ThreadSafeList`1.Enumerator.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current element in the collection.
            </summary>
            <returns>
            The current element in the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:GSF.Threading.ThreadSafeList`1.Enumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:GSF.Threading.ThreadSafeList`1.Enumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:GSF.Threading.ThreadSafeList`1.Enumerator.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:GSF.Threading.ThreadSafeList`1.Iterator">
            <summary>
            Parses through a list in a thread safe mannor.
            </summary>
        </member>
        <member name="M:GSF.Threading.ThreadSafeList`1.Iterator.UnsafeTryGetNextItem(`0@)">
            <summary>
            Only 1 item can be obtained at a time. Failing to call <see cref="M:GSF.Threading.ThreadSafeList`1.Iterator.UnsafeUnregisterItem"/> will
            result in a infinite loop. Therefore wrap each call in a Try/Finally block.
            </summary>
            <param name="item">an output parameter for the next item</param>
            <returns></returns>
        </member>
        <member name="M:GSF.Threading.ThreadSafeList`1.Iterator.UnsafeUnregisterItem">
            <summary>
            Should be called each time after <see cref="M:GSF.Threading.ThreadSafeList`1.Iterator.UnsafeTryGetNextItem(`0@)"/>.
            Note, it is optional to call this function if <see cref="M:GSF.Threading.ThreadSafeList`1.Iterator.UnsafeTryGetNextItem(`0@)"/> returns false.
            </summary>
        </member>
        <member name="T:GSF.Threading.TinyLock">
            <summary>
            Provides a light weight exclusive lock that is approximately 2.5 times faster than <see cref="T:System.Threading.Monitor"/>.
            WARNING: This lock should be used in a Using block, and duplicate calls to Lock without releasing will cause a deadlock.
            </summary>
            <remarks>
            After writing this class I did some review of the methodology. 
            Reviewing this article: http://www.adammil.net/blog/v111_Creating_High-Performance_Locks_and_Lock-free_Code_for_NET_.html
            Brings up stability issues with the lock. Namely what happens when unhandled exceptions occurs when acquiring and releasing the lock.
            I have intentionally left out any kind of protection against this as it severly reduces the speed of this code. Therefore
            do not use this locking method where a Thread.Abort() might be used as a control method. 
            </remarks>
        </member>
        <member name="M:GSF.Threading.TinyLock.#ctor">
            <summary>
            Creates a <see cref="T:GSF.Threading.TinyLock"/>
            </summary>
        </member>
        <member name="M:GSF.Threading.TinyLock.Lock">
            <summary>
            Acquires an exclusive lock on this class. Place call in a using block.
            Duplicate calls to this within the same thread will cause a deadlock.
            </summary>
            <returns>A structure that will release the lock. 
            This struct will always be the exact same value. Therefore it can be 
            stored once if desired, however, be careful when using it this way as inproper synchronization
            will be easier to occur.</returns>
        </member>
        <member name="M:GSF.Threading.TinyLock.LockSlower">
            <summary>
            A nested call since 99% of the time, there will not be contention. This prevents stack space being
            used for the SpinLock when its not needed.
            </summary>
            <returns></returns>
        </member>
        <member name="T:GSF.Threading.TinyLock.TinyLockRelease">
            <summary>
            A structure that will allow releasing of a lock. This is returned by <see cref="M:GSF.Threading.TinyLock.Lock"/>.
            </summary>
        </member>
        <member name="M:GSF.Threading.TinyLock.TinyLockRelease.Dispose">
            <summary>
            Releases an acquired lock.
            </summary>
        </member>
        <member name="T:GSF.Threading.WeakAction">
            <summary>
            Provides a weak referenced action delegate. 
            </summary>
        </member>
        <member name="M:GSF.Threading.WeakAction.TryInvoke">
            <summary>
            Attempts to invoke the delegate to a weak reference object.
            </summary>
            <returns>True if successful, false if not</returns>
        </member>
        <member name="T:GSF.Threading.WeakAction`1">
            <summary>
            Provides a weak referenced action delegate. 
            </summary>
        </member>
        <member name="T:GSF.Threading.WeakEventHandler`1">
            <summary>
            Provides a weak referenced action delegate. 
            </summary>
        </member>
        <member name="T:GSF.WinApi">
            <summary>
            Provides necessary Windows API functions.
            </summary>
        </member>
        <member name="M:GSF.WinApi.FlushFileBuffers(Microsoft.Win32.SafeHandles.SafeFileHandle)">
            <summary>
            Flushes the buffers of a specified file and causes all buffered data to be written to a file.
            </summary>
            <param name="handle"></param>
            <remarks>Since the flush of a file stream does not actually work, this finishes the flush to the disk file system.
            Which still could cache the results, but this is about the best we can do for a flush right now.</remarks>
        </member>
        <member name="M:GSF.WinApi.MoveMemory(System.Byte*,System.Byte*,System.Int32)">
            <summary>
            Copies data from one memory location to another. This function does a check
            to see if the data bytes overlaps and guarantees that the bytes are copied in 
            such a way to preserve the move.
            </summary>
            <param name="destination">a pointer to the destination</param>
            <param name="source">a pointer to the source</param>
            <param name="count">the number of bytes to move</param>
            <remarks>By setting the SuppressUnmanagedCodeSecurityAttribute will decrease the pinvoke overhead by about 2x.</remarks>
        </member>
        <member name="T:GSF.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:GSF.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:GSF.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Client">
            Implements the client side SRP-6a protocol. Note that this class is stateful, and therefore NOT threadsafe.
            This implementation of SRP is based on the optimized message sequence put forth by Thomas Wu in the paper
            "SRP-6: Improvements and Refinements to the Secure Remote Password Protocol, 2002"
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Client.GenerateClientCredentials(Org.BouncyCastle.Crypto.IDigest,System.Byte[],System.Byte[],System.Byte[])">
            Generates client's credentials given the client's salt, identity and password
            @param salt The salt used in the client's verifier.
            @param identity The user's identity (eg. username)
            @param password The user's password
            @return Client's public value to send to server
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Client.CalculateSecret(Org.BouncyCastle.Crypto.IDigest,Org.BouncyCastle.Math.BigInteger)">
            Generates client's verification message given the server's credentials
            @param serverB The server's credentials
            @return Client's verification message for the server
            @throws CryptoException If server's credentials are invalid
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Server">
            Implements the server side SRP-6a protocol. Note that this class is stateful, and therefore NOT threadsafe.
            This implementation of SRP is based on the optimized message sequence put forth by Thomas Wu in the paper
            "SRP-6: Improvements and Refinements to the Secure Remote Password Protocol, 2002"
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Server.#ctor(GSF.Security.Authentication.SrpConstants,Org.BouncyCastle.Math.BigInteger)">
            Initialises the server to accept a new client authentication attempt
            @param N The safe prime associated with the client's verifier
            @param g The group parameter associated with the client's verifier
            @param v The client's verifier
            @param digest The digest algorithm associated with the client's verifier
            @param random For key generation
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Server.GenerateServerCredentials">
            Generates the server's credentials that are to be sent to the client.
            @return The server's public value to the client
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Server.CalculateSecret(Org.BouncyCastle.Crypto.IDigest,Org.BouncyCastle.Math.BigInteger)">
            Processes the client's credentials. If valid the shared secret is generated and returned.
            @param clientA The client's credentials
            @return A shared secret BigInteger
            @throws CryptoException If client's credentials are invalid
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Utilities.HashPaddedPair(Org.BouncyCastle.Crypto.IDigest,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Pads n1 and n2 to the same number of bytes as N. Then hashes them.
            </summary>
            <returns>The hash Mod N</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Utilities.GetPadded(Org.BouncyCastle.Math.BigInteger,System.Int32)">
            <summary>
            Pads a byte[] to the specified length, 
            with zeroes at the start of the buffer.
            </summary>
            <param name="n"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Utilities.ToPaddedArray(Org.BouncyCastle.Math.BigInteger,System.Int32)">
            <summary>
            Gets the byte representation of <see cref="!:n"/> that is padded to 
            match the byte length of <see cref="!:length"/>.
            </summary>
            <param name="n"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
    </members>
</doc>
