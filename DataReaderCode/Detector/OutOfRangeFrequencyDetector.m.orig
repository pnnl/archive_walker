%           PastAdditionalOutput: past AdditionalOutput outputs from this
%                                 function that can be used for various
%                                 purposes.

function [DetectionResults, AdditionalOutput] = OutOfRangeFrequencyDetector(PMUstruct,Parameters,PastAdditionalOutput)

%% Store the channels for analysis in a matrix. PMU and channel names are
% stored in cell arrays. Also returns a time vector t with units of seconds
% and the sampling rate fs.
try
    [Data, DataPMU, DataChannel, DataType, DataUnit, t, fs, TimeString] = ExtractData(PMUstruct,Parameters);
catch
    warning('Input data for the periodogram detector could not be used.');
    DetectionResults = struct([]);
    AdditionalOutput = struct([]);
    return
end

% Using the outputs from ExtractData(), make sure that NaN values are
% handled appropriately and that signal types and units are appropriate.
% This comment is general for all detectors, write code specific to the
% detector you're working on.
KeepIdx = strcmp(DataType,'F') | strcmp(DataType,'OTHER');
Data = Data(:,KeepIdx);
DataPMU = DataPMU(KeepIdx);
DataChannel = DataChannel(KeepIdx);

%% Get detector parameters

% This function pulls the parameters out of the structure containing the
% XML information. It turns strings into numbers as necessary and sets
% default values for parameters that were not specified. 
% Additional inputs, such as the length of the input data or the sampling 
% rate, can be added as necessary. 
ExtractedParameters = ExtractParameters(Parameters,fs);

% Store the parameters in variables for easier access
DurationMax = ExtractedParameters.DurationMax;
DurationMin = ExtractedParameters.DurationMin;
Duration = ExtractedParameters.Duration;
AnalysisWindow = ExtractedParameters.AnalysisWindow;
%
RateOfChangeMax = ExtractedParameters.RateOfChangeMax;
RateOfChangeMin = ExtractedParameters.RateOfChangeMin;
RateOfChange = ExtractedParameters.RateOfChange;

FrequencyResponse = ExtractedParameters.FrequencyResponse;
DurationMax = ExtractedParameters.DurationMax;
DurationMin = ExtractedParameters.DurationMin;
Duration = ExtractedParameters.Duration;
RateOfChangeMax = ExtractedParameters.RateOfChangeMax;
RateOfChangeMin = ExtractedParameters.RateOfChangeMin;
RateOfChange = ExtractedParameters.RateOfChange;




%% Error checks
if Duration > AnalysisWindow
    warning('Duration cannot be greater than AnalysisWindow. Default of 0 will be used.');
    Duration = 0;
end

<<<<<<< HEAD
% Initialize structure to output detection results
DetectionResults = struct('PMU',[],'Channel',[],'Max',[],'Min',[],'Duration',[],'Response',[]);
=======
if DurationMax < DurationMin
    warning('DurationMax is less than DurationMin. Duration-based frequency event detector will not be implemented.')
    DurationMax = NaN;
    DurationMin = NaN;
    Duration = NaN;
    AnalysisWindow = NaN;
end

if RateOfChangeMax < RateOfChangeMin
    warning('RateOfChangeMax is less than RateOfChangeMin. Rate-of-change-based frequency event detector will not be implemented.')
    RateOfChangeMax = NaN;
    RateOfChangeMin = NaN;
    RateOfChange = NaN;
end
>>>>>>> 0bf136e5f73025ac1a8ca937d3b8fcab74240e27

upperExtreme = [];
lowerExtreme = [];
totalTimeOutsideRange = [];
upperTightExtreme = [];
lowerTightExtreme = [];
totalTimeOutsideTightRange=[];

% find the limits
MaxLoose = DurationMax * 60;
MinLoose = DurationMin * 60;
MaxTight = RateOfChangeMax * 60;
MinTight = RateOfChangeMin * 60;
deltaT = diff(t(1:2));

%% Perform detection
% loop through each signal
for index = 1:size(Data,2)    
    if strcmp(DataUnit(index),'Hz')
        % check the loose limits first
        currentSignal = Data(:,index);
        aboveUpperLimitIndices = currentSignal > MaxLoose;
        belowLowerLimitIndices = currentSignal < MinLoose;
        outOfRangeIndices = aboveUpperLimitIndices | belowLowerLimitIndices;
        % find upper and lower extreme
        upperExtreme = max(currentSignal(aboveUpperLimitIndices));
        lowerExtreme = min(currentSignal(belowLowerLimitIndices));
        totalTimeOutsideRange = size(currentSignal(outOfRangeIndices),1) * deltaT;


        % then check the tight limits
        aboveUpperTightLimitIndices = currentSignal > MaxTight;
        belowLowerTightLimitIndices = currentSignal < MinTight;
        outOfTightRangeIndicesLogic = aboveUpperTightLimitIndices | belowLowerTightLimitIndices

        totalTimeOutsideTightRange = size(currentSignal(outOfTightRangeIndicesLogic),1) * deltaT;

        outOfTightRangeIndices = find(outOfTightRangeIndicesLogic);
        % find the all the out of tight range sections in signal
        rangeStartingIndices = [0; find(diff(outOfTightRangeIndices)>1); length(outOfTightRangeIndices)];
        numberOfOutofrangeRanges = length(rangeStartingIndices)-1;

        nFrequencyResponse = 0;
        % for each out of tight range section
        for nRange = 1:numberOfOutofrangeRanges
            % find the starting index of the section
            startingIndex = outOfTightRangeIndices(rangeStartingIndices(nRange) + 1);
            % find the ending index of the section
            endingIndex = outOfTightRangeIndices(rangeStartingIndices(nRange + 1));
            % calculate all the rate of change in this section
            deltaFInThisRange = diff(currentSignal(startingIndex-1:endingIndex+1));
            % find the value and location of the maximum rate of change in this
            % section
            [peakValue,peakIndex]=max(abs(deltaFInThisRange));
            % if the above found maximum rate of change is larger than
            % threshold, then figure out the frequency response of A,B,C points
            if peakValue> RateOfChange
                nFrequencyResponse = nFrequencyResponse + 1;
                tZeroIndex = peakIndex+startingIndex-1;
                timeBeforePointA = 16/deltaT;
                transientPeriod = 20/deltaT;
                TimeAfterPointB = 32/deltaT;
                % find partial array end in the index where the max rate change
                % is
                partialDeltaFInThisRange = deltaFInThisRange(1:peakIndex);
                if deltaFInThisRange(peakIndex)<0
                    % sudden drop, go back from the maximum rate change up to
                    % the top point where the drop started
                    pointAIndex = find(partialDeltaFInThisRange>0,1,'last')+startingIndex-1;
                else
                    % sudden increase, go back from the maximum rate change
                    % down to the lowest point where the increase started
                    pointAIndex = find(partialDeltaFInThisRange<0,1,'last')+startingIndex-1;
                end
                if timeBeforePointA < pointAIndex
                    startingTimeIndex = pointAIndex - timeBeforePointA+1;
                else
                    % edge case where A is less than 16 seconds from the start
                    % of the signal
                    startingTimeIndex = 0;
                end
                response(nFrequencyResponse).A = mean(currentSignal(startingTimeIndex:pointAIndex));
                if pointAIndex+transientPeriod > length(currentSignal)
                    % edge case where transient period is less than 20 seconds
                    pointBIndex = length(currentSignal);
                else
                    pointBIndex = pointAIndex+transientPeriod;
                end
                if pointBIndex+TimeAfterPointB > length(currentSignal)
                    % edge case where B point is less than 32 seconds till the
                    % end of the signal
                    response(nFrequencyResponse).B = mean(currentSignal(pointBIndex+1:end));
                else
                    response(nFrequencyResponse).B = mean(currentSignal(pointBIndex+1:pointBIndex+TimeAfterPointB));
                end
                if deltaFInThisRange(peakIndex)<0
                    % sudden drop, C is the lowest point during transient
                    % period
                    response(nFrequencyResponse).C = min(currentSignal(pointAIndex+1:pointBIndex));
                    lowerTightExtreme(nFrequencyResponse) = response(nFrequencyResponse).C;
                else
                    % sudden increase, C is the highest point during transient
                    % period
                    response(nFrequencyResponse).C = max(currentSignal(pointAIndex+1:pointBIndex));
                    upperTightExtreme(nFrequencyResponse) = response(nFrequencyResponse).C;
                end
            end
        end
        % if out of loose range, reporting the one peak out of loose range and all
        % frequency response (if requested)
        if totalTimeOutsideRange > Duration
            DetectionResults(index).PMU = DataPMU(index);
            DetectionResults(index).Channel = DataChannel(index);
            if isempty(upperExtreme)
                DetectionResults(index).Max = NaN;
            else
                DetectionResults(index).Max = upperExtreme;
            end
            if isempty(lowerExtreme)
                DetectionResults(index).Min = NaN;
            else                
                DetectionResults(index).Min = lowerExtreme;
            end
            DetectionResults(index).Duration = totalTimeOutsideRange;       
        else
            % if not out of loose range, reporting the all peaks that is out of
            % tight range and over the rate of change threshold, plus all the
            % frequency response (if requested)
            DetectionResults(index).PMU = DataPMU(index);
            DetectionResults(index).Channel = DataChannel(index);
            if isempty(upperTightExtreme)
                DetectionResults(index).Max = NaN;
            else
                DetectionResults(index).Max = upperTightExtreme;
            end
            if isemtpy(lowerTightExtreme)
                DetectionResults(index).Min = NaN;
            else
                DetectionResults(index).Min = lowerTightExtreme;
            end
            if isemtpy(totalTimeOutsideTightRange)
                DetectionResults(index).Duration = NaN;
            else
                DetectionResults(index).Duration = totalTimeOutsideTightRange;
            end
        end
        if FrequencyResponse
            DetectionResults(index).Response = response;
        end
    else
        waring(['Wrong signal type for the out of range frequency detector!'...
            'Only frequency signal allowed, but input is'...
            'type %s of PMU %s, channel %s.',DataType(index),DataPMU(index),DataChannel(index)]);
        DetectionResults(index).PMU = DataPMU(index);
        DetectionResults(index).Channel = DataChannel(index);
        DetectionResults(index).Max = NaN;
        DetectionResults(index).Min = NaN;
        DetectionResults(index).Duration = NaN; 
    end
end



<<<<<<< HEAD
=======
% Initialize structure to output detection results
DetectionResults = struct('PMU',[],'Channel',[],'DurationOutStart',[],'DurationOutEnd',[],'RateOfChangeOutStart',[],'RateOfChangeOutEnd',[]);
>>>>>>> 0bf136e5f73025ac1a8ca937d3b8fcab74240e27

% Initialize structure for additional outputs
AdditionalOutput = struct('FilterConditions',[]);


if ~isnan(AnalysisWindow)
    % Logical matrix to mark locations where Data goes outside of the detection
    % thresholds for the duration-based detector. The matrix remains false 
    % where Data is NaN so that these values are ignored, as specified.
    OutOfBoundsDuration = false(size(Data));
    % Set the matrix to true where Data goes above its upper detection
    % threshold. DurationMax is only NaN when it is not to be included.
    if ~isnan(DurationMax)
        OutOfBoundsDuration(Data > DurationMax) = true;
    end
    % Set the matrix to true where Data goes below its lower detection
    % threshold. DurationMin is only NaN when it is not to be included.
    if ~isnan(DurationMin)
        OutOfBoundsDuration(Data < DurationMin) = true;
    end

    % Loop throught each signal
    for index = 1:size(Data,2)
        % Store the PMU and channel name
        DetectionResults(index).PMU = DataPMU(index);
        DetectionResults(index).Channel = DataChannel(index);

        if isempty(PastAdditionalOutput)
            % PastAdditionalOutput isn't available
            InitConditions = [];
        else
            InitConditions = PastAdditionalOutput(index).FilterConditions;
        end

        [OutsideCount, AdditionalOutput(index).FilterConditions] = filter(ones(1,AnalysisWindow),1,OutOfBoundsDuration(:,index),InitConditions);

        DetectionIdx = OutsideCount > Duration;

        OutStart = {};
        OutEnd = {};
        if sum(DetectionIdx) > 0
            % Out-of-range data was detected

            % Start and end of out-of-range data (window length is accounted
            % for later)
            Starts = find(diff([0; DetectionIdx]) == 1);
            Ends = find(diff(DetectionIdx) == -1);

            if length(Starts) > length(Ends)
                Ends = [Ends; length(DetectionIdx)];
            end

            for OutIdx = 1:length(Starts)
                OutStart{OutIdx} = datestr(datenum(TimeString{Starts(OutIdx)})-(AnalysisWindow/fs)/(60*60*24),'yyyy-mm-dd HH:MM:SS.FFF');
                OutEnd{OutIdx} = TimeString{Ends(OutIdx)};
            end
        end

        DetectionResults(index).DurationOutStart = OutStart;
        DetectionResults(index).DurationOutEnd = OutEnd;
    end
else
    % Detector cannot be implemented
    
    % Loop throught each signal
    for index = 1:size(Data,2)
        % Store the PMU and channel name
        DetectionResults(index).PMU = DataPMU(index);
        DetectionResults(index).Channel = DataChannel(index);
        DetectionResults(index).DurationOutStart = NaN;
        DetectionResults(index).DurationOutEnd = NaN;
    end
end



if ~isnan(RateOfChange)
    % Logical matrix to mark locations where Data goes outside of the detection
    % thresholds for the rate-of-change-based detector. The matrix remains false 
    % where Data is NaN so that these values are ignored, as specified.
    OutOfBoundsRateOfChange = false(size(Data));
    % Set the matrix to true where Data goes above its upper detection
    % threshold. RateOfChangeMax is only NaN when it is not to be included.
    if ~isnan(DurationMax)
        OutOfBoundsRateOfChange(Data > RateOfChangeMax) = true;
    end
    % Set the matrix to true where Data goes below its lower detection
    % threshold. RateOfChangeMin is only NaN when it is not to be included.
    if ~isnan(DurationMin)
        OutOfBoundsRateOfChange(Data < RateOfChangeMin) = true;
    end

    % Find the rate of change - loop through each signal
    for index = 1:size(Data,2)
        [PeakVals, PeakLocs] = findpeaks(Data(:,index));
        [ValleyVals, ValleyLocs] = findpeaks(-Data(:,index));
        ValleyVals = -ValleyVals;

        % Create a list of alternating maxima and minima
        ExtremeVals = [PeakVals; ValleyVals];
        ExtremeLocs = [PeakLocs; ValleyLocs];
        [ExtremeLocs, SortIdx] = sort(ExtremeLocs);
        ExtremeVals = ExtremeVals(SortIdx);

        % Add start and end points
        ExtremeLocs = [1; ExtremeLocs; size(Data,1)];
        ExtremeVals = [Data(1,index); ExtremeVals; Data(end,index)];

        SampChange = diff(ExtremeLocs);
        FreqChange = abs(diff(ExtremeVals));

        Rate = FreqChange./SampChange;
        OverRate = find(Rate > RateOfChange);

        ExtremeIdx = false(size(Data,1),1);
        for OverRateIdx = OverRate.'
            ExtremeIdx(ExtremeLocs(OverRateIdx):ExtremeLocs(OverRateIdx+1)) = true;
        end
    %     DetectionIdx = OutOfBoundsRateOfChange(:,index) & ExtremeIdx;

        DetectionIdx = OutOfBoundsRateOfChange(:,index);

        OutStart = {};
        OutEnd = {};
        if sum(DetectionIdx) > 0
            % Out-of-range data was detected

            % Start and end of out-of-range data
            Starts = find(diff([0; DetectionIdx]) == 1);
            Ends = find(diff(DetectionIdx) == -1);

            if length(Starts) > length(Ends)
                Ends = [Ends; length(DetectionIdx)];
            end

            for OutIdx = 1:length(Starts)
                if sum(ExtremeIdx(Starts(OutIdx):Ends(OutIdx))) > 0          
                    OutStart{OutIdx} = TimeString{Starts(OutIdx)};
                    OutEnd{OutIdx} = TimeString{Ends(OutIdx)};
                end
            end
        end

        DetectionResults(index).RateOfChangeOutStart = OutStart;
        DetectionResults(index).RateOfChangeOutEnd = OutEnd;
    end
else
    % Detector cannot be implemented
    
    % Loop through each signal
    for index = 1:size(Data,2)
        DetectionResults(index).RateOfChangeOutStart = NaN;
        DetectionResults(index).RateOfChangeOutEnd = NaN;
    end
end

end

%% Nested functions

% This function pulls the parameters out of the structure containing the
% XML information. It turns strings into numbers as necessary and sets
% default values for parameters that were not specified. Additional inputs,
% such as the length of the input data or the sampling rate, can be added
% as necessary. 
<<<<<<< HEAD
function ExtractedParameters = ExtractParameters(Parameters)
% If TRUE, the frequency response measures are returned. If FALSE or omitted, the measures are not returned
if isfield(Parameters,'FrequencyResponse')
    % Use specified frequency response
    FrequencyResponse = Parameters.FrequencyResponse;
else
    FrequencyResponse = False;
end

% Upper threshold for the normal range as percentage of nominal. If omitted, it is not considered.
if isfield(Parameters,'DurationMax')
    DurationMax = str2double(Parameters.DurationMax);
else
    DurationMax = NaN;
end

% Lower threshold for the normal range as percentage of nominal. If omitted, it is not considered.
if isfield(Parameters, 'DurationMin')
    DurationMin = str2double(Parameters.DurationMin);
else
    DurationMin = NaN;
end

% Duration threshold in samples. If omitted, it is set to zero.
if isfield(Parameters, 'Duration')
    Duration = str2double(Parameters.Duration);
else
    Duration = 0;
end

% Upper threshold for the normal range as percentage of nominal. If omitted, it is not considered.
if isfield(Parameters, 'RateOfChangeMax')
    RateOfChangeMax = str2double(Parameters.RateOfChangeMax);
else
    RateOfChangeMax = NaN;
end

% Lower threshold for the normal range as percentage of nominal. If omitted, it is not considered.
if isfield(Parameters, 'RateOfChangeMin')
    RateOfChangeMin = str2double(Parameters.RateOfChangeMin);
else
    RateOfChangeMin = NaN;
end

% Rate-of-change threshold in Hz/sample. If omitted, this part of the detector is not implemented.
if isfield(Parameters, 'RateOfChange')
    RateOfChange = str2double(Parameters.RateOfChange);
else
    RateOfChange = NaN;
end

ExtractedParameters = struct('FrequencyResponse',FrequencyResponse,'DurationMax',DurationMax,...
    'DurationMin',DurationMin,'Duration',Duration,'RateOfChangeMax',RateOfChangeMax,...
    'RateOfChangeMin',RateOfChangeMin,'RateOfChange',RateOfChange);
=======
function ExtractedParameters = ExtractParameters(Parameters,fs)

% % Return frequency response measures?
% if isfield(Parameters,'FrequencyResponse')
%     % User has made a selection
%     if ~strcmp(Parameters.FrequencyResponse,'TRUE')
%         % Frequency response measures are to be returned
%         FrequencyResponse = true;
%     elseif ~strcmp(Parameters.FrequencyResponse,'FALSE')
%         % Frequency response measures are not to be returned
%         FrequencyResponse = false;
%     else
%         % User entry is unacceptable, use default (not returned)
%         FrequencyResponse = false;
%     end
% else
%     % User did not specify, use default (not returned)
%     FrequencyResponse = false;
% end

% Upper threshold for duration-based detector
if isfield(Parameters,'DurationMax')
    % Use specified DurationMax, upper threshold
    DurationMax = str2double(Parameters.DurationMax);
    
    if isnan(DurationMax)
        % str2double sets the value to NaN when it can't make it a number
        warning('DurationMax is not a number and will be ignored in duration-based frequency event detector.');
    end
else
    % Upper threshold is not considered 
    DurationMax = NaN;
end

% Lower threshold for duration-based detector
if isfield(Parameters,'DurationMin')
    % Use specified DurationMin, lower threshold
    DurationMin = str2double(Parameters.DurationMin);
    
    if isnan(DurationMin)
        % str2double sets the value to NaN when it can't make it a number
        warning('DurationMin is not a number and will be ignored in duration-based frequency event detector.');
    end
else
    % Lower threshold is not considered 
    DurationMin = NaN;
end

% Duration threshold
if isfield(Parameters,'Duration')
    % Use specified Duration threshold
    % Multiplication by fs produces units of samples
    Duration = round(str2double(Parameters.Duration)*fs);
    
    if isnan(Duration)
        % str2double sets the value to NaN when it can't make it a number
        warning('Duration is not a number. Default of 0 will be used');
        Duration = 0;
    end
else
    % Duration threshold is set to zero 
    Duration = 0;
end

% Analysis window size
if isfield(Parameters,'AnalysisWindow')
    % Use specified analysis window length
    % Multiplication by fs produces units of samples
    AnalysisWindow = str2double(Parameters.AnalysisWindow)*fs;
    
    if isnan(AnalysisWindow)
        % str2double sets the value to NaN when it can't make it a number
        warning('AnalysisWindow is not a number. Duration based frequency event detector will not be implemented.');
    end
else
    warning('Analysis window length was not specified. The duration based frequency event detector will not be implemented.');
    AnalysisWindow = NaN;
end

% Upper threshold for rate-of-change-based detector
if isfield(Parameters,'RateOfChangeMax')
    % Use specified RateOfChangeMax, upper threshold
    RateOfChangeMax = str2double(Parameters.RateOfChangeMax);
    
    if isnan(RateOfChangeMax)
        % str2double sets the value to NaN when it can't make it a number
        warning('RateOfChangeMax is not a number and will be ignored');
    end
else
    % Upper threshold is not considered 
    RateOfChangeMax = NaN;
end

% Lower threshold for rate-of-change-based detector
if isfield(Parameters,'RateOfChangeMin')
    % Use specified DurationMin, lower threshold
    RateOfChangeMin = str2double(Parameters.RateOfChangeMin);
    
    if isnan(RateOfChangeMin)
        % str2double sets the value to NaN when it can't make it a number
        warning('RateOfChangeMin is not a number and will be ignored');
    end
else
    % Lower threshold is not considered 
    RateOfChangeMin = NaN;
end

% Rate of change threshold
if isfield(Parameters,'RateOfChange')
    % Use specified RateOfChange threshold
    % Division by fs produces units of Hz/sample
    RateOfChange = str2double(Parameters.RateOfChange)/fs;
    
    if isnan(RateOfChange)
        % str2double sets the value to NaN when it can't make it a number
        warning('RateOfChange is not a number. Rate-of-change based frequency detector will not be implemented.');
    end
else
    % RateOfChange threshold is not considered 
    RateOfChange = NaN;
end

ExtractedParameters = struct('DurationMax',DurationMax,...
    'DurationMin',DurationMin,'Duration',Duration,...
    'RateOfChangeMax',RateOfChangeMax,'RateOfChangeMin',RateOfChangeMin,...
    'RateOfChange',RateOfChange,'AnalysisWindow',AnalysisWindow);
>>>>>>> 0bf136e5f73025ac1a8ca937d3b8fcab74240e27

end